<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>fmpz.h – integers &#8212; Flint 2.9.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    
    <script src="_static/documentation_options.js?v=182a64a0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="fmpz_vec.h – vectors of integers" href="fmpz_vec.html" />
    <link rel="prev" title="ulong_extras.h – arithmetic and number-theoretic functions for single-word integers" href="ulong_extras.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fmpz_vec.html" title="fmpz_vec.h – vectors of integers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="ulong_extras.html" title="ulong_extras.h – arithmetic and number-theoretic functions for single-word integers"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>fmpz.h</strong> – integers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="fmpz-h-integers">
<span id="fmpz"></span><h1><strong>fmpz.h</strong> – integers<a class="headerlink" href="#fmpz-h-integers" title="Link to this heading">¶</a></h1>
<section id="types-macros-and-constants">
<h2>Types, macros and constants<a class="headerlink" href="#types-macros-and-constants" title="Link to this heading">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.fmpz">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz</span></span></span><a class="headerlink" href="#c.fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>an <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> is implemented as an <span class="math notranslate nohighlight">\(slong\)</span>. When its second most significant
bit is <span class="math notranslate nohighlight">\(0\)</span> the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> represents an ordinary <code class="docutils literal notranslate"><span class="pre">slong</span></code> integer whose
absolute value is at most <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span> <span class="pre">-</span> <span class="pre">2</span></code> bits.</p>
<p>When the second most significant bit is <span class="math notranslate nohighlight">\(1\)</span> then the value represents a
pointer (the pointer is shifted right <span class="math notranslate nohighlight">\(2\)</span> bits and the second most
significant bit is set to <span class="math notranslate nohighlight">\(1\)</span>. This relies on the fact that <code class="docutils literal notranslate"><span class="pre">malloc</span></code> always
allocates memory blocks on a <span class="math notranslate nohighlight">\(4\)</span> or <span class="math notranslate nohighlight">\(8\)</span> byte boundary).</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.fmpz_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_t</span></span></span><a class="headerlink" href="#c.fmpz_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>An array of length 1 of <code class="docutils literal notranslate"><span class="pre">fmpz</span></code>’s. This is used to pass <code class="docutils literal notranslate"><span class="pre">fmpz</span></code>’s around by
reference without fuss, similar to the way <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> work.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.COEFF_MAX">
<span class="sig-name descname"><span class="n"><span class="pre">COEFF_MAX</span></span></span><a class="headerlink" href="#c.COEFF_MAX" title="Link to this definition">¶</a><br /></dt>
<dd><p>the largest (positive) value an <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> can be if just an <code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c macro">
<dt class="sig sig-object c" id="c.COEFF_MIN">
<span class="sig-name descname"><span class="n"><span class="pre">COEFF_MIN</span></span></span><a class="headerlink" href="#c.COEFF_MIN" title="Link to this definition">¶</a><br /></dt>
<dd><p>the smallest (negative) value an <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> can be if just an <code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.PTR_TO_COEFF">
<a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">PTR_TO_COEFF</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">__mpz_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ptr</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.PTR_TO_COEFF" title="Link to this definition">¶</a><br /></dt>
<dd><p>a macro to convert an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> (or more generally any <code class="docutils literal notranslate"><span class="pre">__mpz_struct</span> <span class="pre">*</span></code>)
to an <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> (shifts the pointer right by <span class="math notranslate nohighlight">\(2\)</span> and sets the second most
significant bit).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.COEFF_TO_PTR">
<span class="n"><span class="pre">__mpz_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">COEFF_TO_PTR</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.COEFF_TO_PTR" title="Link to this definition">¶</a><br /></dt>
<dd><p>a macro to convert an <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> which represents a pointer into an actual
pointer to an <code class="docutils literal notranslate"><span class="pre">__mpz_struct</span></code> (i.e. to an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.COEFF_IS_MPZ">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">COEFF_IS_MPZ</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.COEFF_IS_MPZ" title="Link to this definition">¶</a><br /></dt>
<dd><p>a macro which returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(f\)</span> represents an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code>, otherwise <span class="math notranslate nohighlight">\(0\)</span> is
returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_new_mpz">
<span class="n"><span class="pre">__mpz_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_new_mpz</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">void</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_new_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>initialises a new <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> and returns a pointer to it. This is only used
internally.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_clear_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_clear_mpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_clear_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>clears the <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> “pointed to” by the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> <span class="math notranslate nohighlight">\(f\)</span>. This is only used
internally.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_cleanup_mpz_content">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_cleanup_mpz_content</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_cleanup_mpz_content" title="Link to this definition">¶</a><br /></dt>
<dd><p>this function does nothing in the reentrant version of <code class="docutils literal notranslate"><span class="pre">fmpz</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_cleanup">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_cleanup</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_cleanup" title="Link to this definition">¶</a><br /></dt>
<dd><p>this function does nothing in the reentrant version of <code class="docutils literal notranslate"><span class="pre">fmpz</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_promote">
<span class="n"><span class="pre">__mpz_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_promote</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_promote" title="Link to this definition">¶</a><br /></dt>
<dd><p>if <span class="math notranslate nohighlight">\(f\)</span> doesn’t represent an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code>, initialise one and associate it to
<span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_promote_val">
<span class="n"><span class="pre">__mpz_struct</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_promote_val</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_promote_val" title="Link to this definition">¶</a><br /></dt>
<dd><p>if <span class="math notranslate nohighlight">\(f\)</span> doesn’t represent an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code>, initialise one and associate it to
<span class="math notranslate nohighlight">\(f\)</span>, but preserve the value of <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>This function is for internal use. The resulting <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> will be backed by
an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> that can be passed to GMP, but the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> will be in an
inconsistent state with respect to the other Flint <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> functions such as
<code class="docutils literal notranslate"><span class="pre">fmpz_is_zero</span></code>, etc.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_demote">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_demote</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_demote" title="Link to this definition">¶</a><br /></dt>
<dd><p>if <span class="math notranslate nohighlight">\(f\)</span> represents an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> clear it and make <span class="math notranslate nohighlight">\(f\)</span> just represent an
<code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_demote_val">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_demote_val</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_demote_val" title="Link to this definition">¶</a><br /></dt>
<dd><p>if <span class="math notranslate nohighlight">\(f\)</span> represents an <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> and its value will fit in an <code class="docutils literal notranslate"><span class="pre">slong</span></code>,
preserve the value in <span class="math notranslate nohighlight">\(f\)</span> which we make to represent an <code class="docutils literal notranslate"><span class="pre">slong</span></code>, and
clear the <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code>.</p>
</dd></dl>

</section>
<section id="memory-management">
<h2>Memory management<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>A small <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> is initialised, i.e.just a <code class="docutils literal notranslate"><span class="pre">slong</span></code>.
The value is set to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_init2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_init2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">limbs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_init2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises the given <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> to have space for the given
number of limbs.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">limbs</span></code> is zero then a small <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> is allocated,
i.e.just a <code class="docutils literal notranslate"><span class="pre">slong</span></code>.  The value is also set to zero.  It is
not necessary to call this function except to save time.  A call
to <code class="docutils literal notranslate"><span class="pre">fmpz_init</span></code> will do just fine.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the given <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code>, releasing any memory associated
with it, either back to the stack or the OS, depending on
whether the reentrant or non-reentrant version of FLINT is built.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_init_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_init_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_init_set" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_init_set_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_init_set_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_init_set_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_init_set_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_init_set_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_init_set_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises <span class="math notranslate nohighlight">\(f\)</span> and sets it to the value of <span class="math notranslate nohighlight">\(g\)</span>.</p>
</dd></dl>

</section>
<section id="random-generation">
<h2>Random generation<a class="headerlink" href="#random-generation" title="Link to this heading">¶</a></h2>
<p>For thread-safety, the randomisation methods take as one of their
parameters an object of type <code class="docutils literal notranslate"><span class="pre">flint_rand_t</span></code>.  Before calling
any of the randomisation functions such an object first has to be
initialised with a call to <a class="reference internal" href="flint.html#c.flint_randinit" title="flint_randinit"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_randinit()</span></code></a>.  When one is
finished generating random numbers, one should call
<a class="reference internal" href="flint.html#c.flint_randclear" title="flint_randclear"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_randclear()</span></code></a> to clean up.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randbits">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randbits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randbits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generates a random signed integer whose absolute value has precisely
the given number of bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randtest">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generates a random signed integer whose absolute value has a number
of bits which is random from <span class="math notranslate nohighlight">\(0\)</span> up to <code class="docutils literal notranslate"><span class="pre">bits</span></code> inclusive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randtest_unsigned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randtest_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randtest_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generates a random unsigned integer whose value has a number
of bits which is random from <span class="math notranslate nohighlight">\(0\)</span> up to <code class="docutils literal notranslate"><span class="pre">bits</span></code> inclusive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randtest_not_zero">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randtest_not_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randtest_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">fmpz_randtest</span></code>, but the result will not be <span class="math notranslate nohighlight">\(0\)</span>.
If <code class="docutils literal notranslate"><span class="pre">bits</span></code> is set to <span class="math notranslate nohighlight">\(0\)</span>, an exception will result.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generates a random integer in the range <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(m - 1\)</span> inclusive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randtest_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randtest_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randtest_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generates a random integer in the range <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(m - 1\)</span> inclusive,
with an increased probability of generating values close to
the endpoints.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randtest_mod_signed">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randtest_mod_signed</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randtest_mod_signed" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generates a random integer in the range <span class="math notranslate nohighlight">\((-m/2, m/2]\)</span>, with an
increased probability of generating values close to the
endpoints or close to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_randprime">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_randprime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_randprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generates a random prime number with the given number of bits.</p>
<p>The generation is performed by choosing a random number and then
finding the next largest prime, and therefore does not quite
give a uniform distribution over the set of primes with that
many bits.</p>
<p>Random number generation is performed using the standard Flint
random number generator, which is not suitable for cryptographic use.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">proved</span></code> is nonzero, then the integer returned is
guaranteed to actually be prime.</p>
</dd></dl>

</section>
<section id="conversion">
<h2>Conversion<a class="headerlink" href="#conversion" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_si">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_si</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(f\)</span> as a <code class="docutils literal notranslate"><span class="pre">slong</span></code>.  The result is undefined
if <span class="math notranslate nohighlight">\(f\)</span> does not fit into a <code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_ui">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(f\)</span> as an <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.  The result is undefined
if <span class="math notranslate nohighlight">\(f\)</span> does not fit into an <code class="docutils literal notranslate"><span class="pre">ulong</span></code> or is negative.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_uiui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hi</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">low</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(f\)</span> consists of two limbs, then <code class="docutils literal notranslate"><span class="pre">*hi</span></code> and <code class="docutils literal notranslate"><span class="pre">*low</span></code> are set to the high
and low limbs, otherwise <code class="docutils literal notranslate"><span class="pre">*low</span></code> is set to the low limb and <code class="docutils literal notranslate"><span class="pre">*hi</span></code> is set
to <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_nmod">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_nmod</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">nmod_t</span></span><span class="w"> </span><span class="n"><span class="pre">mod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_nmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(f \mod n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_d">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_d</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(f\)</span> as a <code class="docutils literal notranslate"><span class="pre">double</span></code>, rounding down towards zero if
<span class="math notranslate nohighlight">\(f\)</span> cannot be represented exactly. The outcome is undefined
if <span class="math notranslate nohighlight">\(f\)</span> is too large to fit in the normal range of a double.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_mpf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_mpf</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpf_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_mpf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the <code class="docutils literal notranslate"><span class="pre">mpf_t</span></code> <span class="math notranslate nohighlight">\(x\)</span>, rounding down towards zero if
the value of <span class="math notranslate nohighlight">\(x\)</span> is fractional.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_mpf">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_mpf</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpf_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_mpf" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the value of the <code class="docutils literal notranslate"><span class="pre">mpf_t</span></code> <span class="math notranslate nohighlight">\(x\)</span> to the value of <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_mpfr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_mpfr</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpfr_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">mpfr_rnd_t</span></span><span class="w"> </span><span class="n"><span class="pre">rnd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_mpfr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the value of <span class="math notranslate nohighlight">\(x\)</span> from <span class="math notranslate nohighlight">\(f\)</span>, rounded toward the given
direction <code class="docutils literal notranslate"><span class="pre">rnd</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_d_2exp">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_d_2exp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_d_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(f\)</span> as a normalized <code class="docutils literal notranslate"><span class="pre">double</span></code> along with a <span class="math notranslate nohighlight">\(2\)</span>-exponent
<code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e.if <span class="math notranslate nohighlight">\(r\)</span> is the return value then <span class="math notranslate nohighlight">\(f = r 2^{exp}\)</span>,
to within 1 ULP.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_mpz</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> <span class="math notranslate nohighlight">\(x\)</span> to the same value as <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_mpn">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_mpn</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n_in</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_mpn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">mp_ptr</span></code> <span class="math notranslate nohighlight">\(n\)</span> to the same value as <span class="math notranslate nohighlight">\(n_{in}\)</span>. Returned
integer is number of limbs allocated to <span class="math notranslate nohighlight">\(n\)</span>, minimum number of limbs
required to hold the value stored in <span class="math notranslate nohighlight">\(n_{in}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_str">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_str</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the representation of <span class="math notranslate nohighlight">\(f\)</span> in base <span class="math notranslate nohighlight">\(b\)</span>, which can vary
between <span class="math notranslate nohighlight">\(2\)</span> and <span class="math notranslate nohighlight">\(62\)</span>, inclusive.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">str</span></code> is <code class="docutils literal notranslate"><span class="pre">NULL</span></code>, the result string is allocated by
the function.  Otherwise, it is up to the caller to ensure that
the allocated block of memory is sufficiently large.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">val</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the given <code class="docutils literal notranslate"><span class="pre">slong</span></code> value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">val</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the given <code class="docutils literal notranslate"><span class="pre">ulong</span></code> value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_d">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_d</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the <code class="docutils literal notranslate"><span class="pre">double</span></code> <span class="math notranslate nohighlight">\(c\)</span>, rounding down towards zero if
the value of <span class="math notranslate nohighlight">\(c\)</span> is fractional. The outcome is undefined if <span class="math notranslate nohighlight">\(c\)</span> is
infinite, not-a-number, or subnormal.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_d_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_d_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_d_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the nearest integer to <span class="math notranslate nohighlight">\(d 2^{exp}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_neg_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_neg_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">val</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_neg_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the given <code class="docutils literal notranslate"><span class="pre">ulong</span></code> value, and then negates <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_uiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">hi</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">lo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <code class="docutils literal notranslate"><span class="pre">lo</span></code>, plus <code class="docutils literal notranslate"><span class="pre">hi</span></code> shifted to the left by
<code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_neg_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_neg_uiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">hi</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">lo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_neg_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <code class="docutils literal notranslate"><span class="pre">lo</span></code>, plus <code class="docutils literal notranslate"><span class="pre">hi</span></code> shifted to the left by
<code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>, and then negates <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_signed_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_signed_uiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">hi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">lo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_signed_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <code class="docutils literal notranslate"><span class="pre">lo</span></code>, plus <code class="docutils literal notranslate"><span class="pre">hi</span></code> shifted to the left by
<code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>, interpreted as a signed two’s complement
integer with <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_signed_uiuiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_signed_uiuiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">hi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">mid</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">lo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_signed_uiuiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <code class="docutils literal notranslate"><span class="pre">lo</span></code>, plus <code class="docutils literal notranslate"><span class="pre">mid</span></code> shifted to the left by
<code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>, plus <code class="docutils literal notranslate"><span class="pre">hi</span></code> shifted to the left by
<code class="docutils literal notranslate"><span class="pre">2*FLINT_BITS</span></code> bits, interpreted as a signed two’s complement
integer with <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">*</span> <span class="pre">FLINT_BITS</span></code> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_ui_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_ui_array</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">out</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">in</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_ui_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">out</span></code> to the nonnegative integer
<code class="docutils literal notranslate"><span class="pre">in[0]</span> <span class="pre">+</span> <span class="pre">in[1]*X</span>&#160; <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">in[n</span> <span class="pre">-</span> <span class="pre">1]*X^(n</span> <span class="pre">-</span> <span class="pre">1)</span></code>
where <code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">2^FLINT_BITS</span></code>. It is assumed that <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_signed_ui_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_signed_ui_array</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">out</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">in</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_signed_ui_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">out</span></code> to the integer represented in <code class="docutils literal notranslate"><span class="pre">in[0],</span> <span class="pre">...,</span> <span class="pre">in[n</span> <span class="pre">-</span> <span class="pre">1]</span></code>
as a signed two’s complement integer with <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">FLINT_BITS</span></code> bits.
It is assumed that <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. The function operates as a call to
<a class="reference internal" href="#c.fmpz_set_ui_array" title="fmpz_set_ui_array"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_set_ui_array()</span></code></a> followed by a symmetric remainder modulo
<span class="math notranslate nohighlight">\(2^(n*FLINT\_BITS)\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_get_ui_array">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_get_ui_array</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">in</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_get_ui_array" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assuming that the nonnegative integer <code class="docutils literal notranslate"><span class="pre">in</span></code> can be represented in the
form <code class="docutils literal notranslate"><span class="pre">out[0]</span> <span class="pre">+</span> <span class="pre">out[1]*X</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span> <span class="pre">out[n</span> <span class="pre">-</span> <span class="pre">1]*X^(n</span> <span class="pre">-</span> <span class="pre">1)</span></code>,
where <span class="math notranslate nohighlight">\(X = 2^{FLINT\_BITS}\)</span>, sets the corresponding elements of <code class="docutils literal notranslate"><span class="pre">out</span></code>
so that this is true. It is assumed that <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_mpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the given <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_str">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_str</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the value given in the null-terminated string <code class="docutils literal notranslate"><span class="pre">str</span></code>,
in base <span class="math notranslate nohighlight">\(b\)</span>. The base <span class="math notranslate nohighlight">\(b\)</span> can vary between <span class="math notranslate nohighlight">\(2\)</span> and <span class="math notranslate nohighlight">\(62\)</span>, inclusive.
Returns <span class="math notranslate nohighlight">\(0\)</span> if the string contains a valid input and <span class="math notranslate nohighlight">\(-1\)</span> otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set_ui_smod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set_ui_smod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set_ui_smod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the signed remainder <span class="math notranslate nohighlight">\(y \equiv x \bmod m\)</span> satisfying
<span class="math notranslate nohighlight">\(-m/2 &lt; y \leq m/2\)</span>, given <span class="math notranslate nohighlight">\(x\)</span> which is assumed to satisfy
<span class="math notranslate nohighlight">\(0 \leq x &lt; m\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.flint_mpz_init_set_readonly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flint_mpz_init_set_readonly</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.flint_mpz_init_set_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the uninitialised <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> <span class="math notranslate nohighlight">\(z\)</span> to the value of the
readonly <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>Note that it is assumed that <span class="math notranslate nohighlight">\(f\)</span> does not change during
the lifetime of <span class="math notranslate nohighlight">\(z\)</span>.</p>
<p>The integer <span class="math notranslate nohighlight">\(z\)</span> has to be cleared by a call to
<a class="reference internal" href="#c.flint_mpz_clear_readonly" title="flint_mpz_clear_readonly"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_mpz_clear_readonly()</span></code></a>.</p>
<p>The suggested use of the two functions is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fmpz_t</span> <span class="n">f</span><span class="p">;</span>
<span class="o">...</span>
<span class="p">{</span>
    <span class="n">mpz_t</span> <span class="n">z</span><span class="p">;</span>

    <span class="n">flint_mpz_init_set_readonly</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="n">foo</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
    <span class="n">flint_mpz_clear_readonly</span><span class="p">(</span><span class="n">z</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This provides a convenient function for user code, only
requiring to work with the types <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> and <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code>.</p>
<p>In critical code, the following approach may be favourable:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fmpz_t</span> <span class="n">f</span><span class="p">;</span>
<span class="o">...</span>
<span class="p">{</span>
    <span class="n">__mpz_struct</span> <span class="o">*</span><span class="n">z</span><span class="p">;</span>

    <span class="n">z</span> <span class="o">=</span> <span class="n">_fmpz_promote_val</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="n">foo</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
    <span class="n">_fmpz_demote_val</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.flint_mpz_clear_readonly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">flint_mpz_clear_readonly</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.flint_mpz_clear_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the readonly <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> <span class="math notranslate nohighlight">\(z\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_init_set_readonly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_init_set_readonly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">z</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_init_set_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the uninitialised <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> <span class="math notranslate nohighlight">\(f\)</span> to a readonly
version of the integer <span class="math notranslate nohighlight">\(z\)</span>.</p>
<p>Note that the value of <span class="math notranslate nohighlight">\(z\)</span> is assumed to remain constant
throughout the lifetime of <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> <span class="math notranslate nohighlight">\(f\)</span> has to be cleared by calling the
function <a class="reference internal" href="#c.fmpz_clear_readonly" title="fmpz_clear_readonly"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_clear_readonly()</span></code></a>.</p>
<p>The suggested use of the two functions is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mpz_t</span> <span class="n">z</span><span class="p">;</span>
<span class="o">...</span>
<span class="p">{</span>
    <span class="n">fmpz_t</span> <span class="n">f</span><span class="p">;</span>

    <span class="n">fmpz_init_set_readonly</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
    <span class="n">foo</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="n">fmpz_clear_readonly</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_clear_readonly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_clear_readonly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_clear_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the readonly <code class="docutils literal notranslate"><span class="pre">fmpz_t</span></code> <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

</section>
<section id="input-and-output">
<h2>Input and output<a class="headerlink" href="#input-and-output" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_read</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a multiprecision integer from <code class="docutils literal notranslate"><span class="pre">stdin</span></code>.  The format is
an optional minus sign, followed by one or more digits.  The
first digit should be non-zero unless it is the only digit.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive number.</p>
<p>This convention is adopted in light of the return values of
<code class="docutils literal notranslate"><span class="pre">scanf</span></code> from the standard library and <code class="docutils literal notranslate"><span class="pre">mpz_inp_str</span></code>
from MPIR.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fread">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fread</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fread" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a multiprecision integer from the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>.  The
format is an optional minus sign, followed by one or more digits.
The first digit should be non-zero unless it is the only digit.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive number.</p>
<p>This convention is adopted in light of the return values of
<code class="docutils literal notranslate"><span class="pre">scanf</span></code> from the standard library and <code class="docutils literal notranslate"><span class="pre">mpz_inp_str</span></code>
from MPIR.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_inp_raw">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_inp_raw</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fin</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_inp_raw" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a multiprecision integer from the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>.  The
format is raw binary format write by <a class="reference internal" href="#c.fmpz_out_raw" title="fmpz_out_raw"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_out_raw()</span></code></a>.</p>
<p>In case of success, return a positive number, indicating number of bytes read.
In case of failure 0.</p>
<p>This function calls the <code class="docutils literal notranslate"><span class="pre">mpz_inp_raw</span></code> function in library gmp. So that it
can read the raw data written by <code class="docutils literal notranslate"><span class="pre">mpz_inp_raw</span></code> directly.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_print">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_print</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the value <span class="math notranslate nohighlight">\(x\)</span> to <code class="docutils literal notranslate"><span class="pre">stdout</span></code>, without a carriage return(CR).
The value is printed as either <span class="math notranslate nohighlight">\(0\)</span>, the decimal digits of a
positive integer, or a minus sign followed by the digits of
a negative integer.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive number.</p>
<p>This convention is adopted in light of the return values of
<code class="docutils literal notranslate"><span class="pre">flint_printf</span></code> from the standard library and <code class="docutils literal notranslate"><span class="pre">mpz_out_str</span></code>
from MPIR.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fprint">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fprint</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fprint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the value <span class="math notranslate nohighlight">\(x\)</span> to <code class="docutils literal notranslate"><span class="pre">file</span></code>, without a carriage return(CR).
The value is printed as either <span class="math notranslate nohighlight">\(0\)</span>, the decimal digits of a
positive integer, or a minus sign followed by the digits of
a negative integer.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive number.</p>
<p>This convention is adopted in light of the return values of
<code class="docutils literal notranslate"><span class="pre">flint_printf</span></code> from the standard library and <code class="docutils literal notranslate"><span class="pre">mpz_out_str</span></code>
from MPIR.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_out_raw">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_out_raw</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fout</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_out_raw" title="Link to this definition">¶</a><br /></dt>
<dd><p>Writes the value <span class="math notranslate nohighlight">\(x\)</span> to <code class="docutils literal notranslate"><span class="pre">file</span></code>.
The value is written in raw binary format. The integer is written in
portable format, with 4 bytes of size information, and that many bytes
of limbs. Both the size and the limbs are written in decreasing
significance order (i.e., in big-endian).</p>
<p>The output can be read with <code class="docutils literal notranslate"><span class="pre">fmpz_inp_raw</span></code>.</p>
<p>In case of success, return a positive number, indicating number of bytes written.
In case of failure, return 0.</p>
<p>The output of this can also be read by <code class="docutils literal notranslate"><span class="pre">mpz_inp_raw</span></code> from GMP &gt;= 2,
Since this function calls the <code class="docutils literal notranslate"><span class="pre">mpz_inp_raw</span></code> function in library gmp.</p>
</dd></dl>

</section>
<section id="basic-properties-and-manipulation">
<h2>Basic properties and manipulation<a class="headerlink" href="#basic-properties-and-manipulation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_sizeinbase">
<span class="n"><span class="pre">size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sizeinbase</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sizeinbase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the size of the absolute value of <span class="math notranslate nohighlight">\(f\)</span> in base <span class="math notranslate nohighlight">\(b\)</span>, measured in
numbers of digits. The base <span class="math notranslate nohighlight">\(b\)</span> can be between <span class="math notranslate nohighlight">\(2\)</span> and <span class="math notranslate nohighlight">\(62\)</span>, inclusive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_bits">
<span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_bits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_bits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bits required to store the absolute
value of <span class="math notranslate nohighlight">\(f\)</span>.  If <span class="math notranslate nohighlight">\(f\)</span> is <span class="math notranslate nohighlight">\(0\)</span> then <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_size">
<span class="n"><span class="pre">mp_size_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of limbs required to store the absolute
value of <span class="math notranslate nohighlight">\(f\)</span>.  If <span class="math notranslate nohighlight">\(f\)</span> is zero then <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_sgn">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sgn</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sgn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(-1\)</span> if the sign of <span class="math notranslate nohighlight">\(f\)</span> is negative, <span class="math notranslate nohighlight">\(+1\)</span> if it is positive,
otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_val2">
<span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_val2</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_val2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the exponent of the largest power of two dividing <span class="math notranslate nohighlight">\(f\)</span>, or
equivalently the number of trailing zeros in the binary expansion of <span class="math notranslate nohighlight">\(f\)</span>.
If <span class="math notranslate nohighlight">\(f\)</span> is zero then <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_swap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_swap</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_swap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Efficiently swaps <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>.  No data is copied.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the same value as <span class="math notranslate nohighlight">\(g\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_zero">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_one">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_one</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to one.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_abs_fits_ui">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_abs_fits_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_abs_fits_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns whether the absolute value of <span class="math notranslate nohighlight">\(f\)</span>
fits into an <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fits_si">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fits_si</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fits_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns whether the value of <span class="math notranslate nohighlight">\(f\)</span> fits into a <code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_setbit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_setbit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_setbit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets bit index <span class="math notranslate nohighlight">\(i\)</span> of <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tstbit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tstbit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tstbit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Test bit index <span class="math notranslate nohighlight">\(i\)</span> of <span class="math notranslate nohighlight">\(f\)</span> and return <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span>, accordingly.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_abs_lbound_ui_2exp">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_abs_lbound_ui_2exp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_abs_lbound_ui_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>For nonzero <span class="math notranslate nohighlight">\(x\)</span>, returns a mantissa <span class="math notranslate nohighlight">\(m\)</span> with exactly <code class="docutils literal notranslate"><span class="pre">bits</span></code> bits and
sets <code class="docutils literal notranslate"><span class="pre">exp</span></code> to an exponent <span class="math notranslate nohighlight">\(e\)</span>, such that <span class="math notranslate nohighlight">\(|x| \ge m 2^e\)</span>. The number
of bits must be between 1 and <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code> inclusive.
The mantissa is guaranteed to be correctly rounded.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_abs_ubound_ui_2exp">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_abs_ubound_ui_2exp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_abs_ubound_ui_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>For nonzero <span class="math notranslate nohighlight">\(x\)</span>, returns a mantissa <span class="math notranslate nohighlight">\(m\)</span> with exactly <code class="docutils literal notranslate"><span class="pre">bits</span></code> bits
and sets <code class="docutils literal notranslate"><span class="pre">exp</span></code> to an exponent <span class="math notranslate nohighlight">\(e\)</span>, such that <span class="math notranslate nohighlight">\(|x| \le m 2^e\)</span>.
The number of bits must be between 1 and <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code> inclusive.
The mantissa is either correctly rounded or one unit too large
(possibly meaning that the exponent is one too large,
if the mantissa is a power of two).</p>
</dd></dl>

</section>
<section id="comparison">
<h2>Comparison<a class="headerlink" href="#comparison" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cmp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cmp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cmp" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cmp_ui">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cmp_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cmp_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cmp_si">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cmp_si</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cmp_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a negative value if <span class="math notranslate nohighlight">\(f &lt; g\)</span>, positive value if <span class="math notranslate nohighlight">\(g &lt; f\)</span>,
otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cmpabs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cmpabs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cmpabs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a negative value if <span class="math notranslate nohighlight">\(\lvert f\rvert &lt; \lvert g\rvert\)</span>, positive value if
<span class="math notranslate nohighlight">\(\lvert g\rvert &lt; \lvert f \rvert\)</span>, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cmp2abs">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cmp2abs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cmp2abs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a negative value if <span class="math notranslate nohighlight">\(\lvert f\rvert &lt; \lvert 2g\rvert\)</span>, positive value if
<span class="math notranslate nohighlight">\(\lvert 2g\rvert &lt; \lvert f \rvert\)</span>, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_equal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_equal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_equal" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_equal_ui">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_equal_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_equal_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_equal_si">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_equal_si</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_equal_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(f\)</span> is equal to <span class="math notranslate nohighlight">\(g\)</span>, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_zero">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(f\)</span> is <span class="math notranslate nohighlight">\(0\)</span>, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_one">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_one</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(f\)</span> is equal to one, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_pm1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_pm1</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_pm1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(f\)</span> is equal to one or minus one, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_even">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_even</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_even" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns whether the integer <span class="math notranslate nohighlight">\(f\)</span> is even.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_odd">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_odd</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_odd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns whether the integer <span class="math notranslate nohighlight">\(f\)</span> is odd.</p>
</dd></dl>

</section>
<section id="basic-arithmetic">
<h2>Basic arithmetic<a class="headerlink" href="#basic-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_neg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_neg</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_neg" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f_1\)</span> to <span class="math notranslate nohighlight">\(-f_2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_abs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_abs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_abs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f_1\)</span> to the absolute value of <span class="math notranslate nohighlight">\(f_2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_add" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_add_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_add_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_add_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_add_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_add_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_add_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g + h\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sub</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sub" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_sub_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sub_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sub_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_sub_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sub_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sub_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g - h\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mul" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mul_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_mul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mul_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g \times h\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mul2_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mul2_uiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mul2_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g \times x \times y\)</span> where <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are of type <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mul_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mul_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mul_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g \times 2^e\)</span>.</p>
<p>Note: Assumes that <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">+</span> <span class="pre">FLINT_BITS</span></code> does not overflow.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_one_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_one_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_one_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(2^e\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_addmul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_addmul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_addmul" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_addmul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_addmul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_addmul_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_addmul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_addmul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_addmul_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(f + g \times h\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_submul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_submul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_submul" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_submul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_submul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_submul_ui" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_submul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_submul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_submul_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(f - g \times h\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fmma">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fmma</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fmma" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(a \times b + c \times d\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fmms">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fmms</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fmms" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(a \times b - c \times d\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cdiv_qr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cdiv_qr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cdiv_qr" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_qr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_qr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_qr" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tdiv_qr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tdiv_qr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tdiv_qr" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_ndiv_qr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_ndiv_qr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_ndiv_qr" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cdiv_q">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cdiv_q</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cdiv_q" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_q">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_q</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_q" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tdiv_q">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tdiv_q</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tdiv_q" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cdiv_q_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cdiv_q_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cdiv_q_si" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_q_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_q_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_q_si" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tdiv_q_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tdiv_q_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tdiv_q_si" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cdiv_q_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cdiv_q_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cdiv_q_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_q_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_q_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_q_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tdiv_q_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tdiv_q_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tdiv_q_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cdiv_q_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cdiv_q_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cdiv_q_2exp" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_q_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_q_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_q_2exp" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tdiv_q_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tdiv_q_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tdiv_q_2exp" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_r">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_r</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_r" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cdiv_r_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cdiv_r_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cdiv_r_2exp" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_r_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_r_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_r_2exp" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tdiv_r_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tdiv_r_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tdiv_r_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the quotient of <span class="math notranslate nohighlight">\(g\)</span> by <span class="math notranslate nohighlight">\(h\)</span> and/or <span class="math notranslate nohighlight">\(s\)</span> to the remainder. For the
<code class="docutils literal notranslate"><span class="pre">2exp</span></code> functions, <code class="docutils literal notranslate"><span class="pre">g</span> <span class="pre">=</span> <span class="pre">2^exp</span></code>. <span class="math notranslate nohighlight">\(If `h\)</span> is <span class="math notranslate nohighlight">\(0\)</span> an exception is raised.</p>
<p>Rounding is made in the following way:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">fdiv</span></code> rounds the quotient via floor rounding.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cdiv</span></code> rounds the quotient via ceil rounding.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tdiv</span></code> rounds the quotient via truncation, i.e. rounding towards zero.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ndiv</span></code> rounds the quotient such that the remainder has the smallest
absolute value. In case of ties, it rounds the quotient towards zero.</p></li>
</ul>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_cdiv_ui">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_cdiv_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_cdiv_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_ui">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_tdiv_ui">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_tdiv_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_tdiv_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the absolute value remainder of <span class="math notranslate nohighlight">\(g\)</span> divided by <span class="math notranslate nohighlight">\(h\)</span>, following the
convention of rounding as seen above. If <span class="math notranslate nohighlight">\(h\)</span> is zero an exception is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divexact">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divexact</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divexact" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divexact_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divexact_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divexact_si" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divexact_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divexact_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divexact_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the quotient of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span>, assuming that the
division is exact, i.e.<span class="math notranslate nohighlight">\(g\)</span> is a multiple of <span class="math notranslate nohighlight">\(h\)</span>.  If <span class="math notranslate nohighlight">\(h\)</span>
is <span class="math notranslate nohighlight">\(0\)</span> an exception is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divexact2_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divexact2_uiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divexact2_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the quotient of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h = x \times y\)</span>, assuming that
the division is exact, i.e.<span class="math notranslate nohighlight">\(g\)</span> is a multiple of <span class="math notranslate nohighlight">\(h\)</span>.
If <span class="math notranslate nohighlight">\(x\)</span> or <span class="math notranslate nohighlight">\(y\)</span> is <span class="math notranslate nohighlight">\(0\)</span> an exception is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divisible">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divisible</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divisible" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divisible_si">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divisible_si</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divisible_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if there is an integer <span class="math notranslate nohighlight">\(q\)</span> with <span class="math notranslate nohighlight">\(f = q g\)</span> and <span class="math notranslate nohighlight">\(0\)</span> if there is
none.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divides">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divides</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divides" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if there is an integer <span class="math notranslate nohighlight">\(q\)</span> with <span class="math notranslate nohighlight">\(f = q g\)</span> and sets <span class="math notranslate nohighlight">\(q\)</span> to the
quotient. Otherwise returns <span class="math notranslate nohighlight">\(0\)</span> and sets <span class="math notranslate nohighlight">\(q\)</span> to <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the remainder of <span class="math notranslate nohighlight">\(g\)</span> divided by <span class="math notranslate nohighlight">\(h\)</span> such that the remainder is
positive. Assumes that <span class="math notranslate nohighlight">\(h\)</span> is not zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mod_ui">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mod_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mod_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the remainder of <span class="math notranslate nohighlight">\(g\)</span> divided by <span class="math notranslate nohighlight">\(h\)</span> such that the remainder is
positive and also returns this value. Raises an exception if <span class="math notranslate nohighlight">\(h\)</span> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_smod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_smod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_smod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the signed remainder <span class="math notranslate nohighlight">\(y \equiv g \bmod h\)</span> satisfying
<span class="math notranslate nohighlight">\(-\lvert h \rvert/2 &lt; y \leq \lvert h\rvert/2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_preinvn_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_preinvn_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_preinvn_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute a precomputed inverse <code class="docutils literal notranslate"><span class="pre">inv</span></code> of <code class="docutils literal notranslate"><span class="pre">f</span></code> for use in the
<code class="docutils literal notranslate"><span class="pre">preinvn</span></code> functions listed below.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_preinvn_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_preinvn_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_preinvn_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clean up the resources used by a precomputed inverse created with the
<a class="reference internal" href="#c.fmpz_preinvn_init" title="fmpz_preinvn_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_preinvn_init()</span></code></a> function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fdiv_qr_preinvn">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fdiv_qr_preinvn</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">hinv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fdiv_qr_preinvn" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <a class="reference internal" href="#c.fmpz_fdiv_qr" title="fmpz_fdiv_qr"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_fdiv_qr()</span></code></a>, but takes a precomputed inverse <code class="docutils literal notranslate"><span class="pre">hinv</span></code>
of <span class="math notranslate nohighlight">\(h\)</span> constructed using <code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_preinvn()</span></code>.</p>
<p>This function will be faster than <a class="reference internal" href="#c.fmpz_fdiv_qr_preinvn" title="fmpz_fdiv_qr_preinvn"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_fdiv_qr_preinvn()</span></code></a> when the
number of limbs of <span class="math notranslate nohighlight">\(h\)</span> is at least <code class="docutils literal notranslate"><span class="pre">PREINVN_CUTOFF</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_pow_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_pow_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_pow_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g^x\)</span>.  Defines <span class="math notranslate nohighlight">\(0^0 = 1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_pow_fmpz">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_pow_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_pow_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g^x\)</span>. Defines <span class="math notranslate nohighlight">\(0^0 = 1\)</span>. Return <span class="math notranslate nohighlight">\(1\)</span> for success and <span class="math notranslate nohighlight">\(0\)</span> for
failure. The function throws only if <span class="math notranslate nohighlight">\(x\)</span> is negative.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_powm_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_powm_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_powm_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_powm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_powm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">e</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_powm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(g^e \bmod{m}\)</span>.  If <span class="math notranslate nohighlight">\(e = 0\)</span>, sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(m \neq 0\)</span>, raises an <code class="docutils literal notranslate"><span class="pre">abort</span></code> signal otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_clog">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_clog</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_clog" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_clog_ui">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_clog_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_clog_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lceil\log_b x\rceil\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(x \geq 1\)</span> and <span class="math notranslate nohighlight">\(b \geq 2\)</span> and that
the return value fits into a signed <code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_flog">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_flog</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_flog" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_flog_ui">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_flog_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_flog_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lfloor\log_b x\rfloor\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(x \geq 1\)</span> and <span class="math notranslate nohighlight">\(b \geq 2\)</span> and that
the return value fits into a signed <code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_dlog">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_dlog</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_dlog" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a double precision approximation of the
natural logarithm of <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>The accuracy depends on the implementation of the floating-point
logarithm provided by the C standard library. The result can
typically be expected to have a relative error no greater than 1-2 bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_sqrtmod">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sqrtmod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sqrtmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(p\)</span> is prime, set <span class="math notranslate nohighlight">\(b\)</span> to a square root of <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(p\)</span> if <span class="math notranslate nohighlight">\(a\)</span> is a
quadratic residue modulo <span class="math notranslate nohighlight">\(p\)</span> and return <span class="math notranslate nohighlight">\(1\)</span>, otherwise return <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(p\)</span> is not prime the return value is with high probability <span class="math notranslate nohighlight">\(0\)</span>,
indicating that <span class="math notranslate nohighlight">\(p\)</span> is not prime, or <span class="math notranslate nohighlight">\(a\)</span> is not a square modulo <span class="math notranslate nohighlight">\(p\)</span>.
If <span class="math notranslate nohighlight">\(p\)</span> is not prime and the return value is <span class="math notranslate nohighlight">\(1\)</span>, the value of <span class="math notranslate nohighlight">\(b\)</span> is
meaningless.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_sqrt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sqrt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sqrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the integer part of the square root of <span class="math notranslate nohighlight">\(g\)</span>, where
<span class="math notranslate nohighlight">\(g\)</span> is assumed to be non-negative.  If <span class="math notranslate nohighlight">\(g\)</span> is negative, an exception
is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_sqrtrem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_sqrtrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_sqrtrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the integer part of the square root of <span class="math notranslate nohighlight">\(g\)</span>, where <span class="math notranslate nohighlight">\(g\)</span> is
assumed to be non-negative, and sets <span class="math notranslate nohighlight">\(r\)</span> to the remainder, that is,
the difference <span class="math notranslate nohighlight">\(g - f^2\)</span>.  If <span class="math notranslate nohighlight">\(g\)</span> is negative, an exception is raised.
The behaviour is undefined if <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(r\)</span> are aliases.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_square">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_square</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_square" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns nonzero if <span class="math notranslate nohighlight">\(f\)</span> is a perfect square and zero otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_root">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_root</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_root" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(r\)</span> to the integer part of the <span class="math notranslate nohighlight">\(n\)</span>-th root of <span class="math notranslate nohighlight">\(f\)</span>. Requires that
<span class="math notranslate nohighlight">\(n &gt; 0\)</span> and that if <span class="math notranslate nohighlight">\(n\)</span> is even then <span class="math notranslate nohighlight">\(f\)</span> be non-negative, otherwise an
exception is raised. The function returns <span class="math notranslate nohighlight">\(1\)</span> if the root was exact,
otherwise <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_perfect_power">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_perfect_power</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">root</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_perfect_power" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(f\)</span> is a perfect power <span class="math notranslate nohighlight">\(r^k\)</span> set <code class="docutils literal notranslate"><span class="pre">root</span></code> to <span class="math notranslate nohighlight">\(r\)</span> and return <span class="math notranslate nohighlight">\(k\)</span>,
otherwise return <span class="math notranslate nohighlight">\(0\)</span>. Note that <span class="math notranslate nohighlight">\(-1, 0, 1\)</span> are all considered perfect
powers. No guarantee is made about <span class="math notranslate nohighlight">\(r\)</span> or <span class="math notranslate nohighlight">\(k\)</span> being the smallest
possible value. Negative values of <span class="math notranslate nohighlight">\(f\)</span> are permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fac_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fac_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fac_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the factorial <span class="math notranslate nohighlight">\(n!\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is an <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_fib_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_fib_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_fib_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the Fibonacci number <span class="math notranslate nohighlight">\(F_n\)</span> where <span class="math notranslate nohighlight">\(n\)</span> is an
<code class="docutils literal notranslate"><span class="pre">ulong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_bin_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_bin_uiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_bin_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the binomial coefficient <span class="math notranslate nohighlight">\({n \choose k}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_rfac_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_rfac_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_rfac_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(r\)</span> to the rising factorial <span class="math notranslate nohighlight">\((x+a) (x+a+1) (x+a+2) \cdots (x+b-1)\)</span>.
Assumes <span class="math notranslate nohighlight">\(b &gt; a\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_rfac_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_rfac_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_rfac_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(r\)</span> to the rising factorial <span class="math notranslate nohighlight">\(x (x+1) (x+2) \cdots (x+k-1)\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_rfac_uiui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_rfac_uiui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_rfac_uiui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(r\)</span> to the rising factorial <span class="math notranslate nohighlight">\(x (x+1) (x+2) \cdots (x+k-1)\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mul_tdiv_q_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mul_tdiv_q_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mul_tdiv_q_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the product <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> divided by <code class="docutils literal notranslate"><span class="pre">2^exp</span></code>, rounding
down towards zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_mul_si_tdiv_q_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_mul_si_tdiv_q_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_mul_si_tdiv_q_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the product <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(x\)</span> divided by <code class="docutils literal notranslate"><span class="pre">2^exp</span></code>, rounding
down towards zero.</p>
</dd></dl>

</section>
<section id="greatest-common-divisor">
<h2>Greatest common divisor<a class="headerlink" href="#greatest-common-divisor" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_gcd_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_gcd_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_gcd_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_gcd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_gcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_gcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the greatest common divisor of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span>.  The
result is always positive, even if one of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> is
negative.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_gcd3">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_gcd3</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_gcd3" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the greatest common divisor of <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(c\)</span>.
This is equivalent to calling <code class="docutils literal notranslate"><span class="pre">fmpz_gcd</span></code> twice, but may be faster.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lcm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lcm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lcm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the least common multiple of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span>.  The
result is always nonnegative, even if one of <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> is
negative.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_gcdinv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_gcdinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_gcdinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given integers <span class="math notranslate nohighlight">\(f, g\)</span> with <span class="math notranslate nohighlight">\(0 \leq f &lt; g\)</span>, computes the
greatest common divisor <span class="math notranslate nohighlight">\(d = \gcd(f, g)\)</span> and the modular
inverse <span class="math notranslate nohighlight">\(a = f^{-1} \pmod{g}\)</span>, whenever <span class="math notranslate nohighlight">\(f \neq 0\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(d\)</span> and <span class="math notranslate nohighlight">\(a\)</span> are not aliased.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_xgcd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_xgcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_xgcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the extended GCD of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>, i.e. the values <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> such
that <span class="math notranslate nohighlight">\(af + bg = d\)</span>, where <span class="math notranslate nohighlight">\(d = \gcd(f, g)\)</span>. Here <span class="math notranslate nohighlight">\(a\)</span> will be the same as
calling <code class="docutils literal notranslate"><span class="pre">fmpz_gcdinv</span></code> when <span class="math notranslate nohighlight">\(f &lt; g\)</span> (or vice versa for <span class="math notranslate nohighlight">\(b\)</span> when <span class="math notranslate nohighlight">\(g &lt; f\)</span>).</p>
<p>To obtain the canonical solution to Bézout’s identity, call
<code class="docutils literal notranslate"><span class="pre">fmpz_xgcd_canonical_bezout</span></code> instead. This is also faster.</p>
<p>Assumes that there is no aliasing among the outputs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_xgcd_canonical_bezout">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_xgcd_canonical_bezout</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_xgcd_canonical_bezout" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the extended GCD <span class="math notranslate nohighlight">\(\operatorname{xgcd}(f, g) = (d, a, b)\)</span> such that
the solution is the canonical solution to Bézout’s identity. We define the
canonical solution to satisfy one of the following if one of the given
conditions apply:</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}\operatorname{xgcd}(\pm g, g) &amp;= \bigl(|g|, 0, \operatorname{sgn}(g)\bigr)\\\operatorname{xgcd}(f, 0) &amp;= \bigl(|f|, \operatorname{sgn}(f), 0\bigr)\\\operatorname{xgcd}(0, g) &amp;= \bigl(|g|, 0, \operatorname{sgn}(g)\bigr)\\\operatorname{xgcd}(f, \mp 1) &amp;= (1, 0, \mp 1)\\\operatorname{xgcd}(\mp 1, g) &amp;= (1, \mp 1, 0)\quad g \neq 0, \pm 1\\\operatorname{xgcd}(\mp 2 d, g) &amp;=
        \bigl(d, {\textstyle\frac{d - |g|}{\mp 2 d}}, \operatorname{sgn}(g)\bigr)\\\operatorname{xgcd}(f, \mp 2 d) &amp;=
        \bigl(d, \operatorname{sgn}(f), {\textstyle\frac{d - |g|}{\mp 2 d}}\bigr).\end{aligned}\end{align} \]</div>
<p>If the pair <span class="math notranslate nohighlight">\((f, g)\)</span> does not satisfy any of these conditions, the solution
<span class="math notranslate nohighlight">\((d, a, b)\)</span> will satisfy the following:</p>
<div class="math notranslate nohighlight">
\[|a| &lt; \Bigl| \frac{g}{2 d} \Bigr|,
\qquad |b| &lt; \Bigl| \frac{f}{2 d} \Bigr|.\]</div>
<p>Assumes that there is no aliasing among the outputs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_xgcd_partial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_xgcd_partial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">co2</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">co1</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r2</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">L</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_xgcd_partial" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function is an implementation of Lehmer extended GCD with early
termination, as used in the <code class="docutils literal notranslate"><span class="pre">qfb</span></code> module. It terminates early when
remainders fall below the specified bound. The initial values <code class="docutils literal notranslate"><span class="pre">r1</span></code>
and <code class="docutils literal notranslate"><span class="pre">r2</span></code> are treated as successive remainders in the Euclidean
algorithm and are replaced with the last two remainders computed. The
values <code class="docutils literal notranslate"><span class="pre">co1</span></code> and <code class="docutils literal notranslate"><span class="pre">co2</span></code> are the last two cofactors and satisfy
the identity <code class="docutils literal notranslate"><span class="pre">co2*r1</span> <span class="pre">-</span> <span class="pre">co1*r2</span> <span class="pre">==</span> <span class="pre">+/-</span> <span class="pre">r2_orig</span></code> upon termination, where
<code class="docutils literal notranslate"><span class="pre">r2_orig</span></code> is the starting value of <code class="docutils literal notranslate"><span class="pre">r2</span></code> supplied, and <code class="docutils literal notranslate"><span class="pre">r1</span></code>
and <code class="docutils literal notranslate"><span class="pre">r2</span></code> are the final values.</p>
<p>Aliasing of inputs is not allowed. Similarly aliasing of inputs and outputs
is not allowed.</p>
</dd></dl>

</section>
<section id="modular-arithmetic">
<h2>Modular arithmetic<a class="headerlink" href="#modular-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_remove">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_remove</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">finv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Removes all factors <span class="math notranslate nohighlight">\(f\)</span> from <span class="math notranslate nohighlight">\(x\)</span> and returns the number of such.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(x\)</span> is non-zero, that <span class="math notranslate nohighlight">\(f &gt; 1\)</span> and that <code class="docutils literal notranslate"><span class="pre">finv</span></code>
is the precomputed <code class="docutils literal notranslate"><span class="pre">double</span></code> inverse of <span class="math notranslate nohighlight">\(f\)</span> whenever <span class="math notranslate nohighlight">\(f\)</span> is
a small integer and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p>
<p>Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_remove">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_remove</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">op</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove all occurrences of the factor <span class="math notranslate nohighlight">\(f &gt; 1\)</span> from the
integer <code class="docutils literal notranslate"><span class="pre">op</span></code> and sets <code class="docutils literal notranslate"><span class="pre">rop</span></code> to the resulting
integer.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">op</span></code> is zero, sets <code class="docutils literal notranslate"><span class="pre">rop</span></code> to <code class="docutils literal notranslate"><span class="pre">op</span></code> and
returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Returns an <code class="docutils literal notranslate"><span class="pre">abort</span></code> signal if any of the assumptions
are violated.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_invmod">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_invmod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_invmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the inverse of <span class="math notranslate nohighlight">\(g\)</span> modulo <span class="math notranslate nohighlight">\(h\)</span>.  The value of <span class="math notranslate nohighlight">\(h\)</span> may
not be <span class="math notranslate nohighlight">\(0\)</span> otherwise an exception results.  If the inverse exists
the return value will be non-zero, otherwise the return value will
be <span class="math notranslate nohighlight">\(0\)</span> and the value of <span class="math notranslate nohighlight">\(f\)</span> undefined. As a special case, we
consider any number invertible modulo <span class="math notranslate nohighlight">\(h = \pm 1\)</span>, with inverse 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_negmod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_negmod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_negmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(-g \pmod{h}\)</span>, assuming <span class="math notranslate nohighlight">\(g\)</span> is reduced modulo <span class="math notranslate nohighlight">\(h\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_jacobi">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_jacobi</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_jacobi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Jacobi symbol <span class="math notranslate nohighlight">\(\left(\frac{a}{n}\right)\)</span> for any <span class="math notranslate nohighlight">\(a\)</span> and odd positive <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_kronecker">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_kronecker</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_kronecker" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Kronecker symbol <span class="math notranslate nohighlight">\(\left(\frac{a}{n}\right)\)</span> for any <span class="math notranslate nohighlight">\(a\)</span> and any <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divides_mod_list">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divides_mod_list</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">xstart</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">xstride</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">xlength</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divides_mod_list" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(xstart\)</span>, <span class="math notranslate nohighlight">\(xstride\)</span>, and <span class="math notranslate nohighlight">\(xlength\)</span> so that the solution set for x modulo <span class="math notranslate nohighlight">\(n\)</span> in <span class="math notranslate nohighlight">\(a x = b mod n\)</span> is exactly <span class="math notranslate nohighlight">\(\{xstart + xstride i | 0 \le i &lt; xlength\}\)</span>.
This function essentially gives a list of possibilities for the fraction <span class="math notranslate nohighlight">\(a/b\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span>.
The outputs may not be aliased, and <span class="math notranslate nohighlight">\(n\)</span> should be positive.</p>
</dd></dl>

</section>
<section id="bit-packing-and-unpacking">
<h2>Bit packing and unpacking<a class="headerlink" href="#bit-packing-and-unpacking" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_bit_pack">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_bit_pack</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arr</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">shift</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">coeff</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">negate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">borrow</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_bit_pack" title="Link to this definition">¶</a><br /></dt>
<dd><p>Shifts the given coefficient to the left by <code class="docutils literal notranslate"><span class="pre">shift</span></code> bits and adds
it to the integer in <code class="docutils literal notranslate"><span class="pre">arr</span></code> in a field of the given number of bits:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">shift</span>  <span class="n">bits</span>  <span class="o">--------------</span>

<span class="n">X</span> <span class="n">X</span> <span class="n">X</span> <span class="n">C</span> <span class="n">C</span> <span class="n">C</span> <span class="n">C</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
</pre></div>
</div>
<p>An optional borrow of <span class="math notranslate nohighlight">\(1\)</span> can be subtracted from <code class="docutils literal notranslate"><span class="pre">coeff</span></code> before
it is packed.  If <code class="docutils literal notranslate"><span class="pre">coeff</span></code> is negative after the borrow, then a
borrow will be returned by the function.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">shift</span></code> is assumed to be less than <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.
All but the first <code class="docutils literal notranslate"><span class="pre">shift</span></code> bits of <code class="docutils literal notranslate"><span class="pre">arr</span></code> are assumed to be zero
on entry to the function.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">coeff</span></code> may also be optionally (and notionally) negated
before it is used, by setting the <code class="docutils literal notranslate"><span class="pre">negate</span></code> parameter to <span class="math notranslate nohighlight">\(-1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_bit_unpack">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_bit_unpack</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">coeff</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arr</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">shift</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">negate</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">borrow</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_bit_unpack" title="Link to this definition">¶</a><br /></dt>
<dd><p>A bit field of the given number of bits is extracted from <code class="docutils literal notranslate"><span class="pre">arr</span></code>,
starting after <code class="docutils literal notranslate"><span class="pre">shift</span></code> bits, and placed into <code class="docutils literal notranslate"><span class="pre">coeff</span></code>.  An
optional borrow of <span class="math notranslate nohighlight">\(1\)</span> may be added to the coefficient.  If the result
is negative, a borrow of <span class="math notranslate nohighlight">\(1\)</span> is returned.  Finally, the resulting
<code class="docutils literal notranslate"><span class="pre">coeff</span></code> may be negated by setting the <code class="docutils literal notranslate"><span class="pre">negate</span></code> parameter to <span class="math notranslate nohighlight">\(-1\)</span>.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">shift</span></code> is expected to be less than <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_bit_unpack_unsigned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_bit_unpack_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">coeff</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">arr</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">shift</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_bit_unpack_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>A bit field of the given number of bits is extracted from <code class="docutils literal notranslate"><span class="pre">arr</span></code>,
starting after <code class="docutils literal notranslate"><span class="pre">shift</span></code> bits, and placed into <code class="docutils literal notranslate"><span class="pre">coeff</span></code>.</p>
<p>The value of <code class="docutils literal notranslate"><span class="pre">shift</span></code> is expected to be less than <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

</section>
<section id="logic-operations">
<h2>Logic Operations<a class="headerlink" href="#logic-operations" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_complement">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_complement</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_complement" title="Link to this definition">¶</a><br /></dt>
<dd><p>The variable <code class="docutils literal notranslate"><span class="pre">r</span></code> is set to the ones-complement of <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_clrbit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_clrbit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_clrbit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">i</span></code>th bit in <code class="docutils literal notranslate"><span class="pre">f</span></code> to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_combit">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_combit</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_combit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Complements the <code class="docutils literal notranslate"><span class="pre">i</span></code>th bit in <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_and">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_and</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_and" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">r</span></code> to the bit-wise logical <code class="docutils literal notranslate"><span class="pre">and</span></code> of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_or">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_or</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_or" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">r</span></code> to the bit-wise logical (inclusive) <code class="docutils literal notranslate"><span class="pre">or</span></code> of
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_xor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_xor</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_xor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">r</span></code> to the bit-wise logical exclusive <code class="docutils literal notranslate"><span class="pre">or</span></code> of
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_popcnt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_popcnt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_popcnt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of ‘1’ bits in the given Z (aka Hamming weight or
population count).
The return value is undefined if the input is negative.</p>
</dd></dl>

</section>
<section id="chinese-remaindering">
<h2>Chinese remaindering<a class="headerlink" href="#chinese-remaindering" title="Link to this heading">¶</a></h2>
<p>The following functions can be used to reconstruct an integer from its
residues modulo a set of small (word-size) prime numbers. The first two
functions, <a class="reference internal" href="#c.fmpz_CRT_ui" title="fmpz_CRT_ui"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_CRT_ui()</span></code></a> and <a class="reference internal" href="#c.fmpz_CRT" title="fmpz_CRT"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_CRT()</span></code></a>, are easy
to use and allow building the result one residue at a time, which is
useful when the number of needed primes is not known in advance.
The remaining functions support performing the modular reductions and
reconstruction using balanced subdivision. This greatly improves
efficiency for large integers but assumes that the basis of primes is
known in advance. The user must precompute a <code class="docutils literal notranslate"><span class="pre">comb</span></code>
structure and temporary working space with <a class="reference internal" href="#c.fmpz_comb_init" title="fmpz_comb_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_comb_init()</span></code></a> and
<a class="reference internal" href="#c.fmpz_comb_temp_init" title="fmpz_comb_temp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_comb_temp_init()</span></code></a>, and free this data afterwards.
For simple demonstration programs showing how to use the CRT functions,
see <code class="docutils literal notranslate"><span class="pre">crt.c</span></code> and <code class="docutils literal notranslate"><span class="pre">multi_crt.c</span></code> in the <code class="docutils literal notranslate"><span class="pre">examples</span></code>
directory.
The <code class="docutils literal notranslate"><span class="pre">fmpz_multi_crt</span></code> class is similar to <code class="docutils literal notranslate"><span class="pre">fmpz_multi_CRT_ui</span></code> except that it performs error checking and works with arbitrary moduli.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_CRT_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_CRT_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">out</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m1</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">r2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">m2</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_CRT_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Uses the Chinese Remainder Theorem to compute the unique integer
<span class="math notranslate nohighlight">\(0 \le x &lt; M\)</span> (if sign = 0) or <span class="math notranslate nohighlight">\(-M/2 &lt; x \le M/2\)</span> (if sign = 1)
congruent to <span class="math notranslate nohighlight">\(r_1\)</span> modulo <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span> modulo <span class="math notranslate nohighlight">\(m_2\)</span>,
where where <span class="math notranslate nohighlight">\(M = m_1 \times m_2\)</span>. The result <span class="math notranslate nohighlight">\(x\)</span> is stored in <code class="docutils literal notranslate"><span class="pre">out</span></code>.</p>
<p>It is assumed that <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(m_2\)</span> are positive integers greater
than <span class="math notranslate nohighlight">\(1\)</span> and coprime.</p>
<p>If sign = 0, it is assumed that <span class="math notranslate nohighlight">\(0 \le r_1 &lt; m_1\)</span> and <span class="math notranslate nohighlight">\(0 \le r_2 &lt; m_2\)</span>.
Otherwise, it is assumed that <span class="math notranslate nohighlight">\(-m_1 \le r_1 &lt; m_1\)</span> and <span class="math notranslate nohighlight">\(0 \le r_2 &lt; m_2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_CRT">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_CRT</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">out</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m1</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r2</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m2</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_CRT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Use the Chinese Remainder Theorem to set <code class="docutils literal notranslate"><span class="pre">out</span></code> to the unique value
<span class="math notranslate nohighlight">\(0 \le x &lt; M\)</span> (if sign = 0) or <span class="math notranslate nohighlight">\(-M/2 &lt; x \le M/2\)</span> (if sign = 1)
congruent to <span class="math notranslate nohighlight">\(r_1\)</span> modulo <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span> modulo <span class="math notranslate nohighlight">\(m_2\)</span>,
where where <span class="math notranslate nohighlight">\(M = m_1 \times m_2\)</span>.</p>
<p>It is assumed that <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(m_2\)</span> are positive integers greater
than <span class="math notranslate nohighlight">\(1\)</span> and coprime.</p>
<p>If sign = 0, it is assumed that <span class="math notranslate nohighlight">\(0 \le r_1 &lt; m_1\)</span> and <span class="math notranslate nohighlight">\(0 \le r_2 &lt; m_2\)</span>.
Otherwise, it is assumed that <span class="math notranslate nohighlight">\(-m_1 \le r_1 &lt; m_1\)</span> and <span class="math notranslate nohighlight">\(0 \le r_2 &lt; m_2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_multi_mod_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_mod_ui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">out</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">in</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_comb_t</span></span><span class="w"> </span><span class="n"><span class="pre">comb</span></span>, <span class="n"><span class="pre">fmpz_comb_temp_t</span></span><span class="w"> </span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_mod_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reduces the multiprecision integer <code class="docutils literal notranslate"><span class="pre">in</span></code> modulo each of the primes
stored in the <code class="docutils literal notranslate"><span class="pre">comb</span></code> structure. The array <code class="docutils literal notranslate"><span class="pre">out</span></code> will be filled
with the residues modulo these primes. The structure <code class="docutils literal notranslate"><span class="pre">temp</span></code> is
temporary space which must be provided by <a class="reference internal" href="#c.fmpz_comb_temp_init" title="fmpz_comb_temp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_comb_temp_init()</span></code></a> and
cleared by <a class="reference internal" href="#c.fmpz_comb_temp_clear" title="fmpz_comb_temp_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_comb_temp_clear()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_multi_CRT_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_CRT_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">output</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">residues</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_comb_t</span></span><span class="w"> </span><span class="n"><span class="pre">comb</span></span>, <span class="n"><span class="pre">fmpz_comb_temp_t</span></span><span class="w"> </span><span class="n"><span class="pre">ctemp</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_CRT_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function takes a set of residues modulo the list of primes
contained in the <code class="docutils literal notranslate"><span class="pre">comb</span></code> structure and reconstructs a multiprecision
integer modulo the product of the primes which has
these residues modulo the corresponding primes.</p>
<p>If <span class="math notranslate nohighlight">\(N\)</span> is the product of all the primes then <code class="docutils literal notranslate"><span class="pre">out</span></code> is normalised to
be in the range <span class="math notranslate nohighlight">\([0, N)\)</span> if sign = 0 and the range <span class="math notranslate nohighlight">\([-(N-1)/2, N/2]\)</span>
if sign = 1. The array <code class="docutils literal notranslate"><span class="pre">temp</span></code> is temporary
space which must be provided by <a class="reference internal" href="#c.fmpz_comb_temp_init" title="fmpz_comb_temp_init"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_comb_temp_init()</span></code></a> and
cleared by <a class="reference internal" href="#c.fmpz_comb_temp_clear" title="fmpz_comb_temp_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_comb_temp_clear()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_comb_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_comb_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_comb_t</span></span><span class="w"> </span><span class="n"><span class="pre">comb</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">primes</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_comb_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises a <code class="docutils literal notranslate"><span class="pre">comb</span></code> structure for multimodular reduction and
recombination.  The array <code class="docutils literal notranslate"><span class="pre">primes</span></code> is assumed to contain
<code class="docutils literal notranslate"><span class="pre">num_primes</span></code> primes each of <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span> <span class="pre">-</span> <span class="pre">1</span></code> bits. Modular
reductions and recombinations will be done modulo this list of primes.
The <code class="docutils literal notranslate"><span class="pre">primes</span></code> array must not be <code class="docutils literal notranslate"><span class="pre">free</span></code>’d until the <code class="docutils literal notranslate"><span class="pre">comb</span></code>
structure is no longer required and must be cleared by the user.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_comb_temp_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_comb_temp_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_comb_temp_t</span></span><span class="w"> </span><span class="n"><span class="pre">temp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_comb_t</span></span><span class="w"> </span><span class="n"><span class="pre">comb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_comb_temp_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Creates temporary space to be used by multimodular and CRT functions
based on an initialised <code class="docutils literal notranslate"><span class="pre">comb</span></code> structure.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_comb_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_comb_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_comb_t</span></span><span class="w"> </span><span class="n"><span class="pre">comb</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_comb_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the given <code class="docutils literal notranslate"><span class="pre">comb</span></code> structure, releasing any memory it uses.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_comb_temp_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_comb_temp_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_comb_temp_t</span></span><span class="w"> </span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_comb_temp_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears temporary space <code class="docutils literal notranslate"><span class="pre">temp</span></code> used by multimodular and CRT functions
using the given <code class="docutils literal notranslate"><span class="pre">comb</span></code> structure.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_multi_crt_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_crt_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">CRT</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_crt_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize <code class="docutils literal notranslate"><span class="pre">CRT</span></code> for Chinese remaindering.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_multi_crt_precompute">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_crt_precompute</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">CRT</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">moduli</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_crt_precompute" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_multi_crt_precompute_p">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_crt_precompute_p</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">CRT</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">moduli</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_crt_precompute_p" title="Link to this definition">¶</a><br /></dt>
<dd><p>Configure <code class="docutils literal notranslate"><span class="pre">CRT</span></code> for repeated Chinese remaindering of <code class="docutils literal notranslate"><span class="pre">moduli</span></code>. The number of moduli, <code class="docutils literal notranslate"><span class="pre">len</span></code>, should be positive.
A return of <code class="docutils literal notranslate"><span class="pre">0</span></code> indicates that the compilation failed and future
calls to <code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_crt_precomp()</span></code> will leave the output undefined.
A return of <code class="docutils literal notranslate"><span class="pre">1</span></code> indicates that the compilation was successful, which occurs if and only if either (1) <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">==</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">modulus</span> <span class="pre">+</span> <span class="pre">0</span></code> is nonzero, or (2) no modulus is <span class="math notranslate nohighlight">\(0,1,-1\)</span> and all moduli are pairwise relatively prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_multi_crt_precomp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_crt_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">output</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">P</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inputs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_crt_precomp" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_multi_crt_precomp_p">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_crt_precomp_p</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">output</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">P</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inputs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_crt_precomp_p" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">output</span></code> to an integer of smallest absolute value that is congruent to <code class="docutils literal notranslate"><span class="pre">values</span> <span class="pre">+</span> <span class="pre">i</span></code> modulo the <code class="docutils literal notranslate"><span class="pre">moduli</span> <span class="pre">+</span> <span class="pre">i</span></code> in <code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_crt_precompute()</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_multi_crt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_crt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">output</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">moduli</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">values</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_crt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Perform the same operation as <a class="reference internal" href="#c.fmpz_multi_crt_precomp" title="fmpz_multi_crt_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_multi_crt_precomp()</span></code></a> while internally constructing and destroying the precomputed data.
All of the remarks in <a class="reference internal" href="#c.fmpz_multi_crt_precompute" title="fmpz_multi_crt_precompute"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_multi_crt_precompute()</span></code></a> apply.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_multi_crt_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_multi_crt_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">P</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_multi_crt_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Free all space used by <code class="docutils literal notranslate"><span class="pre">CRT</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._nmod_poly_crt_local_size">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_nmod_poly_crt_local_size</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">nmod_poly_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">CRT</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._nmod_poly_crt_local_size" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the required length of the output for <code class="xref c c-func docutils literal notranslate"><span class="pre">_nmod_poly_crt_run()</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_multi_crt_run">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_multi_crt_run</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">outputs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">CRT</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inputs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_multi_crt_run" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c._fmpz_multi_crt_run_p">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_multi_crt_run_p</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">outputs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_multi_crt_t</span></span><span class="w"> </span><span class="n"><span class="pre">CRT</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">inputs</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_multi_crt_run_p" title="Link to this definition">¶</a><br /></dt>
<dd><p>Perform the same operation as fmpz::fmpz_multi_crt_precomp using supplied temporary space.
The actual output is placed in <code class="docutils literal notranslate"><span class="pre">outputs</span> <span class="pre">+</span> <span class="pre">0</span></code>, and <code class="docutils literal notranslate"><span class="pre">outputs</span></code> should contain space for all temporaries and should be at least as long as <code class="docutils literal notranslate"><span class="pre">_fmpz_multi_crt_local_size(CRT)</span></code>.</p>
</dd></dl>

</section>
<section id="primality-testing">
<h2>Primality testing<a class="headerlink" href="#primality-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_strong_probabprime">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_strong_probabprime</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_strong_probabprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is a strong probable prime to base <span class="math notranslate nohighlight">\(a\)</span>, otherwise it
returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_probabprime_lucas">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_probabprime_lucas</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_probabprime_lucas" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs a Lucas probable prime test with parameters chosen by Selfridge’s
method <span class="math notranslate nohighlight">\(A\)</span> as per <a class="reference internal" href="references.html#baiwag1980" id="id1"><span>[BaiWag1980]</span></a>.</p>
<p>Return <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is a Lucas probable prime, otherwise return <span class="math notranslate nohighlight">\(0\)</span>. This
function declares some composites probably prime, but no primes composite.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_probabprime_BPSW">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_probabprime_BPSW</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_probabprime_BPSW" title="Link to this definition">¶</a><br /></dt>
<dd><p>Perform a Baillie-PSW probable prime test with parameters chosen by
Selfridge’s method <span class="math notranslate nohighlight">\(A\)</span> as per <a class="reference internal" href="references.html#baiwag1980" id="id2"><span>[BaiWag1980]</span></a>.</p>
<p>Return <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is a Lucas probable prime, otherwise return <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>There are no known composites passed as prime by this test, though
infinitely many probably exist. The test will declare no primes
composite.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_probabprime">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_probabprime</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_probabprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs some trial division and then some probabilistic primality tests.
If <span class="math notranslate nohighlight">\(p\)</span> is definitely composite, the function returns <span class="math notranslate nohighlight">\(0\)</span>, otherwise it
is declared probably prime, i.e. prime for most practical purposes, and
the function returns <span class="math notranslate nohighlight">\(1\)</span>. The chance of declaring a composite prime is
very small.</p>
<p>Subsequent calls to the same function do not increase the probability of
the number being prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_prime_pseudosquare">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_prime_pseudosquare</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_prime_pseudosquare" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(0\)</span> is <span class="math notranslate nohighlight">\(n\)</span> is composite. If <span class="math notranslate nohighlight">\(n\)</span> is too large (greater than about
<span class="math notranslate nohighlight">\(94\)</span> bits) the function fails silently and returns <span class="math notranslate nohighlight">\(-1\)</span>, otherwise, if
<span class="math notranslate nohighlight">\(n\)</span> is proven prime by the pseudosquares method, return <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a prime according to [Theorem 2.7] <a class="reference internal" href="references.html#lukpatwil1996" id="id3"><span>[LukPatWil1996]</span></a>.</p>
<p>We first factor <span class="math notranslate nohighlight">\(N\)</span> using trial division up to some limit <span class="math notranslate nohighlight">\(B\)</span>.
In fact, the number of primes used in the trial factoring is at
most <code class="docutils literal notranslate"><span class="pre">FLINT_PSEUDOSQUARES_CUTOFF</span></code>.</p>
<p>Next we compute <span class="math notranslate nohighlight">\(N/B\)</span> and find the next pseudosquare <span class="math notranslate nohighlight">\(L_p\)</span> above
this value, using a static table as per
<a class="reference external" href="https://oeis.org/A002189/b002189.txt">https://oeis.org/A002189/b002189.txt</a>.</p>
<p>As noted in the text, if <span class="math notranslate nohighlight">\(p\)</span> is prime then Step 3 will pass. This
test rejects many composites, and so by this time we suspect
that <span class="math notranslate nohighlight">\(p\)</span> is prime. If <span class="math notranslate nohighlight">\(N\)</span> is <span class="math notranslate nohighlight">\(3\)</span> or <span class="math notranslate nohighlight">\(7\)</span> modulo <span class="math notranslate nohighlight">\(8\)</span>, we are done,
and <span class="math notranslate nohighlight">\(N\)</span> is prime.</p>
<p>We now run a probable prime test, for which no known
counterexamples are known, to reject any composites. We then
proceed to prove <span class="math notranslate nohighlight">\(N\)</span> prime by executing Step 4. In the case that
<span class="math notranslate nohighlight">\(N\)</span> is <span class="math notranslate nohighlight">\(1\)</span> modulo <span class="math notranslate nohighlight">\(8\)</span>, if Step 4 fails, we extend the number of primes
<span class="math notranslate nohighlight">\(p_i\)</span> at Step 3 and hope to find one which passes Step 4. We take
the test one past the largest <span class="math notranslate nohighlight">\(p\)</span> for which we have pseudosquares
<span class="math notranslate nohighlight">\(L_p\)</span> tabulated, as this already corresponds to the next <span class="math notranslate nohighlight">\(L_p\)</span> which
is bigger than <span class="math notranslate nohighlight">\(2^{64}\)</span> and hence larger than any prime we might be
testing.</p>
<p>As explained in the text, Condition 4 cannot fail if <span class="math notranslate nohighlight">\(N\)</span> is prime.</p>
<p>The possibility exists that the probable prime test declares a
composite prime. However in that case an error is printed, as
that would be of independent interest.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_prime_pocklington">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_prime_pocklington</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">F</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">pm1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num_pm1</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_prime_pocklington" title="Link to this definition">¶</a><br /></dt>
<dd><p>Applies the Pocklington primality test. The test computes a product
<span class="math notranslate nohighlight">\(F\)</span> of prime powers which divide <span class="math notranslate nohighlight">\(n - 1\)</span>.</p>
<p>The function then returns either <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is definitely composite
or it returns <span class="math notranslate nohighlight">\(1\)</span> if all factors of <span class="math notranslate nohighlight">\(n\)</span> are <span class="math notranslate nohighlight">\(1 \pmod{F}\)</span>. Also in
that case, <span class="math notranslate nohighlight">\(R\)</span> is set to <span class="math notranslate nohighlight">\((n - 1)/F\)</span>.</p>
<p>N.B: a return value of <span class="math notranslate nohighlight">\(1\)</span> only proves <span class="math notranslate nohighlight">\(n\)</span> prime if <span class="math notranslate nohighlight">\(F \ge \sqrt{n}\)</span>.</p>
<p>The function does not compute which primes divide <span class="math notranslate nohighlight">\(n - 1\)</span>. Instead,
these must be supplied as an array <code class="docutils literal notranslate"><span class="pre">pm1</span></code> of length <code class="docutils literal notranslate"><span class="pre">num_pm1</span></code>.
It does not matter how many prime factors are supplied, but the more
that are supplied, the larger F will be.</p>
<p>There is a balance between the amount of time spent looking for
factors of <span class="math notranslate nohighlight">\(n - 1\)</span> and the usefulness of the output (<span class="math notranslate nohighlight">\(F\)</span> may be as low
as <span class="math notranslate nohighlight">\(2\)</span> in some cases).</p>
<p>A reasonable heuristic seems to be to choose <code class="docutils literal notranslate"><span class="pre">limit</span></code> to be some
small multiple of <span class="math notranslate nohighlight">\(\log^3(n)/10\)</span> (e.g. <span class="math notranslate nohighlight">\(1, 2, 5\)</span> or <span class="math notranslate nohighlight">\(10\)</span>) depending
on how long one is prepared to wait, then to trial factor up to the
limit. (See <code class="docutils literal notranslate"><span class="pre">_fmpz_nm1_trial_factors</span></code>.)</p>
<p>Requires <span class="math notranslate nohighlight">\(n\)</span> to be odd.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_nm1_trial_factors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_nm1_trial_factors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">pm1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">num_pm1</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_nm1_trial_factors" title="Link to this definition">¶</a><br /></dt>
<dd><p>Trial factors <span class="math notranslate nohighlight">\(n - 1\)</span> up to the given limit (approximately) and stores
the factors in an array <code class="docutils literal notranslate"><span class="pre">pm1</span></code> whose length is written out to
<code class="docutils literal notranslate"><span class="pre">num_pm1</span></code>.</p>
<p>One can use <span class="math notranslate nohighlight">\(\log(n) + 2\)</span> as a bound on the number of factors which might
be produced (and hence on the length of the array that needs to be
supplied).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_prime_morrison">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_prime_morrison</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">F</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">pp1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num_pp1</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_prime_morrison" title="Link to this definition">¶</a><br /></dt>
<dd><p>Applies the Morrison <span class="math notranslate nohighlight">\(p + 1\)</span> primality test. The test computes a
product <span class="math notranslate nohighlight">\(F\)</span> of primes which divide <span class="math notranslate nohighlight">\(n + 1\)</span>.</p>
<p>The function then returns either <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is definitely composite
or it returns <span class="math notranslate nohighlight">\(1\)</span> if all factors of <span class="math notranslate nohighlight">\(n\)</span> are <span class="math notranslate nohighlight">\(\pm 1 \pmod{F}\)</span>. Also in
that case, <span class="math notranslate nohighlight">\(R\)</span> is set to <span class="math notranslate nohighlight">\((n + 1)/F\)</span>.</p>
<p>N.B: a return value of <span class="math notranslate nohighlight">\(1\)</span> only proves <span class="math notranslate nohighlight">\(n\)</span> prime if
<span class="math notranslate nohighlight">\(F &gt; \sqrt{n} + 1\)</span>.</p>
<p>The function does not compute which primes divide <span class="math notranslate nohighlight">\(n + 1\)</span>. Instead,
these must be supplied as an array <code class="docutils literal notranslate"><span class="pre">pp1</span></code> of length <code class="docutils literal notranslate"><span class="pre">num_pp1</span></code>.
It does not matter how many prime factors are supplied, but the more
that are supplied, the larger <span class="math notranslate nohighlight">\(F\)</span> will be.</p>
<p>There is a balance between the amount of time spent looking for
factors of <span class="math notranslate nohighlight">\(n + 1\)</span> and the usefulness of the output (<span class="math notranslate nohighlight">\(F\)</span> may be as low
as <span class="math notranslate nohighlight">\(2\)</span> in some cases).</p>
<p>A reasonable heuristic seems to be to choose <code class="docutils literal notranslate"><span class="pre">limit</span></code> to be some
small multiple of <span class="math notranslate nohighlight">\(\log^3(n)/10\)</span> (e.g. <span class="math notranslate nohighlight">\(1, 2, 5\)</span> or <span class="math notranslate nohighlight">\(10\)</span>) depending
on how long one is prepared to wait, then to trial factor up to the
limit. (See <code class="docutils literal notranslate"><span class="pre">_fmpz_np1_trial_factors</span></code>.)</p>
<p>Requires <span class="math notranslate nohighlight">\(n\)</span> to be odd and non-square.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_np1_trial_factors">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_np1_trial_factors</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">pp1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">num_pp1</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_np1_trial_factors" title="Link to this definition">¶</a><br /></dt>
<dd><p>Trial factors <span class="math notranslate nohighlight">\(n + 1\)</span> up to the given limit (approximately) and stores
the factors in an array <code class="docutils literal notranslate"><span class="pre">pp1</span></code> whose length is written out to
<code class="docutils literal notranslate"><span class="pre">num_pp1</span></code>.</p>
<p>One can use <span class="math notranslate nohighlight">\(\log(n) + 2\)</span> as a bound on the number of factors which might
be produced (and hence on the length of the array that needs to be
supplied).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_is_prime">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_is_prime</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_is_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempts to prove <span class="math notranslate nohighlight">\(n\)</span> prime.  If <span class="math notranslate nohighlight">\(n\)</span> is proven prime, the function
returns <span class="math notranslate nohighlight">\(1\)</span>. If <span class="math notranslate nohighlight">\(n\)</span> is definitely composite, the function returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>This function calls <a class="reference internal" href="ulong_extras.html#c.n_is_prime" title="n_is_prime"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_prime()</span></code></a> for <span class="math notranslate nohighlight">\(n\)</span> that fits in a single word.
For <span class="math notranslate nohighlight">\(n\)</span> larger than one word, it tests divisibility by a few small primes
and whether <span class="math notranslate nohighlight">\(n\)</span> is a perfect square to rule out trivial composites.
For <span class="math notranslate nohighlight">\(n\)</span> up to about 81 bits, it then uses a strong probable prime test
(Miller-Rabin test) with the first 13 primes as witnesses. This has
been shown to prove primality <a class="reference internal" href="references.html#sorweb2016" id="id4"><span>[SorWeb2016]</span></a>.</p>
<p>For larger <span class="math notranslate nohighlight">\(n\)</span>, it does a single base-2 strong probable prime test
to eliminate most composite numbers. If <span class="math notranslate nohighlight">\(n\)</span> passes, it does a
combination of Pocklington, Morrison and Brillhart, Lehmer, Selfridge
tests. If any of these tests fails to give a proof, it falls back to
performing an APRCL test.</p>
<p>The APRCL test could theoretically fail to prove that <span class="math notranslate nohighlight">\(n\)</span> is prime
or composite. In that case, the program aborts. This is not expected to
occur in practice.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lucas_chain">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lucas_chain</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Vm</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Vm1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lucas_chain" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(V_0 = 2\)</span>, <span class="math notranslate nohighlight">\(V_1 = A\)</span> compute <span class="math notranslate nohighlight">\(V_m, V_{m + 1} \pmod{n}\)</span> from the
recurrences <span class="math notranslate nohighlight">\(V_j = AV_{j - 1} - V_{j - 2} \pmod{n}\)</span>.</p>
<p>This is computed efficiently using <span class="math notranslate nohighlight">\(V_{2j} = V_j^2 - 2 \pmod{n}\)</span> and
<span class="math notranslate nohighlight">\(V_{2j + 1} = V_jV_{j + 1} - A \pmod{n}\)</span>.</p>
<p>No aliasing is permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lucas_chain_full">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lucas_chain_full</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Vm</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Vm1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lucas_chain_full" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(V_0 = 2\)</span>, <span class="math notranslate nohighlight">\(V_1 = A\)</span> compute <span class="math notranslate nohighlight">\(V_m, V_{m + 1} \pmod{n}\)</span> from the
recurrences <span class="math notranslate nohighlight">\(V_j = AV_{j - 1} - BV_{j - 2} \pmod{n}\)</span>.</p>
<p>This is computed efficiently using double and add formulas.</p>
<p>No aliasing is permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lucas_chain_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lucas_chain_double</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U2m</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U2m1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lucas_chain_double" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(U_m, U_{m + 1} \pmod{n}\)</span> compute <span class="math notranslate nohighlight">\(U_{2m}, U_{2m + 1} \pmod{n}\)</span>.</p>
<p>Aliasing of <span class="math notranslate nohighlight">\(U_{2m}\)</span> and <span class="math notranslate nohighlight">\(U_m\)</span> and aliasing of <span class="math notranslate nohighlight">\(U_{2m + 1}\)</span> and <span class="math notranslate nohighlight">\(U_{m + 1}\)</span>
is permitted. No other aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lucas_chain_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lucas_chain_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Umn</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Umn1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Un</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Un1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lucas_chain_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(U_m, U_{m + 1} \pmod{n}\)</span> and <span class="math notranslate nohighlight">\(U_n, U_{n + 1} \pmod{n}\)</span> compute
<span class="math notranslate nohighlight">\(U_{m + n}, U_{m + n + 1} \pmod{n}\)</span>.</p>
<p>Aliasing of <span class="math notranslate nohighlight">\(U_{m + n}\)</span> with <span class="math notranslate nohighlight">\(U_m\)</span> or <span class="math notranslate nohighlight">\(U_n\)</span> and aliasing of <span class="math notranslate nohighlight">\(U_{m + n + 1}\)</span>
with <span class="math notranslate nohighlight">\(U_{m + 1}\)</span> or <span class="math notranslate nohighlight">\(U_{n + 1}\)</span> is permitted. No other aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lucas_chain_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lucas_chain_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Ukm</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Ukm1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lucas_chain_mul" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(U_m, U_{m + 1} \pmod{n}\)</span> compute <span class="math notranslate nohighlight">\(U_{km}, U_{km + 1} \pmod{n}\)</span>.</p>
<p>Aliasing of <span class="math notranslate nohighlight">\(U_{km}\)</span> and <span class="math notranslate nohighlight">\(U_m\)</span> and aliasing of <span class="math notranslate nohighlight">\(U_{km + 1}\)</span> and <span class="math notranslate nohighlight">\(U_{m + 1}\)</span>
is permitted. No other aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lucas_chain_VtoU">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lucas_chain_VtoU</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um</span></span>, <a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Um1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Vm</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Vm1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Dinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lucas_chain_VtoU" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(V_m, V_{m + 1} \pmod{n}\)</span> compute <span class="math notranslate nohighlight">\(U_m, U_{m + 1} \pmod{n}\)</span>.</p>
<p>Aliasing of <span class="math notranslate nohighlight">\(V_m\)</span> and <span class="math notranslate nohighlight">\(U_m\)</span> and aliasing of <span class="math notranslate nohighlight">\(V_{m + 1}\)</span> and <span class="math notranslate nohighlight">\(U_{m + 1}\)</span>
is permitted. No other aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_divisor_in_residue_class_lenstra">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divisor_in_residue_class_lenstra</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">fac</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divisor_in_residue_class_lenstra" title="Link to this definition">¶</a><br /></dt>
<dd><p>If there exists a proper divisor of <span class="math notranslate nohighlight">\(n\)</span> which is <span class="math notranslate nohighlight">\(r \pmod{s}\)</span> for
<span class="math notranslate nohighlight">\(0 &lt; r &lt; s &lt; n\)</span>, this function returns <span class="math notranslate nohighlight">\(1\)</span> and sets <code class="docutils literal notranslate"><span class="pre">fac</span></code> to such a
divisor. Otherwise the function returns <span class="math notranslate nohighlight">\(0\)</span> and the value of <code class="docutils literal notranslate"><span class="pre">fac</span></code> is
undefined.</p>
<p>We require <span class="math notranslate nohighlight">\(\gcd(r, s) = 1\)</span>.</p>
<p>This is efficient if <span class="math notranslate nohighlight">\(s^3 &gt; n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_nextprime">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_nextprime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_nextprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Finds the next prime number larger than <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">proved</span></code> is nonzero, then the integer returned is
guaranteed to actually be prime. Otherwise if <span class="math notranslate nohighlight">\(n\)</span> fits in
<code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span> <span class="pre">-</span> <span class="pre">3</span></code> bits <code class="docutils literal notranslate"><span class="pre">n_nextprime</span></code> is called, and if not then
the GMP <code class="docutils literal notranslate"><span class="pre">mpz_nextprime</span></code> function is called. Up to an including
GMP 6.1.2 this used Miller-Rabin iterations, and thereafter uses
a BPSW test.</p>
</dd></dl>

</section>
<section id="special-functions">
<h2>Special functions<a class="headerlink" href="#special-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_primorial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_primorial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_primorial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">n</span></code> primorial or <span class="math notranslate nohighlight">\(n \#\)</span>, the product of all prime
numbers less than or equal to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_factor_euler_phi">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_factor_euler_phi</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_factor.html#c.fmpz_factor_t" title="fmpz_factor_t"><span class="n"><span class="pre">fmpz_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">fac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_factor_euler_phi" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_euler_phi">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_euler_phi</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_euler_phi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the Euler totient function <span class="math notranslate nohighlight">\(\phi(n)\)</span>, counting the
number of positive integers less than or equal to <span class="math notranslate nohighlight">\(n\)</span> that are coprime
to <span class="math notranslate nohighlight">\(n\)</span>. The factor version takes a precomputed
factorisation of <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_factor_moebius_mu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_factor_moebius_mu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_factor.html#c.fmpz_factor_t" title="fmpz_factor_t"><span class="n"><span class="pre">fmpz_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">fac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_factor_moebius_mu" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_moebius_mu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_moebius_mu</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_moebius_mu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Moebius function <span class="math notranslate nohighlight">\(\mu(n)\)</span>, which is defined as <span class="math notranslate nohighlight">\(\mu(n) = 0\)</span>
if <span class="math notranslate nohighlight">\(n\)</span> has a prime factor of multiplicity greater than <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(\mu(n) = -1\)</span>
if <span class="math notranslate nohighlight">\(n\)</span> has an odd number of distinct prime factors, and <span class="math notranslate nohighlight">\(\mu(n) = 1\)</span> if
<span class="math notranslate nohighlight">\(n\)</span> has an even number of distinct prime factors.  By convention,
<span class="math notranslate nohighlight">\(\mu(0) = 0\)</span>. The factor version takes a precomputed
factorisation of <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_factor_divisor_sigma">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_factor_divisor_sigma</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_factor.html#c.fmpz_factor_t" title="fmpz_factor_t"><span class="n"><span class="pre">fmpz_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">fac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_factor_divisor_sigma" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_divisor_sigma">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_divisor_sigma</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_divisor_sigma" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <span class="math notranslate nohighlight">\(\sigma_k(n)\)</span>, the sum of <span class="math notranslate nohighlight">\(k`th powers of all
divisors of `n\)</span>. The factor version takes a precomputed
factorisation of <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><strong>fmpz.h</strong> – integers</a><ul>
<li><a class="reference internal" href="#types-macros-and-constants">Types, macros and constants</a></li>
<li><a class="reference internal" href="#memory-management">Memory management</a></li>
<li><a class="reference internal" href="#random-generation">Random generation</a></li>
<li><a class="reference internal" href="#conversion">Conversion</a></li>
<li><a class="reference internal" href="#input-and-output">Input and output</a></li>
<li><a class="reference internal" href="#basic-properties-and-manipulation">Basic properties and manipulation</a></li>
<li><a class="reference internal" href="#comparison">Comparison</a></li>
<li><a class="reference internal" href="#basic-arithmetic">Basic arithmetic</a></li>
<li><a class="reference internal" href="#greatest-common-divisor">Greatest common divisor</a></li>
<li><a class="reference internal" href="#modular-arithmetic">Modular arithmetic</a></li>
<li><a class="reference internal" href="#bit-packing-and-unpacking">Bit packing and unpacking</a></li>
<li><a class="reference internal" href="#logic-operations">Logic Operations</a></li>
<li><a class="reference internal" href="#chinese-remaindering">Chinese remaindering</a></li>
<li><a class="reference internal" href="#primality-testing">Primality testing</a></li>
<li><a class="reference internal" href="#special-functions">Special functions</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="ulong_extras.html"
                          title="previous chapter"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="fmpz_vec.html"
                          title="next chapter"><strong>fmpz_vec.h</strong> – vectors of integers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/fmpz.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fmpz_vec.html" title="fmpz_vec.h – vectors of integers"
             >next</a> |</li>
        <li class="right" >
          <a href="ulong_extras.html" title="ulong_extras.h – arithmetic and number-theoretic functions for single-word integers"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>fmpz.h</strong> – integers</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2018, The Flint development team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>