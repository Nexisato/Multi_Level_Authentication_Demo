<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>fmpz_lll.h – LLL reduction &#8212; Flint 2.9.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    
    <script src="_static/documentation_options.js?v=182a64a0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="fmpz_poly.h – univariate polynomials over the integers" href="fmpz_poly.html" />
    <link rel="prev" title="fmpz_mat.h – matrices over the integers" href="fmpz_mat.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fmpz_poly.html" title="fmpz_poly.h – univariate polynomials over the integers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fmpz_mat.html" title="fmpz_mat.h – matrices over the integers"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>fmpz_lll.h</strong> – LLL reduction</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="fmpz-lll-h-lll-reduction">
<h1><strong>fmpz_lll.h</strong> – LLL reduction<a class="headerlink" href="#fmpz-lll-h-lll-reduction" title="Link to this heading">¶</a></h1>
<p>Description.</p>
<section id="parameter-manipulation">
<h2>Parameter manipulation<a class="headerlink" href="#parameter-manipulation" title="Link to this heading">¶</a></h2>
<p>These functions are used to initialise LLL context objects which are of the
type <code class="docutils literal notranslate"><span class="pre">fmpz_lll_t</span></code>. These objects contain all information about the
options governing the reduction using this module’s functions including the
LLL parameters delta and eta, the representation type of the input matrix
(whether it is a lattice basis or a Gram matrix), and the type of Gram
matrix to be used during L^2 (approximate or exact).</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_context_init_default">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_context_init_default</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_context_init_default" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">fl-&gt;delta</span></code>, <code class="docutils literal notranslate"><span class="pre">fl-&gt;eta</span></code>, <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code> and <code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> to
their default values, 0.99, 0.51, <span class="math notranslate nohighlight">\(Z\_BASIS\)</span> and <span class="math notranslate nohighlight">\(APPROX\)</span> respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_context_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_context_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">delta</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">eta</span></span>, <span class="n"><span class="pre">rep_type</span></span><span class="w"> </span><span class="n"><span class="pre">rt</span></span>, <span class="n"><span class="pre">gram_type</span></span><span class="w"> </span><span class="n"><span class="pre">gt</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_context_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">fl-&gt;delta</span></code>, <code class="docutils literal notranslate"><span class="pre">fl-&gt;eta</span></code>, <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code> and <code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> to
<code class="docutils literal notranslate"><span class="pre">delta</span></code>, <code class="docutils literal notranslate"><span class="pre">eta</span></code>, <code class="docutils literal notranslate"><span class="pre">rt</span></code> and <code class="docutils literal notranslate"><span class="pre">gt</span></code> (given as input)
respectively. <code class="docutils literal notranslate"><span class="pre">delta</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> are the L^2 parameters.
<code class="docutils literal notranslate"><span class="pre">delta</span></code> and <code class="docutils literal notranslate"><span class="pre">eta</span></code> must lie in the intervals <span class="math notranslate nohighlight">\((0.25, 1)\)</span> and
(0.5, sqrt{<code class="docutils literal notranslate"><span class="pre">delta</span></code>}) respectively. The representation type is input
using <code class="docutils literal notranslate"><span class="pre">rt</span></code> and can have the values <span class="math notranslate nohighlight">\(Z\_BASIS\)</span> for a lattice basis and
<span class="math notranslate nohighlight">\(GRAM\)</span> for a Gram matrix. The Gram type to be used during computation can
be specified using <code class="docutils literal notranslate"><span class="pre">gt</span></code> which can assume the values <span class="math notranslate nohighlight">\(APPROX\)</span> and
<span class="math notranslate nohighlight">\(EXACT\)</span>. Note that <code class="docutils literal notranslate"><span class="pre">gt</span></code> has meaning only when <code class="docutils literal notranslate"><span class="pre">rt</span></code> is <span class="math notranslate nohighlight">\(Z\_BASIS\)</span>.</p>
</dd></dl>

</section>
<section id="random-parameter-generation">
<h2>Random parameter generation<a class="headerlink" href="#random-parameter-generation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_randtest">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_randtest</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">fl-&gt;delta</span></code> and <code class="docutils literal notranslate"><span class="pre">fl-&gt;eta</span></code> to random values in the interval
<span class="math notranslate nohighlight">\((0.25, 1)\)</span> and (0.5, sqrt{<code class="docutils literal notranslate"><span class="pre">delta</span></code>}) respectively. <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code> is
set to <span class="math notranslate nohighlight">\(GRAM\)</span> or <span class="math notranslate nohighlight">\(Z\_BASIS\)</span> and <code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> is set to <span class="math notranslate nohighlight">\(APPROX\)</span> or <span class="math notranslate nohighlight">\(EXACT\)</span>
in a pseudo random way.</p>
</dd></dl>

</section>
<section id="heuristic-dot-product">
<h2>Heuristic dot product<a class="headerlink" href="#heuristic-dot-product" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_heuristic_dot">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_heuristic_dot</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vec1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">vec2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">exp_adj</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_heuristic_dot" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the dot product of two vectors of doubles <code class="docutils literal notranslate"><span class="pre">vec1</span></code> and
<code class="docutils literal notranslate"><span class="pre">vec2</span></code>, which are respectively <code class="docutils literal notranslate"><span class="pre">double</span></code> approximations (up to
scaling by a power of 2) to rows <code class="docutils literal notranslate"><span class="pre">k</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> in the exact integer
matrix <code class="docutils literal notranslate"><span class="pre">B</span></code>. If massive cancellation is detected an exact computation
is made.</p>
<p>The exact computation is scaled by <code class="docutils literal notranslate"><span class="pre">2^{-exp_adj</span></code>}, where
<code class="docutils literal notranslate"><span class="pre">exp_adj</span> <span class="pre">=</span> <span class="pre">r2</span> <span class="pre">+</span> <span class="pre">r1</span></code> where <span class="math notranslate nohighlight">\(r2\)</span> is the exponent for row <code class="docutils literal notranslate"><span class="pre">j</span></code> and
<span class="math notranslate nohighlight">\(r1\)</span> is the exponent for row <code class="docutils literal notranslate"><span class="pre">k</span></code> (i.e. row <code class="docutils literal notranslate"><span class="pre">j</span></code> is notionally
thought of as being multiplied by <span class="math notranslate nohighlight">\(2^{r2}\)</span>, etc.).</p>
<p>The final dot product computed by this function is then notionally the
return value times <code class="docutils literal notranslate"><span class="pre">2^{exp_adj</span></code>}.</p>
</dd></dl>

</section>
<section id="the-various-babai-s">
<h2>The various Babai’s<a class="headerlink" href="#the-various-babai-s" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_check_babai">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_check_babai</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappa</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">mu</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">appB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">expo</span></span>, <span class="n"><span class="pre">fmpz_gram_t</span></span><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">zeros</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappamax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_check_babai" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs floating point size reductions of the <code class="docutils literal notranslate"><span class="pre">kappa</span></code>-th row of
<code class="docutils literal notranslate"><span class="pre">B</span></code> by all of the previous rows, uses d_mats <code class="docutils literal notranslate"><span class="pre">mu</span></code> and <code class="docutils literal notranslate"><span class="pre">r</span></code>
for storing the GSO data. <code class="docutils literal notranslate"><span class="pre">U</span></code> is used to capture the unimodular
transformations if it is not <span class="math notranslate nohighlight">\(NULL\)</span>. The <code class="docutils literal notranslate"><span class="pre">double</span></code> array <code class="docutils literal notranslate"><span class="pre">s</span></code> will
contain the size of the <code class="docutils literal notranslate"><span class="pre">kappa</span></code>-th row if it were moved into position
<span class="math notranslate nohighlight">\(i\)</span>. The d_mat <code class="docutils literal notranslate"><span class="pre">appB</span></code> is an approximation of <code class="docutils literal notranslate"><span class="pre">B</span></code> with each row
receiving an exponent stored in <code class="docutils literal notranslate"><span class="pre">expo</span></code> which gets populated only when
needed. The d_mat <code class="docutils literal notranslate"><span class="pre">A-&gt;appSP</span></code> is an approximation of the Gram matrix
whose entries are scalar products of the rows of <code class="docutils literal notranslate"><span class="pre">B</span></code> and is used when
<code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> == <span class="math notranslate nohighlight">\(APPROX\)</span>. When <code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> == <span class="math notranslate nohighlight">\(EXACT\)</span> the fmpz_mat
<code class="docutils literal notranslate"><span class="pre">A-&gt;exactSP</span></code> (the exact Gram matrix) is used. The index <code class="docutils literal notranslate"><span class="pre">a</span></code> is
the smallest row index which will be reduced from the <code class="docutils literal notranslate"><span class="pre">kappa</span></code>-th row.
Index <code class="docutils literal notranslate"><span class="pre">zeros</span></code> is the number of zero rows in the matrix.
<code class="docutils literal notranslate"><span class="pre">kappamax</span></code> is the highest index which has been size-reduced so far,
and <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of columns you want to consider. <code class="docutils literal notranslate"><span class="pre">fl</span></code> is an
LLL (L^2) context object. The output is the value -1 if the process fails
(usually due to insufficient precision) or 0 if everything was successful.
These descriptions will be true for the future Babai procedures as well.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_check_babai_heuristic_d">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_check_babai_heuristic_d</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappa</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">mu</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">appB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">expo</span></span>, <span class="n"><span class="pre">fmpz_gram_t</span></span><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">zeros</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappamax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_check_babai_heuristic_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#c.fmpz_lll_check_babai" title="fmpz_lll_check_babai"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_check_babai()</span></code></a> but using the heuristic inner product
rather than a purely floating point inner product. The heuristic will
compute at full precision when there is cancellation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_check_babai_heuristic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_check_babai_heuristic</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappa</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="n"><span class="pre">mpf_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">mu</span></span>, <span class="n"><span class="pre">mpf_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">mpf</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">mpf_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">appB</span></span>, <span class="n"><span class="pre">fmpz_gram_t</span></span><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">zeros</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappamax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mpf_t</span></span><span class="w"> </span><span class="n"><span class="pre">tmp</span></span>, <span class="n"><span class="pre">mpf_t</span></span><span class="w"> </span><span class="n"><span class="pre">rtmp</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">prec</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_check_babai_heuristic" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function is like the <code class="docutils literal notranslate"><span class="pre">mpf</span></code> version of
<a class="reference internal" href="#c.fmpz_lll_check_babai_heuristic_d" title="fmpz_lll_check_babai_heuristic_d"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_check_babai_heuristic_d()</span></code></a>. However, it also inherits some
temporary <code class="docutils literal notranslate"><span class="pre">mpf_t</span></code> variables <code class="docutils literal notranslate"><span class="pre">tmp</span></code> and <code class="docutils literal notranslate"><span class="pre">rtmp</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_advance_check_babai">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_advance_check_babai</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cur_kappa</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappa</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">mu</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">appB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">expo</span></span>, <span class="n"><span class="pre">fmpz_gram_t</span></span><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">zeros</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappamax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_advance_check_babai" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is a Babai procedure which is used when size reducing a vector beyond
an index which LLL has reached. <code class="docutils literal notranslate"><span class="pre">cur_kappa</span></code> is the index behind which
we can assume <code class="docutils literal notranslate"><span class="pre">B</span></code> is LLL reduced, while <code class="docutils literal notranslate"><span class="pre">kappa</span></code> is the vector to
be reduced. This procedure only size reduces the <code class="docutils literal notranslate"><span class="pre">kappa</span></code>-th row by
vectors upto <code class="docutils literal notranslate"><span class="pre">cur_kappa</span></code>, textbf{not} <code class="docutils literal notranslate"><span class="pre">kappa</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_advance_check_babai_heuristic_d">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_advance_check_babai_heuristic_d</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">cur_kappa</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappa</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">mu</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <span class="n"><span class="pre">d_mat_t</span></span><span class="w"> </span><span class="n"><span class="pre">appB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">expo</span></span>, <span class="n"><span class="pre">fmpz_gram_t</span></span><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">zeros</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">kappamax</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_advance_check_babai_heuristic_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#c.fmpz_lll_advance_check_babai" title="fmpz_lll_advance_check_babai"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_advance_check_babai()</span></code></a> but using the heuristic inner
product rather than a purely floating point inner product. The heuristic
will compute at full precision when there is cancellation.</p>
</dd></dl>

</section>
<section id="shift">
<h2>Shift<a class="headerlink" href="#shift" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_shift">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_shift</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_shift" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the largest number of non-zero entries after the diagonal in
<code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
</dd></dl>

</section>
<section id="varieties-of-lll">
<h2>Varieties of LLL<a class="headerlink" href="#varieties-of-lll" title="Link to this heading">¶</a></h2>
<p>These programs implement ideas from the book chapter <a class="reference internal" href="references.html#stehle2010" id="id1"><span>[Stehle2010]</span></a>.
The list of function here that are heuristic in nature and may return with <span class="math notranslate nohighlight">\(B\)</span>
unreduced - that is to say, not do their job - includes (but is not necessarily limited to):</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="#c.fmpz_lll_d" title="fmpz_lll_d"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.fmpz_lll_d_heuristic" title="fmpz_lll_d_heuristic"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_heuristic()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.fmpz_lll_d_heuristic_with_removal" title="fmpz_lll_d_heuristic_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_heuristic_with_removal()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.fmpz_lll_d_with_removal" title="fmpz_lll_d_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_with_removal()</span></code></a></p></li>
<li><p><a class="reference internal" href="#c.fmpz_lll_d_with_removal_knapsack" title="fmpz_lll_d_with_removal_knapsack"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_with_removal_knapsack()</span></code></a></p></li>
</ul>
</div></blockquote>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_d">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_d</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is a mildly greedy version of floating point LLL using doubles only.
It tries the fast version of the Babai algorithm
(<a class="reference internal" href="#c.fmpz_lll_check_babai" title="fmpz_lll_check_babai"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_check_babai()</span></code></a>). If that fails, then it switches to the
heuristic version (<a class="reference internal" href="#c.fmpz_lll_check_babai_heuristic_d" title="fmpz_lll_check_babai_heuristic_d"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_check_babai_heuristic_d()</span></code></a>) for only one
loop and switches right back to the fast version. It reduces <code class="docutils literal notranslate"><span class="pre">B</span></code> in
place. <code class="docutils literal notranslate"><span class="pre">U</span></code> is the matrix used to capture the unimodular
transformations if it is not <span class="math notranslate nohighlight">\(NULL\)</span>. An exception is raised if <span class="math notranslate nohighlight">\(U != NULL\)</span>
and <span class="math notranslate nohighlight">\(U-&gt;r != d\)</span>, where <span class="math notranslate nohighlight">\(d\)</span> is the lattice dimension. <code class="docutils literal notranslate"><span class="pre">fl</span></code> is the
context object containing information containing the LLL parameters delta
and eta. The function can perform reduction on both the lattice basis as
well as its Gram matrix. The type of lattice representation can be
specified via the parameter <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code>. The type of Gram matrix to be
used in computation (approximate or exact) can also be specified through
the variable <code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> (applies only if <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code> == <span class="math notranslate nohighlight">\(Z\_BASIS\)</span>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_d_heuristic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_d_heuristic</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_d_heuristic" title="Link to this definition">¶</a><br /></dt>
<dd><p>This LLL reduces <code class="docutils literal notranslate"><span class="pre">B</span></code> in place using doubles only. It is similar to
<a class="reference internal" href="#c.fmpz_lll_d" title="fmpz_lll_d"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d()</span></code></a> but only uses the heuristic inner products which
attempt to detect cancellations.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_mpf2">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_mpf2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">prec</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_mpf2" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is LLL using <code class="docutils literal notranslate"><span class="pre">mpf</span></code> with the given precision, <code class="docutils literal notranslate"><span class="pre">prec</span></code> for the
underlying GSO. It reduces <code class="docutils literal notranslate"><span class="pre">B</span></code> in place like the other LLL functions.
The <span class="math notranslate nohighlight">\(mpf2\)</span> in the function name refers to the way the <code class="docutils literal notranslate"><span class="pre">mpf_t</span></code>’s are
initialised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_mpf">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_mpf</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_mpf" title="Link to this definition">¶</a><br /></dt>
<dd><p>A wrapper of <a class="reference internal" href="#c.fmpz_lll_mpf2" title="fmpz_lll_mpf2"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_mpf2()</span></code></a>. This currently begins with
<span class="math notranslate nohighlight">\(prec == D_BITS\)</span>, then for the first 20 loops, increases the precision one
limb at a time. After 20 loops, it doubles the precision each time. There
is a proof that this will eventually work. The return value of this
function is 0 if the LLL is successful or -1 if the precision maxes out
before <code class="docutils literal notranslate"><span class="pre">B</span></code> is LLL-reduced.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_wrapper">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_wrapper</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_wrapper" title="Link to this definition">¶</a><br /></dt>
<dd><p>A wrapper of the above procedures. It begins with the greediest version
(<a class="reference internal" href="#c.fmpz_lll_d" title="fmpz_lll_d"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d()</span></code></a>), then adapts to the version using heuristic inner
products only (<a class="reference internal" href="#c.fmpz_lll_d_heuristic" title="fmpz_lll_d_heuristic"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_heuristic()</span></code></a>) if <span class="math notranslate nohighlight">\(fl-&gt;rt == Z\_BASIS\)</span> and
<span class="math notranslate nohighlight">\(fl-&gt;gt == APPROX\)</span>, and finally to the mpf version (<a class="reference internal" href="#c.fmpz_lll_mpf" title="fmpz_lll_mpf"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_mpf()</span></code></a>)
if needed.</p>
<p><code class="docutils literal notranslate"><span class="pre">U</span></code> is the matrix used to capture the unimodular
transformations if it is not <span class="math notranslate nohighlight">\(NULL\)</span>. An exception is raised if <span class="math notranslate nohighlight">\(U != NULL\)</span>
and <span class="math notranslate nohighlight">\(U-&gt;r != d\)</span>, where <span class="math notranslate nohighlight">\(d\)</span> is the lattice dimension. <code class="docutils literal notranslate"><span class="pre">fl</span></code> is the
context object containing information containing the LLL parameters delta
and eta. The function can perform reduction on both the lattice basis as
well as its Gram matrix. The type of lattice representation can be
specified via the parameter <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code>. The type of Gram matrix to be
used in computation (approximate or exact) can also be specified through
the variable <code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> (applies only if <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code> == <span class="math notranslate nohighlight">\(Z\_BASIS\)</span>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_d_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_d_with_removal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_d_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#c.fmpz_lll_d" title="fmpz_lll_d"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d()</span></code></a> but with a removal bound, <code class="docutils literal notranslate"><span class="pre">gs_B</span></code>. The
return value is the new dimension of <code class="docutils literal notranslate"><span class="pre">B</span></code> if removals are desired.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_d_heuristic_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_d_heuristic_with_removal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_d_heuristic_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#c.fmpz_lll_d_heuristic" title="fmpz_lll_d_heuristic"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_heuristic()</span></code></a> but with a removal bound,
<code class="docutils literal notranslate"><span class="pre">gs_B</span></code>. The return value is the new dimension of <code class="docutils literal notranslate"><span class="pre">B</span></code> if removals
are desired.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_mpf2_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_mpf2_with_removal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">prec</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_mpf2_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Same as <a class="reference internal" href="#c.fmpz_lll_mpf2" title="fmpz_lll_mpf2"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_mpf2()</span></code></a> but with a removal bound, <code class="docutils literal notranslate"><span class="pre">gs_B</span></code>. The
return value is the new dimension of <code class="docutils literal notranslate"><span class="pre">B</span></code> if removals are desired.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_mpf_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_mpf_with_removal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_mpf_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>A wrapper of <a class="reference internal" href="#c.fmpz_lll_mpf2_with_removal" title="fmpz_lll_mpf2_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_mpf2_with_removal()</span></code></a>. This currently begins
with <span class="math notranslate nohighlight">\(prec == D\_BITS\)</span>, then for the first 20 loops, increases the precision
one limb at a time. After 20 loops, it doubles the precision each time.
There is a proof that this will eventually work. The return value of this
function is the new dimension of <code class="docutils literal notranslate"><span class="pre">B</span></code> if removals are desired or -1 if
the precision maxes out before <code class="docutils literal notranslate"><span class="pre">B</span></code> is LLL-reduced.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_wrapper_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_wrapper_with_removal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_wrapper_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>A wrapper of the procedures implementing the base case LLL with the
addition of the removal boundary. It begins with the greediest version
(<a class="reference internal" href="#c.fmpz_lll_d_with_removal" title="fmpz_lll_d_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_with_removal()</span></code></a>), then adapts to the version using
heuristic inner products only (<a class="reference internal" href="#c.fmpz_lll_d_heuristic_with_removal" title="fmpz_lll_d_heuristic_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_heuristic_with_removal()</span></code></a>)
if <span class="math notranslate nohighlight">\(fl-&gt;rt == Z\_BASIS\)</span> and <span class="math notranslate nohighlight">\(fl-&gt;gt == APPROX\)</span>, and finally to the mpf
version (<a class="reference internal" href="#c.fmpz_lll_mpf_with_removal" title="fmpz_lll_mpf_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_mpf_with_removal()</span></code></a>) if needed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_d_with_removal_knapsack">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_d_with_removal_knapsack</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_d_with_removal_knapsack" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is floating point LLL specialized to knapsack-type lattices. It
performs early size reductions occasionally which makes things faster in
the knapsack case. Otherwise, it is similar to
<code class="docutils literal notranslate"><span class="pre">fmpz_lll_d_with_removal</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_wrapper_with_removal_knapsack">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_wrapper_with_removal_knapsack</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_wrapper_with_removal_knapsack" title="Link to this definition">¶</a><br /></dt>
<dd><p>A wrapper of the procedures implementing the LLL specialized to
knapsack-type lattices. It begins with the greediest version and the engine
of this version, (<a class="reference internal" href="#c.fmpz_lll_d_with_removal_knapsack" title="fmpz_lll_d_with_removal_knapsack"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_with_removal_knapsack()</span></code></a>), then adapts
to the version using heuristic inner products only
(<a class="reference internal" href="#c.fmpz_lll_d_heuristic_with_removal" title="fmpz_lll_d_heuristic_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_d_heuristic_with_removal()</span></code></a>) if <span class="math notranslate nohighlight">\(fl-&gt;rt == Z\_BASIS\)</span> and
<span class="math notranslate nohighlight">\(fl-&gt;gt == APPROX\)</span>, and finally to the mpf version
(<a class="reference internal" href="#c.fmpz_lll_mpf_with_removal" title="fmpz_lll_mpf_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_lll_mpf_with_removal()</span></code></a>) if needed.</p>
</dd></dl>

</section>
<section id="ulll">
<h2>ULLL<a class="headerlink" href="#ulll" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_with_removal_ulll">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_with_removal_ulll</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">FM</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">UM</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">new_size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_with_removal_ulll" title="Link to this definition">¶</a><br /></dt>
<dd><p>ULLL is a new style of LLL which does adjoins an identity matrix to the
input lattice <code class="docutils literal notranslate"><span class="pre">FM</span></code>, then scales the lattice down to <code class="docutils literal notranslate"><span class="pre">new_size</span></code>
bits and reduces this augmented lattice. This tends to be more stable
numerically than traditional LLL which means higher dimensions can be
attacked using doubles. In each iteration a new identity matrix is adjoined
to the truncated lattice. <code class="docutils literal notranslate"><span class="pre">UM</span></code> is used to capture the unimodular
transformations, while <code class="docutils literal notranslate"><span class="pre">gs_B</span></code> and <code class="docutils literal notranslate"><span class="pre">fl</span></code> have the same role as in
the previous routines. The function is optimised for factoring polynomials.</p>
</dd></dl>

</section>
<section id="lll-reducedness">
<h2>LLL-reducedness<a class="headerlink" href="#lll-reducedness" title="Link to this heading">¶</a></h2>
<p>These programs implement ideas from the paper <a class="reference internal" href="references.html#villard2007" id="id2"><span>[Villard2007]</span></a>.
See <a class="reference external" href="https://arxiv.org/abs/cs/0701183">https://arxiv.org/abs/cs/0701183</a> for the algorithm of Villard.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_is_reduced_d">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_is_reduced_d</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_is_reduced_d" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_lll_is_reduced_mpfr">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_is_reduced_mpfr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_is_reduced_mpfr" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_lll_is_reduced_d_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_is_reduced_d_with_removal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">newd</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_is_reduced_d_with_removal" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_lll_is_reduced_mpfr_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_is_reduced_mpfr_with_removal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">newd</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_is_reduced_mpfr_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>A non-zero return indicates the matrix is definitely reduced, that is, that
* <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced" title="fmpz_mat_is_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced()</span></code></a> or <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced_gram" title="fmpz_mat_is_reduced_gram"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram()</span></code></a> (for the first two)
* <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced_with_removal" title="fmpz_mat_is_reduced_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_with_removal()</span></code></a> or <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced_gram_with_removal" title="fmpz_mat_is_reduced_gram_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram_with_removal()</span></code></a> (for the last two)
return non-zero. A zero return value is inconclusive.
The <span class="math notranslate nohighlight">\(_d\)</span> variants are performed in machine precision, while the <span class="math notranslate nohighlight">\(_mpfr\)</span> uses a precision of <span class="math notranslate nohighlight">\(prec\)</span> bits.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_is_reduced">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_is_reduced</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_is_reduced" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_lll_is_reduced_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_is_reduced_with_removal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">newd</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">prec</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_is_reduced_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>The return from these functions is always conclusive: the functions
* <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced" title="fmpz_mat_is_reduced"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced()</span></code></a> or <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced_gram" title="fmpz_mat_is_reduced_gram"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram()</span></code></a>
* <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced_with_removal" title="fmpz_mat_is_reduced_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_with_removal()</span></code></a> or <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_is_reduced_gram_with_removal" title="fmpz_mat_is_reduced_gram_with_removal"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_is_reduced_gram_with_removal()</span></code></a>
are optimzied by calling the above heuristics first and returning right away if they give a conclusive answer.</p>
</dd></dl>

</section>
<section id="modified-ulll">
<h2>Modified ULLL<a class="headerlink" href="#modified-ulll" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_storjohann_ulll">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_storjohann_ulll</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">FM</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">new_size</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_storjohann_ulll" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs ULLL using <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_lll_storjohann" title="fmpz_mat_lll_storjohann"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_mat_lll_storjohann()</span></code></a> as the LLL function.</p>
</dd></dl>

</section>
<section id="main-lll-functions">
<h2>Main LLL functions<a class="headerlink" href="#main-lll-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reduces <code class="docutils literal notranslate"><span class="pre">B</span></code> in place according to the parameters specified by the
LLL context object <code class="docutils literal notranslate"><span class="pre">fl</span></code>.</p>
<p>This is the main LLL function which should be called by the user. It
currently calls the ULLL algorithm (without removals). The ULLL function
in turn calls a LLL wrapper which tries to choose an optimal LLL algorithm,
starting with a version using just doubles (ULLL tries to maximise usage
of this), then a heuristic LLL a full precision floating point LLL if
required.</p>
<p><code class="docutils literal notranslate"><span class="pre">U</span></code> is the matrix used to capture the unimodular
transformations if it is not <span class="math notranslate nohighlight">\(NULL\)</span>. An exception is raised if <span class="math notranslate nohighlight">\(U != NULL\)</span>
and <span class="math notranslate nohighlight">\(U-&gt;r != d\)</span>, where <span class="math notranslate nohighlight">\(d\)</span> is the lattice dimension. <code class="docutils literal notranslate"><span class="pre">fl</span></code> is the
context object containing information containing the LLL parameters delta
and eta. The function can perform reduction on both the lattice basis as
well as its Gram matrix. The type of lattice representation can be
specified via the parameter <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code>. The type of Gram matrix to be
used in computation (approximate or exact) can also be specified through
the variable <code class="docutils literal notranslate"><span class="pre">fl-&gt;gt</span></code> (applies only if <code class="docutils literal notranslate"><span class="pre">fl-&gt;rt</span></code> == <span class="math notranslate nohighlight">\(Z\_BASIS\)</span>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_lll_with_removal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_lll_with_removal</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <a class="reference internal" href="fmpz_mat.html#c.fmpz_mat_t" title="fmpz_mat_t"><span class="n"><span class="pre">fmpz_mat_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">U</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">gs_B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_lll_t</span></span><span class="w"> </span><span class="n"><span class="pre">fl</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_lll_with_removal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reduces <code class="docutils literal notranslate"><span class="pre">B</span></code> in place according to the parameters specified by the
LLL context object <code class="docutils literal notranslate"><span class="pre">fl</span></code> and removes vectors whose squared Gram-Schmidt
length is greater than the bound <code class="docutils literal notranslate"><span class="pre">gs_B</span></code>. The return value is the new
dimension of <code class="docutils literal notranslate"><span class="pre">B</span></code> to be considered for further computation.</p>
<p>This is the main LLL with removals function which should be called by
the user. Like <code class="docutils literal notranslate"><span class="pre">fmpz_lll</span></code> it calls ULLL, but it also sets the
Gram-Schmidt bound to that supplied and does removals.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><strong>fmpz_lll.h</strong> – LLL reduction</a><ul>
<li><a class="reference internal" href="#parameter-manipulation">Parameter manipulation</a></li>
<li><a class="reference internal" href="#random-parameter-generation">Random parameter generation</a></li>
<li><a class="reference internal" href="#heuristic-dot-product">Heuristic dot product</a></li>
<li><a class="reference internal" href="#the-various-babai-s">The various Babai’s</a></li>
<li><a class="reference internal" href="#shift">Shift</a></li>
<li><a class="reference internal" href="#varieties-of-lll">Varieties of LLL</a></li>
<li><a class="reference internal" href="#ulll">ULLL</a></li>
<li><a class="reference internal" href="#lll-reducedness">LLL-reducedness</a></li>
<li><a class="reference internal" href="#modified-ulll">Modified ULLL</a></li>
<li><a class="reference internal" href="#main-lll-functions">Main LLL functions</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="fmpz_mat.html"
                          title="previous chapter"><strong>fmpz_mat.h</strong> – matrices over the integers</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="fmpz_poly.html"
                          title="next chapter"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/fmpz_lll.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fmpz_poly.html" title="fmpz_poly.h – univariate polynomials over the integers"
             >next</a> |</li>
        <li class="right" >
          <a href="fmpz_mat.html" title="fmpz_mat.h – matrices over the integers"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>fmpz_lll.h</strong> – LLL reduction</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2018, The Flint development team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>