<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>fmpz_poly.h – univariate polynomials over the integers &#8212; Flint 2.9.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    
    <script src="_static/documentation_options.js?v=182a64a0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="fmpz_poly_mat.h – matrices of polynomials over the integers" href="fmpz_poly_mat.html" />
    <link rel="prev" title="fmpz_lll.h – LLL reduction" href="fmpz_lll.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fmpz_poly_mat.html" title="fmpz_poly_mat.h – matrices of polynomials over the integers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fmpz_lll.html" title="fmpz_lll.h – LLL reduction"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="fmpz-poly-h-univariate-polynomials-over-the-integers">
<span id="fmpz-poly"></span><h1><strong>fmpz_poly.h</strong> – univariate polynomials over the integers<a class="headerlink" href="#fmpz-poly-h-univariate-polynomials-over-the-integers" title="Link to this heading">¶</a></h1>
<p>Description.</p>
<section id="types-macros-and-constants">
<h2>Types, macros and constants<a class="headerlink" href="#types-macros-and-constants" title="Link to this heading">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.fmpz_poly_struct">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_struct</span></span></span><a class="headerlink" href="#c.fmpz_poly_struct" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.fmpz_poly_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_t</span></span></span><a class="headerlink" href="#c.fmpz_poly_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Description.</p>
</dd></dl>

</section>
<section id="memory-management">
<h2>Memory management<a class="headerlink" href="#memory-management" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises <code class="docutils literal notranslate"><span class="pre">poly</span></code> for use, setting its length to zero.
A corresponding call to <a class="reference internal" href="#c.fmpz_poly_clear" title="fmpz_poly_clear"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_poly_clear()</span></code></a> must be made after
finishing with the <code class="docutils literal notranslate"><span class="pre">fmpz_poly_t</span></code> to free the memory used by
the polynomial.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_init2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_init2</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">alloc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_init2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises <code class="docutils literal notranslate"><span class="pre">poly</span></code> with space for at least <code class="docutils literal notranslate"><span class="pre">alloc</span></code> coefficients
and sets the length to zero.  The allocated coefficients are all set to
zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_realloc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_realloc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">alloc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_realloc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reallocates the given polynomial to have space for <code class="docutils literal notranslate"><span class="pre">alloc</span></code>
coefficients.  If <code class="docutils literal notranslate"><span class="pre">alloc</span></code> is zero the polynomial is cleared
and then reinitialised.  If the current length is greater than
<code class="docutils literal notranslate"><span class="pre">alloc</span></code> the polynomial is first truncated to length <code class="docutils literal notranslate"><span class="pre">alloc</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_fit_length">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_fit_length</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_fit_length" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">len</span></code> is greater than the number of coefficients currently
allocated, then the polynomial is reallocated to have space for at
least <code class="docutils literal notranslate"><span class="pre">len</span></code> coefficients.  No data is lost when calling this
function.</p>
<p>The function efficiently deals with the case where <code class="docutils literal notranslate"><span class="pre">fit_length</span></code> is
called many times in small increments by at least doubling the number
of allocated coefficients when length is larger than the number of
coefficients currently allocated.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears the given polynomial, releasing any memory used.  It must
be reinitialised in order to be used again.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_normalise">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_normalise</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_normalise" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> so that the top coefficient is non-zero.
If all coefficients are zero, the length is set to zero.  This function
is mainly used internally, as all functions guarantee normalisation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_set_length">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_set_length</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">newlen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_set_length" title="Link to this definition">¶</a><br /></dt>
<dd><p>Demotes the coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code> beyond <code class="docutils literal notranslate"><span class="pre">newlen</span></code> and sets
the length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> to <code class="docutils literal notranslate"><span class="pre">newlen</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_attach_truncate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_attach_truncate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">trunc</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_attach_truncate" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function sets the uninitialised polynomial <code class="docutils literal notranslate"><span class="pre">trunc</span></code> to the low
<span class="math notranslate nohighlight">\(n\)</span> coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>, or to <code class="docutils literal notranslate"><span class="pre">poly</span></code> if the latter doesn’t
have <span class="math notranslate nohighlight">\(n\)</span> coefficients. The polynomial <code class="docutils literal notranslate"><span class="pre">trunc</span></code> not be cleared or used
as the output of any Flint functions.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_attach_shift">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_attach_shift</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">trunc</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_attach_shift" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function sets the uninitialised polynomial <code class="docutils literal notranslate"><span class="pre">trunc</span></code> to the
high coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>, i.e. the coefficients not among the low
<span class="math notranslate nohighlight">\(n\)</span> coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>. If the latter doesn’t have <span class="math notranslate nohighlight">\(n\)</span>
coefficients <code class="docutils literal notranslate"><span class="pre">trunc</span></code> is set to the zero polynomial. The polynomial
<code class="docutils literal notranslate"><span class="pre">trunc</span></code> not be cleared or used as the output of any Flint functions.</p>
</dd></dl>

</section>
<section id="polynomial-parameters">
<h2>Polynomial parameters<a class="headerlink" href="#polynomial-parameters" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_length">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_length</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_length" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the length of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.  The zero polynomial has length zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_degree">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_degree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_degree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the degree of <code class="docutils literal notranslate"><span class="pre">poly</span></code>, which is one less than its length.</p>
</dd></dl>

</section>
<section id="assignment-and-basic-manipulation">
<h2>Assignment and basic manipulation<a class="headerlink" href="#assignment-and-basic-manipulation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to equal <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the signed integer <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the unsigned integer <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the integer <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_mpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the integer <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_set_str">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_set_str</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_set_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the polynomial encoded in the null-terminated
string <code class="docutils literal notranslate"><span class="pre">str</span></code>.  Assumes that <code class="docutils literal notranslate"><span class="pre">poly</span></code> is allocated as a
sufficiently large array suitable for the number of coefficients
present in <code class="docutils literal notranslate"><span class="pre">str</span></code>.</p>
<p>Returns <span class="math notranslate nohighlight">\(0\)</span> if no error occurred.  Otherwise, returns a non-zero
value, in which case the resulting value of <code class="docutils literal notranslate"><span class="pre">poly</span></code> is undefined.
If <code class="docutils literal notranslate"><span class="pre">str</span></code> is not null-terminated, calling this method might result
in a segmentation fault.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_str">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_str</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>Imports a polynomial from a null-terminated string.  If the string
<code class="docutils literal notranslate"><span class="pre">str</span></code> represents a valid polynomial returns <span class="math notranslate nohighlight">\(0\)</span>, otherwise
returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>Returns <span class="math notranslate nohighlight">\(0\)</span> if no error occurred.  Otherwise, returns a non-zero value,
in which case the resulting value of <code class="docutils literal notranslate"><span class="pre">poly</span></code> is undefined.  If
<code class="docutils literal notranslate"><span class="pre">str</span></code> is not null-terminated, calling this method might result in
a segmentation fault.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_get_str">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_get_str</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_get_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the plain FLINT string representation of the polynomial
<code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_get_str">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_get_str</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_get_str" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the plain FLINT string representation of the polynomial
<code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_get_str_pretty">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_get_str_pretty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_get_str_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pretty representation of the polynomial
<code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> using the null-terminated string <code class="docutils literal notranslate"><span class="pre">x</span></code> as the
variable name.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_get_str_pretty">
<span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_get_str_pretty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_get_str_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pretty representation of the polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code> using the
null-terminated string <code class="docutils literal notranslate"><span class="pre">x</span></code> as the variable name.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_zero">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the zero polynomial.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_one">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_one</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the constant polynomial one.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_zero_coeffs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_zero_coeffs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_zero_coeffs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the coefficients of <span class="math notranslate nohighlight">\(x^i, \dotsc, x^{j-1}\)</span> to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_swap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_swap</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_swap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swaps <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.  This is done efficiently without
copying data by swapping pointers, etc.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_reverse">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_reverse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_reverse" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the reverse of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">poly</span></code> is in fact an array of length <code class="docutils literal notranslate"><span class="pre">len</span></code>.  Assumes that
<code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">len</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>.  Supports aliasing of <code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">poly</span></code>,
but the behaviour is undefined in case of partial overlap.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_reverse">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_reverse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_reverse" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function considers the polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code> to be of length <span class="math notranslate nohighlight">\(n\)</span>,
notionally truncating and zero padding if required, and reverses
the result.  Since the function normalises its result <code class="docutils literal notranslate"><span class="pre">res</span></code> may be
of length less than <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_truncate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_truncate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">newlen</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_truncate" title="Link to this definition">¶</a><br /></dt>
<dd><p>If the current length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">newlen</span></code>, it
is truncated to have the given length.  Discarded coefficients are not
necessarily set to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_trunc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_trunc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_trunc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to a copy of <code class="docutils literal notranslate"><span class="pre">poly</span></code>, truncated to length <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd></dl>

</section>
<section id="randomisation">
<h2>Randomisation<a class="headerlink" href="#randomisation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_randtest">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to a random polynomial with up to the given length and where
each coefficient has up to the given number of bits. The coefficients
are signed randomly. One must call <a class="reference internal" href="flint.html#c.flint_randinit" title="flint_randinit"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_randinit()</span></code></a> before
calling this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_randtest_unsigned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_randtest_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_randtest_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to a random polynomial with up to the given length and where
each coefficient has up to the given number of bits. One must call
<a class="reference internal" href="flint.html#c.flint_randinit" title="flint_randinit"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_randinit()</span></code></a> before calling this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_randtest_not_zero">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_randtest_not_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_randtest_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <a class="reference internal" href="#c.fmpz_poly_randtest" title="fmpz_poly_randtest"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_poly_randtest()</span></code></a> except that <code class="docutils literal notranslate"><span class="pre">len</span></code> and bits may
not be zero and the polynomial generated is guaranteed not to be the
zero polynomial.  One must call <a class="reference internal" href="flint.html#c.flint_randinit" title="flint_randinit"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_randinit()</span></code></a> before
calling this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_randtest_no_real_root">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_randtest_no_real_root</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_randtest_no_real_root" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">p</span></code> to a random polynomial without any real root, whose
length is up to <code class="docutils literal notranslate"><span class="pre">len</span></code> and where each coefficient has up to the
given number of bits. One must call <a class="reference internal" href="flint.html#c.flint_randinit" title="flint_randinit"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_randinit()</span></code></a> before
calling this function.</p>
</dd></dl>

</section>
<section id="getting-and-setting-coefficients">
<h2>Getting and setting coefficients<a class="headerlink" href="#getting-and-setting-coefficients" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_get_coeff_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_get_coeff_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_get_coeff_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(x\)</span> to the <span class="math notranslate nohighlight">\(n\)</span>-th coefficient of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.  Coefficient
numbering is from zero and if <span class="math notranslate nohighlight">\(n\)</span> is set to a value beyond the end of
the polynomial, zero is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_get_coeff_si">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_get_coeff_si</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_get_coeff_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns coefficient <span class="math notranslate nohighlight">\(n\)</span> of <code class="docutils literal notranslate"><span class="pre">poly</span></code> as a <code class="docutils literal notranslate"><span class="pre">slong</span></code>. The result is
undefined if the value does not fit into a <code class="docutils literal notranslate"><span class="pre">slong</span></code>. Coefficient
numbering is from zero and if <span class="math notranslate nohighlight">\(n\)</span> is set to a value beyond the end of
the polynomial, zero is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_get_coeff_ui">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_get_coeff_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_get_coeff_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns coefficient <span class="math notranslate nohighlight">\(n\)</span> of <code class="docutils literal notranslate"><span class="pre">poly</span></code> as a <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.  The result is
undefined if the value does not fit into a <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.  Coefficient
numbering is from zero and if <span class="math notranslate nohighlight">\(n\)</span> is set to a value beyond the end of the
polynomial, zero is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_get_coeff_ptr">
<a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_get_coeff_ptr</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_get_coeff_ptr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the coefficient of <span class="math notranslate nohighlight">\(x^n\)</span> in the polynomial,
as an <code class="docutils literal notranslate"><span class="pre">fmpz</span> <span class="pre">*</span></code>.  This function is provided so that individual
coefficients can be accessed and operated on by functions in the
<code class="docutils literal notranslate"><span class="pre">fmpz</span></code> module.  This function does not make a copy of the
data, but returns a reference to the actual coefficient.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when <span class="math notranslate nohighlight">\(n\)</span> exceeds the degree of the polynomial.</p>
<p>This function is implemented as a macro.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_lead">
<a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_lead</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_lead" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the leading coefficient of the polynomial,
as an <code class="docutils literal notranslate"><span class="pre">fmpz</span> <span class="pre">*</span></code>.  This function is provided so that the leading
coefficient can be easily accessed and operated on by functions in
the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> module.  This function does not make a copy of the
data, but returns a reference to the actual coefficient.</p>
<p>Returns <code class="docutils literal notranslate"><span class="pre">NULL</span></code> when the polynomial is zero.</p>
<p>This function is implemented as a macro.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_coeff_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_coeff_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_coeff_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets coefficient <span class="math notranslate nohighlight">\(n\)</span> of <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code> value <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Coefficient numbering starts from zero and if <span class="math notranslate nohighlight">\(n\)</span> is beyond the current
length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> then the polynomial is extended and zero
coefficients inserted if necessary.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_coeff_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_coeff_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_coeff_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets coefficient <span class="math notranslate nohighlight">\(n\)</span> of <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the <code class="docutils literal notranslate"><span class="pre">slong</span></code> value <code class="docutils literal notranslate"><span class="pre">x</span></code>.
Coefficient numbering starts from zero and if <span class="math notranslate nohighlight">\(n\)</span> is beyond the current
length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> then the polynomial is extended and zero
coefficients inserted if necessary.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_coeff_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_coeff_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_coeff_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets coefficient <span class="math notranslate nohighlight">\(n\)</span> of <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the <code class="docutils literal notranslate"><span class="pre">ulong</span></code> value
<code class="docutils literal notranslate"><span class="pre">x</span></code>.  Coefficient numbering starts from zero and if <span class="math notranslate nohighlight">\(n\)</span> is beyond
the current length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> then the polynomial is extended and
zero coefficients inserted if necessary.</p>
</dd></dl>

</section>
<section id="comparison">
<h2>Comparison<a class="headerlink" href="#comparison" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_equal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_equal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_equal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <code class="docutils literal notranslate"><span class="pre">poly1</span></code> is equal to <code class="docutils literal notranslate"><span class="pre">poly2</span></code>, otherwise
returns <span class="math notranslate nohighlight">\(0\)</span>.  The polynomials are assumed to be normalised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_equal_trunc">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_equal_trunc</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_equal_trunc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(1\)</span> if <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>, notionally truncated to
length <span class="math notranslate nohighlight">\(n\)</span> are equal, otherwise return <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_is_zero">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_is_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_is_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if the polynomial is zero and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p>
<p>This function is implemented as a macro.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_is_one">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_is_one</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_is_one" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if the polynomial is one and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_is_unit">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_is_unit</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_is_unit" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> is the polynomial is the constant polynomial <span class="math notranslate nohighlight">\(\pm 1\)</span>,
and <span class="math notranslate nohighlight">\(0\)</span> otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_is_gen">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_is_gen</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_is_gen" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if the polynomial is the degree <span class="math notranslate nohighlight">\(1\)</span> polynomial <span class="math notranslate nohighlight">\(x\)</span>, and <span class="math notranslate nohighlight">\(0\)</span>
otherwise.</p>
</dd></dl>

</section>
<section id="addition-and-subtraction">
<h2>Addition and subtraction<a class="headerlink" href="#addition-and-subtraction" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the sum of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.  It is assumed that <code class="docutils literal notranslate"><span class="pre">res</span></code> has
sufficient space for the longer of the two polynomials.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_add</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the sum of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_add_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_add_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_add_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Notionally truncate <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> to length <span class="math notranslate nohighlight">\(n\)</span> and then
set <code class="docutils literal notranslate"><span class="pre">res</span></code> to the sum.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sub</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> minus <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.  It
is assumed that <code class="docutils literal notranslate"><span class="pre">res</span></code> has sufficient space for the longer of the
two polynomials.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sub</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">poly1</span></code> minus <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sub_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sub_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sub_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Notionally truncate <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> to length <span class="math notranslate nohighlight">\(n\)</span> and then
set <code class="docutils literal notranslate"><span class="pre">res</span></code> to the sum.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_neg">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_neg</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_neg" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">-poly</span></code>.</p>
</dd></dl>

</section>
<section id="scalar-absolute-value-multiplication-and-division">
<h2>Scalar absolute value, multiplication and division<a class="headerlink" href="#scalar-absolute-value-multiplication-and-division" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_abs">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_abs</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_abs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to the polynomial whose coefficients are the absolute
value of those of <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_mul_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_mul_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_mul_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> times <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_mul_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_mul_mpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_mul_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> times the <code class="docutils literal notranslate"><span class="pre">mpz_t</span></code> <span class="math notranslate nohighlight">\(x\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_mul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_mul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_mul_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> times the signed <code class="docutils literal notranslate"><span class="pre">slong</span> <span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_mul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_mul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_mul_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> times the <code class="docutils literal notranslate"><span class="pre">ulong</span> <span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_mul_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_mul_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_mul_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> times <code class="docutils literal notranslate"><span class="pre">2^exp</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_addmul_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_addmul_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_addmul_si" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_addmul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_addmul_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_addmul_ui" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_addmul_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_addmul_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_addmul_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly1</span> <span class="pre">+</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_submul_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_submul_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_submul_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly1</span> <span class="pre">-</span> <span class="pre">x</span> <span class="pre">*</span> <span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_fdiv_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_fdiv_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_fdiv_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">fmpz_t</span> <span class="pre">x</span></code>,
rounding coefficients down toward <span class="math notranslate nohighlight">\(- \infty\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_fdiv_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_fdiv_mpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_fdiv_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">mpz_t</span> <span class="pre">x</span></code>,
rounding coefficients down toward <span class="math notranslate nohighlight">\(- \infty\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_fdiv_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_fdiv_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_fdiv_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">slong</span> <span class="pre">x</span></code>,
rounding coefficients down toward <span class="math notranslate nohighlight">\(- \infty\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_fdiv_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_fdiv_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_fdiv_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">ulong</span> <span class="pre">x</span></code>,
rounding coefficients down toward <span class="math notranslate nohighlight">\(- \infty\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_fdiv_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_fdiv_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_fdiv_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by <code class="docutils literal notranslate"><span class="pre">2^x</span></code>,
rounding coefficients down toward <span class="math notranslate nohighlight">\(- \infty\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_tdiv_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_tdiv_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_tdiv_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">fmpz_t</span> <span class="pre">x</span></code>,
rounding coefficients toward <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_tdiv_si">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_tdiv_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_tdiv_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">slong</span> <span class="pre">x</span></code>,
rounding coefficients toward <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_tdiv_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_tdiv_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_tdiv_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">ulong</span> <span class="pre">x</span></code>,
rounding coefficients toward <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_tdiv_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_tdiv_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_tdiv_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by <code class="docutils literal notranslate"><span class="pre">2^x</span></code>,
rounding coefficients toward <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_divexact_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_divexact_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_divexact_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">fmpz_t</span> <span class="pre">x</span></code>,
assuming the division is exact for every coefficient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_divexact_mpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_divexact_mpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpz_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_divexact_mpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">mpz_t</span> <span class="pre">x</span></code>,
assuming the coefficient is exact for every coefficient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_divexact_si">
<span class="n"><span class="pre">id</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_divexact_si</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_divexact_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">slong</span> <span class="pre">x</span></code>,
assuming the coefficient is exact for every coefficient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_divexact_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_divexact_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_divexact_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by the <code class="docutils literal notranslate"><span class="pre">ulong</span> <span class="pre">x</span></code>,
assuming the coefficient is exact for every coefficient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_mod_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_mod_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_mod_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code>, reducing each coefficient
modulo <span class="math notranslate nohighlight">\(p &gt; 0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_scalar_smod_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_scalar_smod_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_scalar_smod_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly1</span></code> to <code class="docutils literal notranslate"><span class="pre">poly2</span></code>, symmetrically reducing
each coefficient modulo <span class="math notranslate nohighlight">\(p &gt; 0\)</span>, that is, choosing the unique
representative in the interval <span class="math notranslate nohighlight">\((-p/2, p/2]\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_remove_content_2exp">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_remove_content_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pol</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_remove_content_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove the 2-content of <code class="docutils literal notranslate"><span class="pre">pol</span></code> and return the number <span class="math notranslate nohighlight">\(k\)</span>
that is the maximal non-negative integer so that <span class="math notranslate nohighlight">\(2^k\)</span> divides
all coefficients of the polynomial. For the zero polynomial,
<span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_scale_2exp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_scale_2exp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pol</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_scale_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Scale <code class="docutils literal notranslate"><span class="pre">(pol,</span> <span class="pre">len)</span></code> to <span class="math notranslate nohighlight">\(p(2^k X)\)</span> in-place and divide by the
2-content (so that the gcd of coefficients is odd). If <code class="docutils literal notranslate"><span class="pre">k</span></code>
is negative the polynomial is multiplied by <span class="math notranslate nohighlight">\(2^{kd}\)</span>.</p>
</dd></dl>

</section>
<section id="bit-packing">
<h2>Bit packing<a class="headerlink" href="#bit-packing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_bit_pack">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_bit_pack</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">arr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bit_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">negate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_bit_pack" title="Link to this definition">¶</a><br /></dt>
<dd><p>Packs the coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code> into bitfields of the given
<code class="docutils literal notranslate"><span class="pre">bit_size</span></code>, negating the coefficients before packing
if <code class="docutils literal notranslate"><span class="pre">negate</span></code> is set to <span class="math notranslate nohighlight">\(-1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_bit_unpack">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_bit_unpack</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">arr</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bit_size</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">negate</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_bit_unpack" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpacks the polynomial of given length from the array as packed into
fields of the given <code class="docutils literal notranslate"><span class="pre">bit_size</span></code>, finally negating the coefficients
if <code class="docutils literal notranslate"><span class="pre">negate</span></code> is set to <span class="math notranslate nohighlight">\(-1\)</span>. Returns borrow, which is nonzero if a
leading term with coefficient <span class="math notranslate nohighlight">\(\pm1\)</span> should be added at
position <code class="docutils literal notranslate"><span class="pre">len</span></code> of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_bit_unpack_unsigned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_bit_unpack_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">mp_srcptr_t</span></span><span class="w"> </span><span class="n"><span class="pre">arr</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bit_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_bit_unpack_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpacks the polynomial of given length from the array as packed into
fields of the given <code class="docutils literal notranslate"><span class="pre">bit_size</span></code>.  The coefficients are assumed to
be unsigned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_bit_pack">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_bit_pack</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bit_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_bit_pack" title="Link to this definition">¶</a><br /></dt>
<dd><p>Packs <code class="docutils literal notranslate"><span class="pre">poly</span></code> into bitfields of size <code class="docutils literal notranslate"><span class="pre">bit_size</span></code>, writing the
result to <code class="docutils literal notranslate"><span class="pre">f</span></code>. The sign of <code class="docutils literal notranslate"><span class="pre">f</span></code> will be the same as that of
the leading coefficient of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_bit_unpack">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_bit_unpack</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bit_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_bit_unpack" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpacks the polynomial with signed coefficients packed into
fields of size <code class="docutils literal notranslate"><span class="pre">bit_size</span></code> as represented by the integer <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_bit_unpack_unsigned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_bit_unpack_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bit_size</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_bit_unpack_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpacks the polynomial with unsigned coefficients packed into
fields of size <code class="docutils literal notranslate"><span class="pre">bit_size</span></code> as represented by the integer <code class="docutils literal notranslate"><span class="pre">f</span></code>.
It is required that <code class="docutils literal notranslate"><span class="pre">f</span></code> is nonnegative.</p>
</dd></dl>

</section>
<section id="multiplication">
<h2>Multiplication<a class="headerlink" href="#multiplication" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mul_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mul_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mul_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes <code class="docutils literal notranslate"><span class="pre">len1</span></code> and <code class="docutils literal notranslate"><span class="pre">len2</span></code> are positive.  Allows zero-padding
of the two input polynomials.  No aliasing of inputs with outputs is
allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>, computed
using the classical or schoolbook method.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mullow_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mullow_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mullow_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the first <span class="math notranslate nohighlight">\(n\)</span> coefficients of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code>
multiplied by <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1</span></code>.  Assumes neither <code class="docutils literal notranslate"><span class="pre">len1</span></code> nor
<code class="docutils literal notranslate"><span class="pre">len2</span></code> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mullow_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mullow_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mullow_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the first <span class="math notranslate nohighlight">\(n\)</span> coefficients of <code class="docutils literal notranslate"><span class="pre">poly1</span> <span class="pre">*</span> <span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mulhigh_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mulhigh_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mulhigh_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the first <code class="docutils literal notranslate"><span class="pre">start</span></code> coefficients of <code class="docutils literal notranslate"><span class="pre">res</span></code> to zero and the
remainder to the corresponding coefficients of
<code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span> <span class="pre">*</span> <span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes <code class="docutils literal notranslate"><span class="pre">start</span> <span class="pre">&lt;=</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1</span></code>.  Assumes neither <code class="docutils literal notranslate"><span class="pre">len1</span></code> nor
<code class="docutils literal notranslate"><span class="pre">len2</span></code> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mulhigh_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mulhigh_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mulhigh_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the first <code class="docutils literal notranslate"><span class="pre">start</span></code> coefficients of <code class="docutils literal notranslate"><span class="pre">res</span></code> to zero and the
remainder to the corresponding coefficients of the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code>
and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mulmid_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mulmid_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mulmid_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the middle <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">-</span> <span class="pre">len2</span> <span class="pre">+</span> <span class="pre">1</span></code> coefficients of
the product of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, i.e.the
coefficients from degree <code class="docutils literal notranslate"><span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">-</span> <span class="pre">1</span></code> inclusive.
Assumes that <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mulmid_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mulmid_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mulmid_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the middle <code class="docutils literal notranslate"><span class="pre">len(poly1)</span> <span class="pre">-</span> <span class="pre">len(poly2)</span> <span class="pre">+</span> <span class="pre">1</span></code>
coefficients of <code class="docutils literal notranslate"><span class="pre">poly1</span> <span class="pre">*</span> <span class="pre">poly2</span></code>, i.e.the coefficient from degree
<code class="docutils literal notranslate"><span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1</span></code> to <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">-</span> <span class="pre">1</span></code> inclusive.  Assumes that
<code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mul_karatsuba">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mul_karatsuba</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mul_karatsuba" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.  Assumes <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  Allows
zero-padding of the two input polynomials.  No aliasing of inputs with
outputs is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul_karatsuba">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul_karatsuba</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul_karatsuba" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mullow_karatsuba_n">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mullow_karatsuba_n</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mullow_karatsuba_n" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> and
truncates to the given length.  It is assumed that <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and
<code class="docutils literal notranslate"><span class="pre">poly2</span></code> are precisely the given length, possibly zero padded.
Assumes <span class="math notranslate nohighlight">\(n\)</span> is not zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mullow_karatsuba_n">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mullow_karatsuba_n</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mullow_karatsuba_n" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> and
truncates to the given length.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mulhigh_karatsuba_n">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mulhigh_karatsuba_n</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mulhigh_karatsuba_n" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> and
truncates at the top to the given length.  The first <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">-</span> <span class="pre">1</span></code>
coefficients are set to zero. It is assumed that <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and
<code class="docutils literal notranslate"><span class="pre">poly2</span></code> are precisely the given length, possibly zero padded.
Assumes <code class="docutils literal notranslate"><span class="pre">len</span></code> is not zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mulhigh_karatsuba_n">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mulhigh_karatsuba_n</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mulhigh_karatsuba_n" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the first <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">-</span> <span class="pre">1</span></code> coefficients of the result to zero and the
remaining coefficients to the corresponding coefficients of the product of
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.  Assumes <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> are
at most of the given length.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mul_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mul_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mul_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Places no assumptions on <code class="docutils literal notranslate"><span class="pre">len1</span></code> and <code class="docutils literal notranslate"><span class="pre">len2</span></code>.  Allows zero-padding
of the two input polynomials.  Supports aliasing of inputs and outputs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mullow_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mullow_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mullow_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients of the product of
<code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len1</span></code> and <code class="docutils literal notranslate"><span class="pre">len2</span></code> are positive, but does allow
for the polynomials to be zero-padded.  The polynomials may be zero,
too.  Assumes <span class="math notranslate nohighlight">\(n\)</span> is positive.  Supports aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code>,
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mullow_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mullow_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mullow_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients of the product of
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mul_SS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mul_SS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">output</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">input1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">length1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">input2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">length2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mul_SS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(output,</span> <span class="pre">length1</span> <span class="pre">+</span> <span class="pre">length2</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the product of
<code class="docutils literal notranslate"><span class="pre">(input1,</span> <span class="pre">length1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(input2,</span> <span class="pre">length2)</span></code>.</p>
<p>We must have <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.  Allows zero-padding
of the two input polynomials.  Supports aliasing of inputs and outputs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul_SS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul_SS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul_SS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>. Uses the
Sch&quot;{o}nhage-Strassen algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mullow_SS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mullow_SS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">output</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">input1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">length1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">input2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">length2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mullow_SS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients of the product of
<code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len1</span></code> and <code class="docutils literal notranslate"><span class="pre">len2</span></code> are positive, but does allow
for the polynomials to be zero-padded.  We must have <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>
and <code class="docutils literal notranslate"><span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>. Assumes <span class="math notranslate nohighlight">\(n\)</span> is positive. Supports aliasing between
<code class="docutils literal notranslate"><span class="pre">res</span></code>, <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mullow_SS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mullow_SS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mullow_SS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients of the product of
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mul" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.  Assumes <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  Allows
zero-padding of the two input polynomials. Does not support aliasing
between the inputs and the output.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.  Chooses
an optimal algorithm from the choices above.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mullow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mullow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mullow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients of the product of
<code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1</span></code>.
Allows for zero-padding in the inputs.  Does not support aliasing between
the inputs and the output.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mullow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mullow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mullow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients of the product of
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mulhigh_n">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mulhigh_n</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mulhigh_n" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the high <span class="math notranslate nohighlight">\(n\)</span> coefficients of <code class="docutils literal notranslate"><span class="pre">res</span></code> to the high <span class="math notranslate nohighlight">\(n\)</span> coefficients
of the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>, assuming the latter are
precisely <span class="math notranslate nohighlight">\(n\)</span> coefficients in length, zero padded if necessary.  The
remaining <span class="math notranslate nohighlight">\(n - 1\)</span> coefficients may be arbitrary.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mulhigh">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mulhigh</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mulhigh" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets all but the low <span class="math notranslate nohighlight">\(n\)</span> coefficients of <span class="math notranslate nohighlight">\(res\)</span> to the corresponding
coefficients of the product of <span class="math notranslate nohighlight">\(poly1\)</span> of length <span class="math notranslate nohighlight">\(len1\)</span> and <span class="math notranslate nohighlight">\(poly2\)</span> of
length <span class="math notranslate nohighlight">\(len2\)</span>, the remaining coefficients being arbitrary. It is assumed
that <span class="math notranslate nohighlight">\(len1 &gt;= len2 &gt; 0\)</span> and that <span class="math notranslate nohighlight">\(0 &lt; n &lt; len1 + len2 - 1\)</span>. Aliasing of
inputs is not permitted.</p>
</dd></dl>

</section>
<section id="fft-precached-multiplication">
<h2>FFT precached multiplication<a class="headerlink" href="#fft-precached-multiplication" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul_SS_precache_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul_SS_precache_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_poly_mul_precache_t</span></span><span class="w"> </span><span class="n"><span class="pre">pre</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul_SS_precache_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Precompute the FFT of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> to enable repeated multiplication of
<code class="docutils literal notranslate"><span class="pre">poly2</span></code> by polynomials whose length does not exceed <code class="docutils literal notranslate"><span class="pre">len1</span></code> and
whose number of bits per coefficient does not exceed <code class="docutils literal notranslate"><span class="pre">bits1</span></code>.</p>
<p>The value <code class="docutils literal notranslate"><span class="pre">bits1</span></code> may be negative, i.e. it may be the result of
calling <code class="docutils literal notranslate"><span class="pre">fmpz_poly_max_bits</span></code>. The function only considers the
absolute value of <code class="docutils literal notranslate"><span class="pre">bits1</span></code>.</p>
<p>Suppose <code class="docutils literal notranslate"><span class="pre">len2</span></code> is the length of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> and
<code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">=</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1</span></code> is the maximum output length of a polynomial
multiplication using <code class="docutils literal notranslate"><span class="pre">pre</span></code>. Then internally <code class="docutils literal notranslate"><span class="pre">len</span></code> is rounded up to
a power of two, <span class="math notranslate nohighlight">\(2^n\)</span> say. The truncated FFT algorithm is used to smooth
performance but note that it can only do this in the range
<span class="math notranslate nohighlight">\((2^{n-1}, 2^n]\)</span>. Therefore, it may be more efficient to recompute <span class="math notranslate nohighlight">\(pre\)</span>
for cases where the output length will fall below <span class="math notranslate nohighlight">\(2^{n-1} + 1\)</span>. Otherwise
the implementation will zero pad them up to that length.</p>
<p>Note that the Schoenhage-Strassen algorithm is only efficient for
polynomials with relatively large coefficients relative to the length of
the polynomials.</p>
<p>Also note that there are no restrictions on the polynomials. In particular
the polynomial whose FFT is being precached does not have to be either
longer or shorter than the polynomials it is to be multiplied by.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul_precache_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul_precache_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_poly_mul_precache_t</span></span><span class="w"> </span><span class="n"><span class="pre">pre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul_precache_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clear the space allocated by <code class="docutils literal notranslate"><span class="pre">fmpz_poly_mul_SS_precache_init</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_mullow_SS_precache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_mullow_SS_precache</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">output</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">input1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="n"><span class="pre">fmpz_poly_mul_precache_t</span></span><span class="w"> </span><span class="n"><span class="pre">pre</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">trunc</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_mullow_SS_precache" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write into <code class="docutils literal notranslate"><span class="pre">output</span></code> the first <code class="docutils literal notranslate"><span class="pre">trunc</span></code> coefficients of
the polynomial <code class="docutils literal notranslate"><span class="pre">(input1,</span> <span class="pre">len1)</span></code> by the polynomial whose FFT was precached
by <code class="docutils literal notranslate"><span class="pre">fmpz_poly_mul_SS_precache_init</span></code> and stored in <code class="docutils literal notranslate"><span class="pre">pre</span></code>.</p>
<p>For performance reasons it is recommended that all polynomials be truncated
to at most <code class="docutils literal notranslate"><span class="pre">trunc</span></code> coefficients if possible.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mullow_SS_precache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mullow_SS_precache</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">fmpz_poly_mul_precache_t</span></span><span class="w"> </span><span class="n"><span class="pre">pre</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mullow_SS_precache" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> by the polynomial whose FFT was
precached by <code class="docutils literal notranslate"><span class="pre">fmpz_poly_mul_SS_precache_init</span></code> (and stored in pre). The
result is truncated to <span class="math notranslate nohighlight">\(n\)</span> coefficients (and normalised).</p>
<p>There are no restrictions on the length of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> other than those given
in the call to <code class="docutils literal notranslate"><span class="pre">fmpz_poly_mul_SS_precache_init</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_mul_SS_precache">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_mul_SS_precache</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">fmpz_poly_precache_t</span></span><span class="w"> </span><span class="n"><span class="pre">pre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_mul_SS_precache" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">res</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> by the polynomial whose FFT was
precached by <code class="docutils literal notranslate"><span class="pre">fmpz_poly_mul_SS_precache_init</span></code> (and stored in pre).</p>
<p>There are no restrictions on the length of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> other than those given
in the call to <code class="docutils literal notranslate"><span class="pre">fmpz_poly_mul_SS_precache_init</span></code>.</p>
</dd></dl>

</section>
<section id="squaring">
<h2>Squaring<a class="headerlink" href="#squaring" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqr_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqr_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqr_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(rop,</span> <span class="pre">2*len</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the square of <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>,
assuming that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>Supports zero-padding in <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>.  Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqr_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqr_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqr_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">rop</span></code> to the square of the polynomial <code class="docutils literal notranslate"><span class="pre">op</span></code> using
Kronecker segmentation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqr_karatsuba">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqr_karatsuba</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqr_karatsuba" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(rop,</span> <span class="pre">2*len</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the square of <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>,
assuming that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>Supports zero-padding in <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>.  Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqr_karatsuba">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqr_karatsuba</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqr_karatsuba" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">rop</span></code> to the square of the polynomial <code class="docutils literal notranslate"><span class="pre">op</span></code> using
the Karatsuba multiplication algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqr_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqr_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqr_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(rop,</span> <span class="pre">2*len</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the square of <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>,
assuming that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>Supports zero-padding in <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>.  Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqr_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqr_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqr_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">rop</span></code> to the square of the polynomial <code class="docutils literal notranslate"><span class="pre">op</span></code> using
the classical or schoolbook method.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">op</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(rop,</span> <span class="pre">2*len</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the square of <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>,
assuming that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>Supports zero-padding in <code class="docutils literal notranslate"><span class="pre">(op,</span> <span class="pre">len)</span></code>.  Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqr">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqr</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rop</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">op</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqr" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">rop</span></code> to the square of the polynomial <code class="docutils literal notranslate"><span class="pre">op</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrlow_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrlow_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrlow_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients
of the square of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len</span></code> is positive, but does allow for the polynomial
to be zero-padded.  The polynomial may be zero, too.  Assumes <span class="math notranslate nohighlight">\(n\)</span> is
positive.  Supports aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrlow_KS">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrlow_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrlow_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients
of the square of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrlow_karatsuba_n">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrlow_karatsuba_n</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrlow_karatsuba_n" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the square of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code> truncated
to length <span class="math notranslate nohighlight">\(n\)</span>, which is assumed to be positive.  Allows for <code class="docutils literal notranslate"><span class="pre">poly</span></code>
to be zero-oadded.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrlow_karatsuba_n">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrlow_karatsuba_n</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrlow_karatsuba_n" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the square of <code class="docutils literal notranslate"><span class="pre">poly</span></code> and
truncates to the given length.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrlow_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrlow_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrlow_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the first <span class="math notranslate nohighlight">\(n\)</span> coefficients of the square
of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">len</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrlow_classical">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrlow_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrlow_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the first <span class="math notranslate nohighlight">\(n\)</span> coefficients of
the square of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrlow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrlow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrlow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients
of the square of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.</p>
<p>Assumes <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;</span> <span class="pre">n</span> <span class="pre">&lt;=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">len</span> <span class="pre">-</span> <span class="pre">1</span></code>.
Allows for zero-padding in the input.  Does not support aliasing
between the input and the output.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrlow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrlow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrlow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the lowest <span class="math notranslate nohighlight">\(n\)</span> coefficients
of the square of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

</section>
<section id="powering">
<h2>Powering<a class="headerlink" href="#powering" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pow_multinomial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pow_multinomial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pow_multinomial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code>.  This uses the J.C.P. Miller pure
recurrence as follows:</p>
<p>If <span class="math notranslate nohighlight">\(\ell\)</span> is the index of the lowest non-zero coefficient in <code class="docutils literal notranslate"><span class="pre">poly</span></code>,
as a first step this method zeros out the lowest <span class="math notranslate nohighlight">\(e \ell\)</span> coefficients of
<code class="docutils literal notranslate"><span class="pre">res</span></code>.  The recurrence above is then used to compute the remaining
coefficients.</p>
<p>Assumes <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pow_multinomial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pow_multinomial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pow_multinomial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code> using a generalisation of binomial expansion
called the J.C.P. Miller pure recurrence [1], [2].
If <span class="math notranslate nohighlight">\(e\)</span> is zero, returns one, so that in particular <code class="docutils literal notranslate"><span class="pre">0^0</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
<p>The formal statement of the recurrence is as follows.  Write the input
polynomial as <span class="math notranslate nohighlight">\(P(x) = p_0 + p_1 x + \dotsb + p_m x^m\)</span> with <span class="math notranslate nohighlight">\(p_0 \neq 0\)</span>
and let</p>
<div class="math notranslate nohighlight">
\[P(x)^n = a(n, 0) + a(n, 1) x + \dotsb + a(n, mn) x^{mn}.\]</div>
<p>Then <span class="math notranslate nohighlight">\(a(n, 0) = p_0^n\)</span> and, for all <span class="math notranslate nohighlight">\(1 \leq k \leq mn\)</span>,</p>
<div class="math notranslate nohighlight">
\[a(n, k) =
    (k p_0)^{-1} \sum_{i = 1}^m p_i \bigl( (n + 1) i - k \bigr) a(n, k-i).\]</div>
<p>[1] D. Knuth, The Art of Computer Programming Vol. 2, Seminumerical
Algorithms, Third Edition (Reading, Massachusetts: Addison-Wesley, 1997)</p>
<p>[2] D. Zeilberger, The J.C.P. Miller Recurrence for Exponentiating a
Polynomial, and its q-Analog, Journal of Difference Equations and
Applications, 1995, Vol. 1, pp. 57–60</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pow_binomial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pow_binomial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pow_binomial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code> when poly is of length 2, using binomial
expansion.</p>
<p>Assumes <span class="math notranslate nohighlight">\(e &gt; 0\)</span>.  Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pow_binomial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pow_binomial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pow_binomial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code> when <code class="docutils literal notranslate"><span class="pre">poly</span></code> is of length <span class="math notranslate nohighlight">\(2\)</span>, using
binomial expansion.</p>
<p>If the length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> is not <span class="math notranslate nohighlight">\(2\)</span>, raises an exception and aborts.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pow_addchains">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pow_addchains</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pow_addchains" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a star chain <span class="math notranslate nohighlight">\(1 = a_0 &lt; a_1 &lt; \dotsb &lt; a_n = e\)</span> computes
<code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code>.</p>
<p>A star chain is an addition chain <span class="math notranslate nohighlight">\(1 = a_0 &lt; a_1 &lt; \dotsb &lt; a_n\)</span> such
that, for all <span class="math notranslate nohighlight">\(i &gt; 0\)</span>, <span class="math notranslate nohighlight">\(a_i = a_{i-1} + a_j\)</span> for some <span class="math notranslate nohighlight">\(j &lt; i\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(e &gt; 2\)</span>, or equivalently <span class="math notranslate nohighlight">\(n &gt; 1\)</span>, and <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  Does
not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pow_addchains">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pow_addchains</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pow_addchains" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code> using addition chains whenever
<span class="math notranslate nohighlight">\(0 \leq e \leq 148\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(e &gt; 148\)</span>, raises an exception and aborts.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pow_binexp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pow_binexp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pow_binexp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code> using left-to-right binary exponentiation as
described in [p. 461][Knu1997]_.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.  Assumes that <code class="docutils literal notranslate"><span class="pre">res</span></code> is
an array of length at least <code class="docutils literal notranslate"><span class="pre">e*(len</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">1</span></code>.  Does not support
aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pow_binexp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pow_binexp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pow_binexp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code> using the binary exponentiation algorithm.
If <span class="math notranslate nohighlight">\(e\)</span> is zero, returns one, so that in particular <code class="docutils literal notranslate"><span class="pre">0^0</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pow_small">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pow_small</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pow_small" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code> whenever <span class="math notranslate nohighlight">\(0 \leq e \leq 4\)</span>.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and that <code class="docutils literal notranslate"><span class="pre">res</span></code> is an array of length
at least <code class="docutils literal notranslate"><span class="pre">e*(len</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">1</span></code>.  Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code>, assuming that <code class="docutils literal notranslate"><span class="pre">e,</span> <span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> and that
<code class="docutils literal notranslate"><span class="pre">res</span></code> has space for <code class="docutils literal notranslate"><span class="pre">e*(len</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">1</span></code> coefficients.  Does
not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pow">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pow</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">res</span> <span class="pre">=</span> <span class="pre">poly^e</span></code>.  If <span class="math notranslate nohighlight">\(e\)</span> is zero, returns one,
so that in particular <code class="docutils literal notranslate"><span class="pre">0^0</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pow_trunc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pow_trunc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pow_trunc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code> raised to the power <span class="math notranslate nohighlight">\(e\)</span> and
truncated to length <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(e, n &gt; 0\)</span>.  Allows zero-padding of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code>.
Does not support aliasing of any inputs and outputs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pow_trunc">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pow_trunc</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">e</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pow_trunc" title="Link to this definition">¶</a><br /></dt>
<dd><p>Notationally raises <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the power <span class="math notranslate nohighlight">\(e\)</span>, truncates the result
to length <span class="math notranslate nohighlight">\(n\)</span> and writes the result in <code class="docutils literal notranslate"><span class="pre">res</span></code>.  This is computed
much more efficiently than simply powering the polynomial and truncating.</p>
<p>Thus, if <span class="math notranslate nohighlight">\(n = 0\)</span> the result is zero.  Otherwise, whenever <span class="math notranslate nohighlight">\(e = 0\)</span> the
result will be the constant polynomial equal to <span class="math notranslate nohighlight">\(1\)</span>.</p>
<p>This function can be used to raise power series to a power in an
efficient way.</p>
</dd></dl>

</section>
<section id="shifting">
<h2>Shifting<a class="headerlink" href="#shifting" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_shift_left">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_shift_left</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_shift_left" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len</span> <span class="pre">+</span> <span class="pre">n)</span></code> to <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> shifted left by
<span class="math notranslate nohighlight">\(n\)</span> coefficients.</p>
<p>Inserts zero coefficients at the lower end.  Assumes that <code class="docutils literal notranslate"><span class="pre">len</span></code>
and <span class="math notranslate nohighlight">\(n\)</span> are positive, and that <code class="docutils literal notranslate"><span class="pre">res</span></code> fits <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">+</span> <span class="pre">n</span></code> elements.
Supports aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_shift_left">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_shift_left</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_shift_left" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">poly</span></code> shifted left by <span class="math notranslate nohighlight">\(n\)</span> coeffs.  Zero
coefficients are inserted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_shift_right">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_shift_right</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_shift_right" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len</span> <span class="pre">-</span> <span class="pre">n)</span></code> to <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> shifted right by
<span class="math notranslate nohighlight">\(n\)</span> coefficients.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len</span></code> and <span class="math notranslate nohighlight">\(n\)</span> are positive, that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">n</span></code>,
and that <code class="docutils literal notranslate"><span class="pre">res</span></code> fits <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">-</span> <span class="pre">n</span></code> elements.  Supports aliasing
between <code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">poly</span></code>, although in this case the top
coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code> are not set to zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_shift_right">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_shift_right</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_shift_right" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">poly</span></code> shifted right by <span class="math notranslate nohighlight">\(n\)</span> coefficients.  If <span class="math notranslate nohighlight">\(n\)</span>
is equal to or greater than the current length of <code class="docutils literal notranslate"><span class="pre">poly</span></code>, <code class="docutils literal notranslate"><span class="pre">res</span></code>
is set to the zero polynomial.</p>
</dd></dl>

</section>
<section id="bit-sizes-and-norms">
<h2>Bit sizes and norms<a class="headerlink" href="#bit-sizes-and-norms" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_max_limbs">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_max_limbs</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_max_limbs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the maximum number of limbs required to store the absolute value
of coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.  If <code class="docutils literal notranslate"><span class="pre">poly</span></code> is zero, returns <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_max_bits">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_max_bits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_max_bits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the maximum number of bits <span class="math notranslate nohighlight">\(b\)</span> required to store the absolute
value of coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.  If all the coefficients of
<code class="docutils literal notranslate"><span class="pre">poly</span></code> are non-negative, <span class="math notranslate nohighlight">\(b\)</span> is returned, otherwise <span class="math notranslate nohighlight">\(-b\)</span> is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_height">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_height</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">height</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_height" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the height of <code class="docutils literal notranslate"><span class="pre">poly</span></code>, defined as the largest of the
absolute values the coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>. Equivalently, this
gives the infinity norm of the coefficients. If <code class="docutils literal notranslate"><span class="pre">poly</span></code> is zero,
the height is <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_2norm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_2norm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_2norm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the Euclidean norm of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>, that is,
the integer square root of the sum of the squares of the coefficients
of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_2norm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_2norm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_2norm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the Euclidean norm of <code class="docutils literal notranslate"><span class="pre">poly</span></code>, that is, the
integer square root of the sum of the squares of the coefficients of
<code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_2norm_normalised_bits">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_2norm_normalised_bits</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_2norm_normalised_bits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns an upper bound on the number of bits of the normalised
Euclidean norm of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>, i.e. the number of bits of
the Euclidean norm divided by the absolute value of the leading
coefficient. The returned value will be no more than 1 bit too
large.</p>
<p>This is used in the computation of the Landau-Mignotte bound.</p>
<p>It is assumed that <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. The result only makes sense
if the leading coefficient is nonzero.</p>
</dd></dl>

</section>
<section id="greatest-common-divisor">
<h2>Greatest common divisor<a class="headerlink" href="#greatest-common-divisor" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_gcd_subresultant">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_gcd_subresultant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_gcd_subresultant" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len2)</span></code> of
<code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, assuming
<code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  The result is normalised to have
positive leading coefficient.  Aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code>,
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_gcd_subresultant">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_gcd_subresultant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_gcd_subresultant" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">res</span></code> of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and
<code class="docutils literal notranslate"><span class="pre">poly2</span></code>, normalised to have non-negative leading coefficient.</p>
<p>This function uses the subresultant algorithm as described
in [Algorithm 3.3.1][Coh1996]_.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_gcd_heuristic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_gcd_heuristic</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_gcd_heuristic" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len2)</span></code> of
<code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, assuming
<code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  The result is normalised to have
positive leading coefficient.  Aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code>,
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is not supported. The function
may not always succeed in finding the GCD. If it fails, the
function returns 0, otherwise it returns 1.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_gcd_heuristic">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_gcd_heuristic</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_gcd_heuristic" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">res</span></code> of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and
<code class="docutils literal notranslate"><span class="pre">poly2</span></code>, normalised to have non-negative leading coefficient.</p>
<p>The function may not always succeed in finding the GCD. If it fails,
the function returns 0, otherwise it returns 1.</p>
<p>This function uses the heuristic GCD algorithm (GCDHEU). The basic
strategy is to remove the content of the polynomials, pack them
using Kronecker segmentation (given a bound on the size of the
coefficients of the GCD) and take the integer GCD. Unpack the
result and test divisibility.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_gcd_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_gcd_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_gcd_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len2)</span></code> of
<code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, assuming
<code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  The result is normalised to have
positive leading coefficient.  Aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code>,
<code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_gcd_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_gcd_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_gcd_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">res</span></code> of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and
<code class="docutils literal notranslate"><span class="pre">poly2</span></code>, normalised to have non-negative leading coefficient.</p>
<p>This function uses the modular GCD algorithm. The basic
strategy is to remove the content of the polynomials, reduce them
modulo sufficiently many primes and do CRT reconstruction until
some bound is reached (or we can prove with trial division that
we have the GCD).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_gcd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_gcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_gcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">res</span></code> of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code>
and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, assuming <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  The result
is normalised to have positive leading coefficient.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">res</span></code> has space for <code class="docutils literal notranslate"><span class="pre">len2</span></code> coefficients.
Aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code>, <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is not
supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_gcd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_gcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_gcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the greatest common divisor <code class="docutils literal notranslate"><span class="pre">res</span></code> of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and
<code class="docutils literal notranslate"><span class="pre">poly2</span></code>, normalised to have non-negative leading coefficient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_xgcd_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_xgcd_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_xgcd_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(r\)</span> to the resultant of <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(g,</span> <span class="pre">len2)</span></code>.
If the resultant is zero, the function returns immediately. Otherwise it
finds polynomials <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> such that <code class="docutils literal notranslate"><span class="pre">s*f</span> <span class="pre">+</span> <span class="pre">t*g</span> <span class="pre">=</span> <span class="pre">r</span></code>. The length
of <span class="math notranslate nohighlight">\(s\)</span> will be no greater than <code class="docutils literal notranslate"><span class="pre">len2</span></code> and the length of <span class="math notranslate nohighlight">\(t\)</span> will be
no greater than <code class="docutils literal notranslate"><span class="pre">len1</span></code> (both are zero padded if necessary).</p>
<p>It is assumed that <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. No aliasing of inputs and
outputs is permitted.</p>
<p>The function assumes that <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are primitive (have Gaussian content
equal to 1). The result is undefined otherwise.</p>
<p>Uses a multimodular algorithm. The resultant is first computed and
extended GCD’s modulo various primes <span class="math notranslate nohighlight">\(p\)</span> are computed and combined using
CRT. When the CRT stabilises the resulting polynomials are simply reduced
modulo further primes until a proven bound is reached.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_xgcd_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_xgcd_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">t</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_xgcd_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(r\)</span> to the resultant of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>. If the resultant is zero, the
function then returns immediately, otherwise <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are found such
that <code class="docutils literal notranslate"><span class="pre">s*f</span> <span class="pre">+</span> <span class="pre">t*g</span> <span class="pre">=</span> <span class="pre">r</span></code>.</p>
<p>The function assumes that <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are primitive (have Gaussian content
equal to 1). The result is undefined otherwise.</p>
<p>Uses the multimodular algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_xgcd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_xgcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">g</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_xgcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(r\)</span> to the resultant of <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(g,</span> <span class="pre">len2)</span></code>.
If the resultant is zero, the function returns immediately. Otherwise it
finds polynomials <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> such that <code class="docutils literal notranslate"><span class="pre">s*f</span> <span class="pre">+</span> <span class="pre">t*g</span> <span class="pre">=</span> <span class="pre">r</span></code>. The length
of <span class="math notranslate nohighlight">\(s\)</span> will be no greater than <code class="docutils literal notranslate"><span class="pre">len2</span></code> and the length of <span class="math notranslate nohighlight">\(t\)</span> will be
no greater than <code class="docutils literal notranslate"><span class="pre">len1</span></code> (both are zero padded if necessary).</p>
<p>The function assumes that <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are primitive (have Gaussian content
equal to 1). The result is undefined otherwise.</p>
<p>It is assumed that <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. No aliasing of inputs and
outputs is permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_xgcd">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_xgcd</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">s</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">t</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_xgcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(r\)</span> to the resultant of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span>. If the resultant is zero, the
function then returns immediately, otherwise <span class="math notranslate nohighlight">\(s\)</span> and <span class="math notranslate nohighlight">\(t\)</span> are found such
that <code class="docutils literal notranslate"><span class="pre">s*f</span> <span class="pre">+</span> <span class="pre">t*g</span> <span class="pre">=</span> <span class="pre">r</span></code>.</p>
<p>The function assumes that <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(g\)</span> are primitive (have Gaussian content
equal to 1). The result is undefined otherwise.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_lcm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_lcm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_lcm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len1</span> <span class="pre">+</span> <span class="pre">len2</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the least common multiple
of the two polynomials <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>,
normalised to have non-negative leading coefficient.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
<p>Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_lcm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_lcm</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_lcm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the least common multiple of the two
polynomials <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>, normalised to
have non-negative leading coefficient.</p>
<p>If either of the two polynomials is zero, sets <code class="docutils literal notranslate"><span class="pre">res</span></code>
to zero.</p>
<p>This ensures that the equality</p>
<div class="math notranslate nohighlight">
\[f g = \gcd(f, g) \operatorname{lcm}(f, g)\]</div>
<p>holds up to sign.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_resultant_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_resultant_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_resultant_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the resultant of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, assuming that <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_resultant_modular">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_resultant_modular</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_resultant_modular" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the resultant of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
<p>For two non-zero polynomials <span class="math notranslate nohighlight">\(f(x) = a_m x^m + \dotsb + a_0\)</span> and
<span class="math notranslate nohighlight">\(g(x) = b_n x^n + \dotsb + b_0\)</span> of degrees <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>, the resultant
is defined to be</p>
<div class="math notranslate nohighlight">
\[a_m^n b_n^m \prod_{(x, y) : f(x) = g(y) = 0} (x - y).\]</div>
<p>For convenience, we define the resultant to be equal to zero if either
of the two polynomials is zero.</p>
<p>This function uses the modular algorithm described
in <a class="reference internal" href="references.html#col1971" id="id1"><span>[Col1971]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_resultant_modular_div">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_resultant_modular_div</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">div</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">nbits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_resultant_modular_div" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the resultant of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> divided by
<code class="docutils literal notranslate"><span class="pre">div</span></code> using a slight modification of the above function. It is assumed that
the resultant is exactly divisible by <code class="docutils literal notranslate"><span class="pre">div</span></code> and the result <code class="docutils literal notranslate"><span class="pre">res</span></code>
has at most <code class="docutils literal notranslate"><span class="pre">nbits</span></code> bits.
This bypasses the computation of general bounds.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_resultant_euclidean">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_resultant_euclidean</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_resultant_euclidean" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the resultant of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, assuming that <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_resultant_euclidean">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_resultant_euclidean</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_resultant_euclidean" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the resultant of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
<p>For two non-zero polynomials <span class="math notranslate nohighlight">\(f(x) = a_m x^m + \dotsb + a_0\)</span> and
<span class="math notranslate nohighlight">\(g(x) = b_n x^n + \dotsb + b_0\)</span> of degrees <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>, the resultant
is defined to be</p>
<div class="math notranslate nohighlight">
\[a_m^n b_n^m \prod_{(x, y) : f(x) = g(y) = 0} (x - y).\]</div>
<p>For convenience, we define the resultant to be equal to zero if either
of the two polynomials is zero.</p>
<p>This function uses the algorithm described
in [Algorithm 3.3.7][Coh1996]_.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_resultant">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_resultant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_resultant" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the resultant of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>, assuming that <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">&gt;=</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_resultant">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_resultant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_resultant" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the resultant of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.</p>
<p>For two non-zero polynomials <span class="math notranslate nohighlight">\(f(x) = a_m x^m + \dotsb + a_0\)</span> and
<span class="math notranslate nohighlight">\(g(x) = b_n x^n + \dotsb + b_0\)</span> of degrees <span class="math notranslate nohighlight">\(m\)</span> and <span class="math notranslate nohighlight">\(n\)</span>, the resultant
is defined to be</p>
<div class="math notranslate nohighlight">
\[a_m^n b_n^m \prod_{(x, y) : f(x) = g(y) = 0} (x - y).\]</div>
<p>For convenience, we define the resultant to be equal to zero if either
of the two polynomials is zero.</p>
</dd></dl>

</section>
<section id="discriminant">
<h2>Discriminant<a class="headerlink" href="#discriminant" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_discriminant">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_discriminant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_discriminant" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">res</span></code> to the discriminant of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>. Assumes
<code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_discriminant">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_discriminant</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_discriminant" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">res</span></code> to the discriminant of <code class="docutils literal notranslate"><span class="pre">poly</span></code>. We normalise the
discriminant so that <span class="math notranslate nohighlight">\(\operatorname{disc}(f) = (-1)^{(n(n-1)/2)}
\operatorname{res}(f, f')/\operatorname{lc}(f)\)</span>, thus
<span class="math notranslate nohighlight">\(\operatorname{disc}(f) = \operatorname{lc}(f)^{(2n - 2)} \prod_{i &lt; j} (r_i
- r_j)^2\)</span>, where <span class="math notranslate nohighlight">\(\operatorname{lc}(f)\)</span> is the leading coefficient of <span class="math notranslate nohighlight">\(f\)</span>,
<span class="math notranslate nohighlight">\(n\)</span> is the degree of <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(r_i\)</span> are the roots of <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

</section>
<section id="gaussian-content">
<h2>Gaussian content<a class="headerlink" href="#gaussian-content" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_content">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_content</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_content" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the non-negative content of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.
Aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code> and the coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code> is
not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_content">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_content</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_content" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the non-negative content of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.  The content
of the zero polynomial is defined to be zero.  Supports aliasing, that is,
<code class="docutils literal notranslate"><span class="pre">res</span></code> is allowed to be one of the coefficients of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_primitive_part">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_primitive_part</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_primitive_part" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len)</span></code> to <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> divided by the content
of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>, and normalises the result to have non-negative
leading coefficient.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> is non-zero.  Supports aliasing of
<code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_primitive_part">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_primitive_part</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_primitive_part" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">poly</span></code> divided by the content of <code class="docutils literal notranslate"><span class="pre">poly</span></code>,
and normalises the result to have non-negative leading coefficient.
If <code class="docutils literal notranslate"><span class="pre">poly</span></code> is zero, sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to zero.</p>
</dd></dl>

</section>
<section id="square-free">
<h2>Square-free<a class="headerlink" href="#square-free" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_is_squarefree">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_is_squarefree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_is_squarefree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns whether the polynomial <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> is square-free.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_is_squarefree">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_is_squarefree</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_is_squarefree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns whether the polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code> is square-free.  A non-zero
polynomial is defined to be square-free if it has no non-unit square
factors.  We also define the zero polynomial to be square-free.</p>
<p>Returns <span class="math notranslate nohighlight">\(1\)</span> if the length of <code class="docutils literal notranslate"><span class="pre">poly</span></code> is at most <span class="math notranslate nohighlight">\(2\)</span>.  Returns whether
the discriminant is zero for quadratic polynomials.  Otherwise, returns
whether the greatest common divisor of <code class="docutils literal notranslate"><span class="pre">poly</span></code> and its derivative has
length <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

</section>
<section id="euclidean-division">
<h2>Euclidean division<a class="headerlink" href="#euclidean-division" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_divrem_basecase">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_divrem_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_divrem_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> such that
<span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <code class="docutils literal notranslate"><span class="pre">lenB</span></code> is reduced
modulo the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>.
If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact,
this is the same thing as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(\operatorname{len}(A), \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  <span class="math notranslate nohighlight">\(R\)</span> and <span class="math notranslate nohighlight">\(A\)</span> may be aliased, but apart from this no
aliasing of input and output operands is allowed.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_divrem_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_divrem_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_divrem_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each coefficient of <span class="math notranslate nohighlight">\(R\)</span>
beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>.
If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact,
this is the same thing as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  An exception is raised
if <span class="math notranslate nohighlight">\(B\)</span> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_divrem_divconquer_recursive">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_divrem_divconquer_recursive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">BQ</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">W</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_divrem_divconquer_recursive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenB)</span></code>, <code class="docutils literal notranslate"><span class="pre">(BQ,</span> <span class="pre">2</span> <span class="pre">lenB</span> <span class="pre">-</span> <span class="pre">1)</span></code> such that
<span class="math notranslate nohighlight">\(BQ = B \times Q\)</span> and <span class="math notranslate nohighlight">\(A = B Q + R\)</span> where each coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond
<span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  We
assume that <span class="math notranslate nohighlight">\(\operatorname{len}(A) = 2 \operatorname{len}(B) - 1\)</span>.  If the leading coefficient
of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact, this is the same as division
over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes <span class="math notranslate nohighlight">\(\operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  Requires
a temporary array <code class="docutils literal notranslate"><span class="pre">(W,</span> <span class="pre">2</span> <span class="pre">lenB</span> <span class="pre">-</span> <span class="pre">1)</span></code>.  No aliasing of input and output
operands is allowed.</p>
<p>This function does not read the bottom <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> coefficients from
<span class="math notranslate nohighlight">\(A\)</span>, which means that they might not even need to exist in allocated
memory.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_divrem_divconquer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_divrem_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_divrem_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> such that
<span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is
reduced modulo the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact, this is
the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  No aliasing of input and output operands is
allowed.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_divrem_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_divrem_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_divrem_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each coefficient of <span class="math notranslate nohighlight">\(R\)</span>
beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>.
If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact,
this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  An exception is raised if <span class="math notranslate nohighlight">\(B\)</span>
is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_divrem">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_divrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_divrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> such that
<span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is
reduced modulo the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact, this is
the same thing as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  No aliasing of input and output operands is
allowed.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_divrem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_divrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_divrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each coefficient of <span class="math notranslate nohighlight">\(R\)</span>
beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>.
If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact,
this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  An exception is raised if <span class="math notranslate nohighlight">\(B\)</span>
is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_basecase">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>
divided by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact,
this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes <span class="math notranslate nohighlight">\(\operatorname{len}(A), \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.
Requires a temporary array <span class="math notranslate nohighlight">\(R\)</span> of size at least the (actual) length
of <span class="math notranslate nohighlight">\(A\)</span>. For convenience, <span class="math notranslate nohighlight">\(R\)</span> may be <code class="docutils literal notranslate"><span class="pre">NULL</span></code>.  <span class="math notranslate nohighlight">\(R\)</span> and <span class="math notranslate nohighlight">\(A\)</span> may be
aliased, but apart from this no aliasing of input and output operands
is allowed.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <span class="math notranslate nohighlight">\(Q\)</span> of <span class="math notranslate nohighlight">\(A\)</span> divided by <span class="math notranslate nohighlight">\(Q\)</span>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact,
this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  An exception is raised if <span class="math notranslate nohighlight">\(B\)</span>
is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_divremlow_divconquer_recursive">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_divremlow_divconquer_recursive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">BQ</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_divremlow_divconquer_recursive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Divide and conquer division of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">2</span> <span class="pre">lenB</span> <span class="pre">-</span> <span class="pre">1)</span></code> by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code>,
computing only the bottom <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> coefficients of <span class="math notranslate nohighlight">\(B Q\)</span>.</p>
<p>Assumes <span class="math notranslate nohighlight">\(\operatorname{len}(B) &gt; 0\)</span>.  Requires <span class="math notranslate nohighlight">\(B Q\)</span> to have length at least
<span class="math notranslate nohighlight">\(2 \operatorname{len}(B) - 1\)</span>, although only the bottom <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> coefficients will
carry meaningful output.  Does not support any aliasing.  Allows
zero-padding in <span class="math notranslate nohighlight">\(A\)</span>, but not in <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_divconquer_recursive">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_divconquer_recursive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_divconquer_recursive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Recursive short division in the balanced case.</p>
<p>Computes the quotient <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenB)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">2</span> <span class="pre">lenB</span> <span class="pre">-</span> <span class="pre">1)</span></code> upon
division by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code>.  Requires <span class="math notranslate nohighlight">\(\operatorname{len}(B) &gt; 0\)</span>.  Needs a
temporary array <code class="docutils literal notranslate"><span class="pre">temp</span></code> of length <span class="math notranslate nohighlight">\(2 \operatorname{len}(B) - 1\)</span>.  Does not support
any aliasing.</p>
<p>For further details, see <a class="reference internal" href="references.html#mul2000" id="id2"><span>[Mul2000]</span></a>.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_divconquer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>
upon division by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code>.  Assumes that
<span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Does not support aliasing.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <span class="math notranslate nohighlight">\(Q\)</span> of <span class="math notranslate nohighlight">\(A\)</span> divided by <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or the division is exact,
this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  An exception is raised if <span class="math notranslate nohighlight">\(B\)</span>
is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>
divided by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or
the division is exact, this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  Aliasing of input and output operands is not
allowed.</p>
<p>If the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, the function stops if an inexact division
is encountered, upon which the function will return <span class="math notranslate nohighlight">\(0\)</span>. If no inexact
division is encountered, the function returns <span class="math notranslate nohighlight">\(1\)</span>. Note that this does not
guarantee the remainder of the polynomial division is zero, merely that
its length is less than that of B. This feature is useful for series
division and for divisibility testing (upon testing the remainder).</p>
<p>For ordinary use set the flag <code class="docutils literal notranslate"><span class="pre">exact</span></code> to <span class="math notranslate nohighlight">\(0\)</span>. In this case, no checks
or early aborts occur and the function always returns <span class="math notranslate nohighlight">\(1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <span class="math notranslate nohighlight">\(Q\)</span> of <span class="math notranslate nohighlight">\(A\)</span> divided by <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or
the division is exact, this is the same as division over <span class="math notranslate nohighlight">\(Q\)</span>.  An
exception is raised if <span class="math notranslate nohighlight">\(B\)</span> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_rem_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_rem_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_rem_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the remainder <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code> upon
division by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or
the division is exact, this is the same thing as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(\operatorname{len}(A), \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  <span class="math notranslate nohighlight">\(R\)</span> and <span class="math notranslate nohighlight">\(A\)</span> may be aliased, but apart from this no
aliasing of input and output operands is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_rem_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_rem_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_rem_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the remainder <span class="math notranslate nohighlight">\(R\)</span> of <span class="math notranslate nohighlight">\(A\)</span> upon division by <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or
the division is exact, this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  An
exception is raised if <span class="math notranslate nohighlight">\(B\)</span> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_rem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_rem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_rem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the remainder <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code> upon division
by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or
the division is exact, this is the same thing as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  Aliasing of input and output operands is not allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_rem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_rem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_rem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the remainder <span class="math notranslate nohighlight">\(R\)</span> of <span class="math notranslate nohighlight">\(A\)</span> upon division by <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p>Notationally, computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(A = B Q + R\)</span> and each
coefficient of <span class="math notranslate nohighlight">\(R\)</span> beyond <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> is reduced modulo the leading
coefficient of <span class="math notranslate nohighlight">\(B\)</span>.  If the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> is <span class="math notranslate nohighlight">\(\pm 1\)</span> or
the division is exact, this is the same as division over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  An
exception is raised if <span class="math notranslate nohighlight">\(B\)</span> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_root">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_root</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_root" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">len-1)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">len)</span></code> upon
division by <span class="math notranslate nohighlight">\(x - c\)</span>.</p>
<p>Supports aliasing of <code class="docutils literal notranslate"><span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>, but the result is
undefined in case of partial overlap.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div_root">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div_root</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div_root" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the quotient <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">len-1)</span></code> of <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">len)</span></code> upon
division by <span class="math notranslate nohighlight">\(x - c\)</span>.</p>
</dd></dl>

</section>
<section id="division-with-precomputed-inverse">
<h2>Division with precomputed inverse<a class="headerlink" href="#division-with-precomputed-inverse" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_preinvert">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_preinvert</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B_inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_preinvert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a monic polynomial <code class="docutils literal notranslate"><span class="pre">B</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code>, compute a precomputed
inverse <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> of length <code class="docutils literal notranslate"><span class="pre">n</span></code> for use in the functions below. No
aliasing of <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> is permitted. We assume <code class="docutils literal notranslate"><span class="pre">n</span></code> is not zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_preinvert">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_preinvert</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B_inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_preinvert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a monic polynomial <code class="docutils literal notranslate"><span class="pre">B</span></code>, compute a precomputed inverse
<code class="docutils literal notranslate"><span class="pre">B_inv</span></code> for use in the functions below. An exception is raised if
<code class="docutils literal notranslate"><span class="pre">B</span></code> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_preinv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B_inv</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a precomputed inverse <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> of the polynomial <code class="docutils literal notranslate"><span class="pre">B</span></code> of
length <code class="docutils literal notranslate"><span class="pre">len2</span></code>, compute the quotient <code class="docutils literal notranslate"><span class="pre">Q</span></code> of <code class="docutils literal notranslate"><span class="pre">A</span></code> by <code class="docutils literal notranslate"><span class="pre">B</span></code>.
We assume the length <code class="docutils literal notranslate"><span class="pre">len1</span></code> of <code class="docutils literal notranslate"><span class="pre">A</span></code> is at least <code class="docutils literal notranslate"><span class="pre">len2</span></code>. The
polynomial <code class="docutils literal notranslate"><span class="pre">Q</span></code> must have space for <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">-</span> <span class="pre">len2</span> <span class="pre">+</span> <span class="pre">1</span></code>
coefficients. No aliasing of operands is permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div_preinv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B_inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a precomputed inverse <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> of the polynomial <code class="docutils literal notranslate"><span class="pre">B</span></code>,
compute the quotient <code class="docutils literal notranslate"><span class="pre">Q</span></code> of <code class="docutils literal notranslate"><span class="pre">A</span></code> by <code class="docutils literal notranslate"><span class="pre">B</span></code>. Aliasing of <code class="docutils literal notranslate"><span class="pre">B</span></code>
and <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> is not permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_divrem_preinv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_divrem_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B_inv</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_divrem_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a precomputed inverse <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> of the polynomial <code class="docutils literal notranslate"><span class="pre">B</span></code> of
length <code class="docutils literal notranslate"><span class="pre">len2</span></code>, compute the quotient <code class="docutils literal notranslate"><span class="pre">Q</span></code> of <code class="docutils literal notranslate"><span class="pre">A</span></code> by <code class="docutils literal notranslate"><span class="pre">B</span></code>.
The remainder is then placed in <code class="docutils literal notranslate"><span class="pre">A</span></code>. We assume the length <code class="docutils literal notranslate"><span class="pre">len1</span></code>
of <code class="docutils literal notranslate"><span class="pre">A</span></code> is at least <code class="docutils literal notranslate"><span class="pre">len2</span></code>. The polynomial <code class="docutils literal notranslate"><span class="pre">Q</span></code> must have
space for <code class="docutils literal notranslate"><span class="pre">len1</span> <span class="pre">-</span> <span class="pre">len2</span> <span class="pre">+</span> <span class="pre">1</span></code> coefficients. No aliasing of operands is
permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_divrem_preinv">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_divrem_preinv</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B_inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_divrem_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a precomputed inverse <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> of the polynomial <code class="docutils literal notranslate"><span class="pre">B</span></code>,
compute the quotient <code class="docutils literal notranslate"><span class="pre">Q</span></code> of <code class="docutils literal notranslate"><span class="pre">A</span></code> by <code class="docutils literal notranslate"><span class="pre">B</span></code> and the remainder
<code class="docutils literal notranslate"><span class="pre">R</span></code>. Aliasing of <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">B_inv</span></code> is not permitted.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_powers_precompute">
<a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_powers_precompute</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_powers_precompute" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">2*len</span> <span class="pre">-</span> <span class="pre">1</span></code> powers of <span class="math notranslate nohighlight">\(x\)</span> modulo the polynomial <span class="math notranslate nohighlight">\(B\)</span> of
the given length. This is used as a kind of precomputed inverse in
the remainder routine below.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_powers_precompute">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_powers_precompute</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_poly_powers_precomp_t</span></span><span class="w"> </span><span class="n"><span class="pre">pinv</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_powers_precompute" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">2*len</span> <span class="pre">-</span> <span class="pre">1</span></code> powers of <span class="math notranslate nohighlight">\(x\)</span> modulo the polynomial <span class="math notranslate nohighlight">\(B\)</span> of
the given length. This is used as a kind of precomputed inverse in
the remainder routine below.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_powers_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_powers_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">powers</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_powers_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clean up resources used by precomputed powers which have been computed
by <code class="docutils literal notranslate"><span class="pre">_fmpz_poly_powers_precompute</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_powers_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_powers_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">fmpz_poly_powers_precomp_t</span></span><span class="w"> </span><span class="n"><span class="pre">pinv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_powers_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clean up resources used by precomputed powers which have been computed
by <code class="docutils literal notranslate"><span class="pre">fmpz_poly_powers_precompute</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_rem_powers_precomp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_rem_powers_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">powers</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_rem_powers_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(A\)</span> to the remainder of <span class="math notranslate nohighlight">\(A\)</span> divide <span class="math notranslate nohighlight">\(B\)</span> given precomputed powers mod <span class="math notranslate nohighlight">\(B\)</span>
provided by <code class="docutils literal notranslate"><span class="pre">_fmpz_poly_powers_precompute</span></code>. No aliasing is allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_rem_powers_precomp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_rem_powers_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_poly_powers_precomp_t</span></span><span class="w"> </span><span class="n"><span class="pre">B_inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_rem_powers_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <span class="math notranslate nohighlight">\(R\)</span> to the remainder of <span class="math notranslate nohighlight">\(A\)</span> divide <span class="math notranslate nohighlight">\(B\)</span> given precomputed powers mod <span class="math notranslate nohighlight">\(B\)</span>
provided by <code class="docutils literal notranslate"><span class="pre">fmpz_poly_powers_precompute</span></code>.</p>
</dd></dl>

</section>
<section id="divisibility-testing">
<h2>Divisibility testing<a class="headerlink" href="#divisibility-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_divides">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_divides</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_divides" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">lenB)</span></code> divides <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code> exactly and
sets <span class="math notranslate nohighlight">\(Q\)</span> to the quotient, otherwise returns 0.</p>
<p>It is assumed that <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span> and that <span class="math notranslate nohighlight">\(Q\)</span> has space
for <span class="math notranslate nohighlight">\(\operatorname{len}(A) - \operatorname{len}(B) + 1\)</span> coefficients.</p>
<p>Aliasing of <span class="math notranslate nohighlight">\(Q\)</span> with either of the inputs is not permitted.</p>
<p>This function is currently unoptimised and provided for convenience
only.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_divides">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_divides</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_divides" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns 1 if <span class="math notranslate nohighlight">\(B\)</span> divides <span class="math notranslate nohighlight">\(A\)</span> exactly and sets <span class="math notranslate nohighlight">\(Q\)</span> to the quotient,
otherwise returns 0.</p>
<p>This function is currently unoptimised and provided for convenience
only.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_remove">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_remove</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">res</span></code> to <code class="docutils literal notranslate"><span class="pre">poly1</span></code> divided by the highest power of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> that
divides it and return the power. The divisor <code class="docutils literal notranslate"><span class="pre">poly2</span></code> must not be zero or
<span class="math notranslate nohighlight">\(\pm 1\)</span>, otherwise an exception is raised.</p>
</dd></dl>

</section>
<section id="division-mod-p">
<h2>Division mod p<a class="headerlink" href="#division-mod-p" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_divlow_smodp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_divlow_smodp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_divlow_smodp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the <span class="math notranslate nohighlight">\(n\)</span> lowest coefficients of <span class="math notranslate nohighlight">\(f\)</span> divided by <span class="math notranslate nohighlight">\(g\)</span>, assuming the
division is exact modulo <span class="math notranslate nohighlight">\(p\)</span>. The computed coefficients are reduced modulo
<span class="math notranslate nohighlight">\(p\)</span> using the symmetric remainder system. We require <span class="math notranslate nohighlight">\(f\)</span> to be at least <span class="math notranslate nohighlight">\(n\)</span>
in length. The function can handle trailing zeroes, but the low nonzero
coefficient of <span class="math notranslate nohighlight">\(g\)</span> must be coprime to <span class="math notranslate nohighlight">\(p\)</span>. This is a bespoke function used
by factoring.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_divhigh_smodp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_divhigh_smodp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_divhigh_smodp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the <span class="math notranslate nohighlight">\(n\)</span> highest coefficients of <span class="math notranslate nohighlight">\(f\)</span> divided by <span class="math notranslate nohighlight">\(g\)</span>, assuming the
division is exact modulo <span class="math notranslate nohighlight">\(p\)</span>. The computed coefficients are reduced modulo
<span class="math notranslate nohighlight">\(p\)</span> using the symmetric remainder system. We require <span class="math notranslate nohighlight">\(f\)</span> to be as output
by <code class="docutils literal notranslate"><span class="pre">fmpz_poly_mulhigh_n</span></code> given polynomials <span class="math notranslate nohighlight">\(g\)</span> and a polynomial of
length <span class="math notranslate nohighlight">\(n\)</span> as inputs. The leading coefficient of <span class="math notranslate nohighlight">\(g\)</span> must be coprime to
<span class="math notranslate nohighlight">\(p\)</span>. This is a bespoke function used by factoring.</p>
</dd></dl>

</section>
<section id="power-series-division">
<h2>Power series division<a class="headerlink" href="#power-series-division" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_inv_series_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_inv_series_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Qlen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_inv_series_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the first <span class="math notranslate nohighlight">\(n\)</span> terms of the inverse power series of
<code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenQ)</span></code> using a recurrence.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(n \geq 1\)</span> and that <span class="math notranslate nohighlight">\(Q\)</span> has constant term <span class="math notranslate nohighlight">\(\pm 1\)</span>.
Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_inv_series_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_inv_series_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_inv_series_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the first <span class="math notranslate nohighlight">\(n\)</span> terms of the inverse power series of <span class="math notranslate nohighlight">\(Q\)</span>
using a recurrence, assuming that <span class="math notranslate nohighlight">\(Q\)</span> has constant term <span class="math notranslate nohighlight">\(\pm 1\)</span>
and <span class="math notranslate nohighlight">\(n \geq 1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_inv_series_newton">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_inv_series_newton</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_inv_series_newton" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the first <span class="math notranslate nohighlight">\(n\)</span> terms of the inverse power series of
<code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenQ)</span></code> using Newton iteration.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(n \geq 1\)</span> and that <span class="math notranslate nohighlight">\(Q\)</span> has constant term <span class="math notranslate nohighlight">\(\pm 1\)</span>.
Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_inv_series_newton">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_inv_series_newton</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Qlen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_inv_series_newton" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the first <span class="math notranslate nohighlight">\(n\)</span> terms of the inverse power series of <span class="math notranslate nohighlight">\(Q\)</span> using
Newton iteration, assuming <span class="math notranslate nohighlight">\(Q\)</span> has constant term <span class="math notranslate nohighlight">\(\pm 1\)</span> and <span class="math notranslate nohighlight">\(n \geq 1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_inv_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_inv_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_inv_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the first <span class="math notranslate nohighlight">\(n\)</span> terms of the inverse power series of
<code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenQ)</span></code>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(n \geq 1\)</span> and that <span class="math notranslate nohighlight">\(Q\)</span> has constant term <span class="math notranslate nohighlight">\(\pm 1\)</span>.
Does not support aliasing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_inv_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_inv_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_inv_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the first <span class="math notranslate nohighlight">\(n\)</span> terms of the inverse power series of <span class="math notranslate nohighlight">\(Q\)</span>,
assuming <span class="math notranslate nohighlight">\(Q\)</span> has constant term <span class="math notranslate nohighlight">\(\pm 1\)</span> and <span class="math notranslate nohighlight">\(n \geq 1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_series_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_series_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Alen</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Blen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_series_basecase" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_series_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_series_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Alen</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Blen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_series_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_div_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_div_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Alen</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Blen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_div_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Divides <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">Alen)</span></code> by <code class="docutils literal notranslate"><span class="pre">(B,</span> <span class="pre">Blen)</span></code> as power series over <span class="math notranslate nohighlight">\(\mathbb{Z}\)</span>,
assuming <span class="math notranslate nohighlight">\(B\)</span> has constant term <span class="math notranslate nohighlight">\(\pm 1\)</span> and <span class="math notranslate nohighlight">\(n \geq 1\)</span>.
Aliasing is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div_series_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div_series_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div_series_basecase" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div_series_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div_series_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div_series_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_div_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_div_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_div_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs power series division in <span class="math notranslate nohighlight">\(\mathbb{Z}[[x]] / (x^n)\)</span>.  The function
considers the polynomials <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> as power series of length <span class="math notranslate nohighlight">\(n\)</span>
starting with the constant terms.  The function assumes that <span class="math notranslate nohighlight">\(B\)</span> has
constant term <span class="math notranslate nohighlight">\(\pm 1\)</span> and <span class="math notranslate nohighlight">\(n \geq 1\)</span>.</p>
</dd></dl>

</section>
<section id="pseudo-division">
<h2>Pseudo division<a class="headerlink" href="#pseudo-division" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pseudo_divrem_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pseudo_divrem_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pseudo_divrem_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(\ell\)</span> is the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>, then computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such
that <span class="math notranslate nohighlight">\(\ell^d A = Q B + R\)</span>.  This function is used for simulating division
over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Assumes that <span class="math notranslate nohighlight">\(Q\)</span> can fit
<span class="math notranslate nohighlight">\(\operatorname{len}(A) - \operatorname{len}(B) + 1\)</span> coefficients, and that <span class="math notranslate nohighlight">\(R\)</span> can fit <span class="math notranslate nohighlight">\(\operatorname{len}(A)\)</span>
coefficients.  Supports aliasing of <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> and <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.
But other than this,  no aliasing of the inputs and outputs is supported.</p>
<p>An optional precomputed inverse of the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> from
<code class="docutils literal notranslate"><span class="pre">fmpz_preinvn_init</span></code> can be supplied. Otherwise <code class="docutils literal notranslate"><span class="pre">inv</span></code> should be
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pseudo_divrem_basecase">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pseudo_divrem_basecase</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pseudo_divrem_basecase" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(\ell\)</span> is the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>, then computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span> such
that <span class="math notranslate nohighlight">\(\ell^d A = Q B + R\)</span>.  This function is used for simulating division
over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pseudo_divrem_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pseudo_divrem_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pseudo_divrem_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> such that
<span class="math notranslate nohighlight">\(\ell^d A = B Q + R\)</span>, only setting the bottom <span class="math notranslate nohighlight">\(\operatorname{len}(B) - 1\)</span> coefficients
of <span class="math notranslate nohighlight">\(R\)</span> to their correct values.  The remaining top coefficients of
<code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> may be arbitrary.</p>
<p>Assumes <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Allows zero-padding in
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  No aliasing of input and output operands is allowed.</p>
<p>An optional precomputed inverse of the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> from
<code class="docutils literal notranslate"><span class="pre">fmpz_preinvn_init</span></code> can be supplied. Otherwise <code class="docutils literal notranslate"><span class="pre">inv</span></code> should be
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pseudo_divrem_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pseudo_divrem_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pseudo_divrem_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> such that <span class="math notranslate nohighlight">\(\ell^d A = B Q + R\)</span>, where <span class="math notranslate nohighlight">\(R\)</span> has
length less than the length of <span class="math notranslate nohighlight">\(B\)</span> and <span class="math notranslate nohighlight">\(\ell\)</span> is the leading coefficient
of <span class="math notranslate nohighlight">\(B\)</span>.  An exception is raised if <span class="math notranslate nohighlight">\(B\)</span> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pseudo_divrem_cohen">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pseudo_divrem_cohen</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pseudo_divrem_cohen" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assumes that <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Assumes that <span class="math notranslate nohighlight">\(Q\)</span> can fit
<span class="math notranslate nohighlight">\(\operatorname{len}(A) - \operatorname{len}(B) + 1\)</span> coefficients, and that <span class="math notranslate nohighlight">\(R\)</span> can fit <span class="math notranslate nohighlight">\(\operatorname{len}(A)\)</span>
coefficients.  Supports aliasing of <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> and <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.
But other than this, no aliasing of the inputs and outputs is supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pseudo_divrem_cohen">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pseudo_divrem_cohen</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pseudo_divrem_cohen" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is a variant of <code class="docutils literal notranslate"><span class="pre">fmpz_poly_pseudo_divrem</span></code> which computes
polynomials <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(\ell^d A = B Q + R\)</span>.  However, the
value of <span class="math notranslate nohighlight">\(d\)</span> is fixed at <span class="math notranslate nohighlight">\(\max{\{0, \operatorname{len}(A) - \operatorname{len}(B) + 1\}}\)</span>.</p>
<p>This function is faster when the remainder is not well behaved, i.e.where it is not expected to be close to zero.  Note that this function
is not asymptotically fast.  It is efficient only for short polynomials,
e.g.when <span class="math notranslate nohighlight">\(\operatorname{len}(B) &lt; 32\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pseudo_rem_cohen">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pseudo_rem_cohen</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pseudo_rem_cohen" title="Link to this definition">¶</a><br /></dt>
<dd><p>Assumes that <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Assumes that <span class="math notranslate nohighlight">\(R\)</span> can fit
<span class="math notranslate nohighlight">\(\operatorname{len}(A)\)</span> coefficients.  Supports aliasing of <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  But other than this, no aliasing of the inputs and
outputs is supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pseudo_rem_cohen">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pseudo_rem_cohen</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pseudo_rem_cohen" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is a variant of <a class="reference internal" href="#c.fmpz_poly_pseudo_rem" title="fmpz_poly_pseudo_rem"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_poly_pseudo_rem()</span></code></a> which computes
polynomials <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(R\)</span> such that <span class="math notranslate nohighlight">\(\ell^d A = B Q + R\)</span>, but only
returns <span class="math notranslate nohighlight">\(R\)</span>.  However, the value of <span class="math notranslate nohighlight">\(d\)</span> is fixed at
<span class="math notranslate nohighlight">\(\max{\{0, \operatorname{len}(A) - \operatorname{len}(B) + 1\}}\)</span>.</p>
<p>This function is faster when the remainder is not well behaved, i.e.where it is not expected to be close to zero.  Note that this function
is not asymptotically fast.  It is efficient only for short polynomials,
e.g.when <span class="math notranslate nohighlight">\(\operatorname{len}(B) &lt; 32\)</span>.</p>
<p>This function uses the algorithm described
in [Algorithm 3.1.2][Coh1996]_.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pseudo_divrem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pseudo_divrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pseudo_divrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(\ell\)</span> is the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span>, then computes
<code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">lenA</span> <span class="pre">-</span> <span class="pre">lenB</span> <span class="pre">+</span> <span class="pre">1)</span></code>, <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenB</span> <span class="pre">-</span> <span class="pre">1)</span></code> and <span class="math notranslate nohighlight">\(d\)</span> such that
<span class="math notranslate nohighlight">\(\ell^d A = B Q + R\)</span>.  This function is used for simulating division
over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(\operatorname{len}(A) \geq \operatorname{len}(B) &gt; 0\)</span>.  Assumes that <span class="math notranslate nohighlight">\(Q\)</span> can fit
<span class="math notranslate nohighlight">\(\operatorname{len}(A) - \operatorname{len}(B) + 1\)</span> coefficients, and that <span class="math notranslate nohighlight">\(R\)</span> can fit <span class="math notranslate nohighlight">\(\operatorname{len}(A)\)</span>
coefficients, although on exit only the bottom <span class="math notranslate nohighlight">\(\operatorname{len}(B)\)</span> coefficients
will carry meaningful data.</p>
<p>Supports aliasing of <code class="docutils literal notranslate"><span class="pre">(R,</span> <span class="pre">lenA)</span></code> and <code class="docutils literal notranslate"><span class="pre">(A,</span> <span class="pre">lenA)</span></code>.  But other
than this, no aliasing of the inputs and outputs is supported.</p>
<p>An optional precomputed inverse of the leading coefficient of <span class="math notranslate nohighlight">\(B\)</span> from
<code class="docutils literal notranslate"><span class="pre">fmpz_preinvn_init</span></code> can be supplied. Otherwise <code class="docutils literal notranslate"><span class="pre">inv</span></code> should be
<code class="docutils literal notranslate"><span class="pre">NULL</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pseudo_divrem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pseudo_divrem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pseudo_divrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(Q\)</span>, <span class="math notranslate nohighlight">\(R\)</span>, and <span class="math notranslate nohighlight">\(d\)</span> such that <span class="math notranslate nohighlight">\(\ell^d A = B Q + R\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pseudo_div">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pseudo_div</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pseudo_div" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pseudo-division, only returning the quotient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pseudo_div">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pseudo_div</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pseudo_div" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pseudo-division, only returning the quotient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_pseudo_rem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_pseudo_rem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">A</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenA</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">B</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lenB</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">fmpz_preinvn_t</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_pseudo_rem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pseudo-division, only returning the remainder.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_pseudo_rem">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_pseudo_rem</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">R</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">d</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_pseudo_rem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pseudo-division, only returning the remainder.</p>
</dd></dl>

</section>
<section id="derivative">
<h2>Derivative<a class="headerlink" href="#derivative" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_derivative">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_derivative</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rpoly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_derivative" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(rpoly,</span> <span class="pre">len</span> <span class="pre">-</span> <span class="pre">1)</span></code> to the derivative of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.
Also handles the cases where <code class="docutils literal notranslate"><span class="pre">len</span></code> is <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span> correctly.
Supports aliasing of <code class="docutils literal notranslate"><span class="pre">rpoly</span></code> and <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_derivative">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_derivative</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_derivative" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the derivative of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_nth_derivative">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_nth_derivative</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rpoly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_nth_derivative" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(rpoly,</span> <span class="pre">len</span> <span class="pre">-</span> <span class="pre">n)</span></code> to the nth derivative of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.
Also handles the cases where <code class="docutils literal notranslate"><span class="pre">len</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code> correctly.
Supports aliasing of <code class="docutils literal notranslate"><span class="pre">rpoly</span></code> and <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_nth_derivative">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_nth_derivative</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_nth_derivative" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the nth derivative of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

</section>
<section id="evaluation">
<h2>Evaluation<a class="headerlink" href="#evaluation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_divconquer_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_divconquer_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_divconquer_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> at the integer <span class="math notranslate nohighlight">\(a\)</span> using
a divide and conquer approach.  Assumes that the length of the polynomial
is at least one.  Allows zero padding.  Does not allow aliasing between
<code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_divconquer_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_divconquer_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_divconquer_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code> at the integer <span class="math notranslate nohighlight">\(a\)</span> using a divide
and conquer approach.</p>
<p>Aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is supported, however,
<code class="docutils literal notranslate"><span class="pre">res</span></code> may not be part of <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_horner_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_horner_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_horner_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">len)</span></code> at the integer <span class="math notranslate nohighlight">\(a\)</span> using
Horner’s rule, and sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the result.  Aliasing between
<code class="docutils literal notranslate"><span class="pre">res</span></code> and <span class="math notranslate nohighlight">\(a\)</span> or any of the coefficients of <span class="math notranslate nohighlight">\(f\)</span> is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_horner_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_horner_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_horner_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <span class="math notranslate nohighlight">\(f\)</span> at the integer <span class="math notranslate nohighlight">\(a\)</span> using Horner’s rule, and
sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the result.</p>
<p>As expected, aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span></code> is supported.
However, <code class="docutils literal notranslate"><span class="pre">res</span></code> may not be aliased with a coefficient of <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">len)</span></code> at the integer <span class="math notranslate nohighlight">\(a\)</span> and sets
<code class="docutils literal notranslate"><span class="pre">res</span></code> to the result.  Aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code> and <span class="math notranslate nohighlight">\(a\)</span> or any
of the coefficients of <span class="math notranslate nohighlight">\(f\)</span> is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <span class="math notranslate nohighlight">\(f\)</span> at the integer <span class="math notranslate nohighlight">\(a\)</span> and sets <code class="docutils literal notranslate"><span class="pre">res</span></code>
to the result.</p>
<p>As expected, aliasing between <code class="docutils literal notranslate"><span class="pre">res</span></code> and <span class="math notranslate nohighlight">\(a\)</span> is supported.  However,
<code class="docutils literal notranslate"><span class="pre">res</span></code> may not be aliased with a coefficient of <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_divconquer_fmpq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_divconquer_fmpq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rnum</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rden</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">anum</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">aden</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_divconquer_fmpq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">len)</span></code> at the rational
<code class="docutils literal notranslate"><span class="pre">(anum,</span> <span class="pre">aden)</span></code> using a divide and conquer approach, and sets
<code class="docutils literal notranslate"><span class="pre">(rnum,</span> <span class="pre">rden)</span></code> to the result in lowest terms. Assumes that
the length of the polynomial is at least one.</p>
<p>Aliasing between <code class="docutils literal notranslate"><span class="pre">(rnum,</span> <span class="pre">rden)</span></code> and <code class="docutils literal notranslate"><span class="pre">(anum,</span> <span class="pre">aden)</span></code> or any of
the coefficients of <span class="math notranslate nohighlight">\(f\)</span> is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_divconquer_fmpq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_divconquer_fmpq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_divconquer_fmpq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <span class="math notranslate nohighlight">\(f\)</span> at the rational <span class="math notranslate nohighlight">\(a\)</span> using a divide
and conquer approach, and sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the result.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_horner_fmpq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_horner_fmpq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rnum</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rden</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">anum</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">aden</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_horner_fmpq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">len)</span></code> at the rational
<code class="docutils literal notranslate"><span class="pre">(anum,</span> <span class="pre">aden)</span></code> using Horner’s rule, and sets <code class="docutils literal notranslate"><span class="pre">(rnum,</span> <span class="pre">rden)</span></code> to
the result in lowest terms.</p>
<p>Aliasing between <code class="docutils literal notranslate"><span class="pre">(rnum,</span> <span class="pre">rden)</span></code> and <code class="docutils literal notranslate"><span class="pre">(anum,</span> <span class="pre">aden)</span></code> or any of
the coefficients of <span class="math notranslate nohighlight">\(f\)</span> is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_horner_fmpq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_horner_fmpq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_horner_fmpq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <span class="math notranslate nohighlight">\(f\)</span> at the rational <span class="math notranslate nohighlight">\(a\)</span> using Horner’s rule, and
sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the result.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_fmpq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_fmpq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rnum</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">rden</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">anum</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">aden</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_fmpq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <code class="docutils literal notranslate"><span class="pre">(f,</span> <span class="pre">len)</span></code> at the rational
<code class="docutils literal notranslate"><span class="pre">(anum,</span> <span class="pre">aden)</span></code> and sets <code class="docutils literal notranslate"><span class="pre">(rnum,</span> <span class="pre">rden)</span></code> to the result in lowest
terms.</p>
<p>Aliasing between <code class="docutils literal notranslate"><span class="pre">(rnum,</span> <span class="pre">rden)</span></code> and <code class="docutils literal notranslate"><span class="pre">(anum,</span> <span class="pre">aden)</span></code> or any of
the coefficients of <span class="math notranslate nohighlight">\(f\)</span> is not supported.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_fmpq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_fmpq</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq_t" title="fmpq_t"><span class="n"><span class="pre">fmpq_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_fmpq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <span class="math notranslate nohighlight">\(f\)</span> at the rational <span class="math notranslate nohighlight">\(a\)</span>, and
sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the result.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_mpq">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_mpq</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpq_t</span></span><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mpq_t</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_mpq" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates the polynomial <span class="math notranslate nohighlight">\(f\)</span> at the rational <span class="math notranslate nohighlight">\(a\)</span> and sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to
the result.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_mod">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_mod</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> at the value <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span> and
returns the result.  The last argument <code class="docutils literal notranslate"><span class="pre">ninv</span></code> must be set
to the precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>, which can be obtained using
the function <a class="reference internal" href="ulong_extras.html#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_mod">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_mod</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">poly</span></code> at the value <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span> and returns the result.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_fmpz_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_fmpz_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_fmpz_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">f</span></code> at the <span class="math notranslate nohighlight">\(n\)</span> values given in the vector <code class="docutils literal notranslate"><span class="pre">f</span></code>,
writing the results to <code class="docutils literal notranslate"><span class="pre">res</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_horner_d">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_horner_d</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_horner_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code> at the double <span class="math notranslate nohighlight">\(d\)</span>. No attempt is made to do this
efficiently or in a numerically stable way. It is currently only used in
Flint for quick and dirty evaluations of polynomials with all coefficients
positive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_horner_d">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_horner_d</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_horner_d" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">poly</span></code> at the double <span class="math notranslate nohighlight">\(d\)</span>. No attempt is made to do this
efficiently or in a numerically stable way. It is currently only used in
Flint for quick and dirty evaluations of polynomials with all coefficients
positive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_horner_d_2exp">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_horner_d_2exp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_horner_d_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code> at the double <span class="math notranslate nohighlight">\(d\)</span>. Return the result as a double
and an exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> combination. No attempt is made to do this
efficiently or in a numerically stable way. It is currently only used in
Flint for quick and dirty evaluations of polynomials with all coefficients
positive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_evaluate_horner_d_2exp">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_evaluate_horner_d_2exp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_evaluate_horner_d_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">poly</span></code> at the double <span class="math notranslate nohighlight">\(d\)</span>. Return the result as a double
and an exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> combination. No attempt is made to do this
efficiently or in a numerically stable way. It is currently only used in
Flint for quick and dirty evaluations of polynomials with all coefficients
positive.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_evaluate_horner_d_2exp2">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_evaluate_horner_d_2exp2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">dexp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_evaluate_horner_d_2exp2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Evaluate <code class="docutils literal notranslate"><span class="pre">poly</span></code> at <code class="docutils literal notranslate"><span class="pre">d*2^dexp</span></code>. Return the result as a double
and an exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> combination. No attempt is made to do this
efficiently or in a numerically stable way. It is currently only used in
Flint for quick and dirty evaluations of polynomials with all coefficients
positive.</p>
</dd></dl>

</section>
<section id="newton-basis">
<h2>Newton basis<a class="headerlink" href="#newton-basis" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_monomial_to_newton">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_monomial_to_newton</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">roots</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_monomial_to_newton" title="Link to this definition">¶</a><br /></dt>
<dd><p>Converts <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code> in-place from its coefficients given
in the standard monomial basis to the Newton basis
for the roots <span class="math notranslate nohighlight">\(r_0, r_1, \ldots, r_{n-2}\)</span>.
In other words, this determines output coefficients <span class="math notranslate nohighlight">\(c_i\)</span> such that
<span class="math notranslate nohighlight">\(c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \ldots + c_{n-1}(x-r_0)(x-r_1)\cdots(x-r_{n-2})\)</span>
is equal to the input polynomial.
Uses repeated polynomial division.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_newton_to_monomial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_newton_to_monomial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">roots</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_newton_to_monomial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Converts <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code> in-place from its coefficients given
in the Newton basis for the roots <span class="math notranslate nohighlight">\(r_0, r_1, \ldots, r_{n-2}\)</span>
to the standard monomial basis. In other words, this evaluates
<span class="math notranslate nohighlight">\(c_0 + c_1(x-r_0) + c_2(x-r_0)(x-r_1) + \ldots + c_{n-1}(x-r_0)(x-r_1)\cdots(x-r_{n-2})\)</span>
where <span class="math notranslate nohighlight">\(c_i\)</span> are the input coefficients for <code class="docutils literal notranslate"><span class="pre">poly</span></code>.
Uses Horner’s rule.</p>
</dd></dl>

</section>
<section id="interpolation">
<h2>Interpolation<a class="headerlink" href="#interpolation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_interpolate_fmpz_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_interpolate_fmpz_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">xs</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">ys</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_interpolate_fmpz_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the unique interpolating polynomial of degree at
most <span class="math notranslate nohighlight">\(n - 1\)</span> satisfying <span class="math notranslate nohighlight">\(f(x_i) = y_i\)</span> for every pair <span class="math notranslate nohighlight">\(x_i, y_u\)</span> in
<code class="docutils literal notranslate"><span class="pre">xs</span></code> and <code class="docutils literal notranslate"><span class="pre">ys</span></code>, assuming that this polynomial has integer
coefficients.</p>
<p>If an interpolating polynomial with integer coefficients does not
exist, a <code class="docutils literal notranslate"><span class="pre">FLINT_INEXACT</span></code> exception is thrown.</p>
<p>It is assumed that the <span class="math notranslate nohighlight">\(x\)</span> values are distinct.</p>
</dd></dl>

</section>
<section id="composition">
<h2>Composition<a class="headerlink" href="#composition" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_compose_horner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_compose_horner</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_compose_horner" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">res</span></code> has space for <code class="docutils literal notranslate"><span class="pre">(len1-1)*(len2-1)</span> <span class="pre">+</span> <span class="pre">1</span></code>
coefficients.  Assumes that <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> are non-zero
polynomials.  Does not support aliasing between any of the inputs and
the output.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_compose_horner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_compose_horner</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_compose_horner" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.
To be more precise, denoting <code class="docutils literal notranslate"><span class="pre">res</span></code>, <code class="docutils literal notranslate"><span class="pre">poly1</span></code>, and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
by <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span>, and <span class="math notranslate nohighlight">\(h\)</span>, sets <span class="math notranslate nohighlight">\(f(t) = g(h(t))\)</span>.</p>
<p>This implementation uses Horner’s method.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_compose_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_compose_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_compose_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the composition of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>
using a divide and conquer approach and places the result into <code class="docutils literal notranslate"><span class="pre">res</span></code>,
assuming <code class="docutils literal notranslate"><span class="pre">res</span></code> can hold the output of length
<code class="docutils literal notranslate"><span class="pre">(len1</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">(len2</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">+</span> <span class="pre">1</span></code>.</p>
<p>Assumes <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>.  Does not support aliasing between
<code class="docutils literal notranslate"><span class="pre">res</span></code> and any of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_compose_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_compose_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_compose_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.
To be precise about the order of composition, denoting <code class="docutils literal notranslate"><span class="pre">res</span></code>,
<code class="docutils literal notranslate"><span class="pre">poly1</span></code>, and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> by <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span>, and <span class="math notranslate nohighlight">\(h\)</span>, respectively,
sets <span class="math notranslate nohighlight">\(f(t) = g(h(t))\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_compose">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_compose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_compose" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">res</span></code> has space for <code class="docutils literal notranslate"><span class="pre">(len1-1)*(len2-1)</span> <span class="pre">+</span> <span class="pre">1</span></code>
coefficients.  Assumes that <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> are non-zero
polynomials.  Does not support aliasing between any of the inputs and
the output.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_compose">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_compose</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_compose" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>.
To be precise about the order of composition, denoting <code class="docutils literal notranslate"><span class="pre">res</span></code>,
<code class="docutils literal notranslate"><span class="pre">poly1</span></code>, and <code class="docutils literal notranslate"><span class="pre">poly2</span></code> by <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span>, and <span class="math notranslate nohighlight">\(h\)</span>, respectively,
sets <span class="math notranslate nohighlight">\(f(t) = g(h(t))\)</span>.</p>
</dd></dl>

</section>
<section id="inflation-and-deflation">
<h2>Inflation and deflation<a class="headerlink" href="#inflation-and-deflation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_inflate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_inflate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">result</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">input</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">inflation</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_inflate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">result</span></code> to the inflated polynomial <span class="math notranslate nohighlight">\(p(x^n)\)</span> where
<span class="math notranslate nohighlight">\(p\)</span> is given by <code class="docutils literal notranslate"><span class="pre">input</span></code> and <span class="math notranslate nohighlight">\(n\)</span> is given by <code class="docutils literal notranslate"><span class="pre">inflation</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_deflate">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_deflate</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">result</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">input</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">deflation</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_deflate" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">result</span></code> to the deflated polynomial <span class="math notranslate nohighlight">\(p(x^{1/n})\)</span> where
<span class="math notranslate nohighlight">\(p\)</span> is given by <code class="docutils literal notranslate"><span class="pre">input</span></code> and <span class="math notranslate nohighlight">\(n\)</span> is given by <code class="docutils literal notranslate"><span class="pre">deflation</span></code>.
Requires <span class="math notranslate nohighlight">\(n &gt; 0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_deflation">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_deflation</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">input</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_deflation" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the largest integer by which <code class="docutils literal notranslate"><span class="pre">input</span></code> can be deflated.
As special cases, returns 0 if <code class="docutils literal notranslate"><span class="pre">input</span></code> is the zero polynomial
and 1 of <code class="docutils literal notranslate"><span class="pre">input</span></code> is a constant polynomial.</p>
</dd></dl>

</section>
<section id="taylor-shift">
<h2>Taylor shift<a class="headerlink" href="#taylor-shift" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_taylor_shift_horner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_taylor_shift_horner</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_taylor_shift_horner" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">poly</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span> in-place.
Uses an efficient version Horner’s rule.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_taylor_shift_horner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_taylor_shift_horner</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_taylor_shift_horner" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">f</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_taylor_shift_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_taylor_shift_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_taylor_shift_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">poly</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span> in-place.
Uses the divide-and-conquer polynomial composition algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_taylor_shift_divconquer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_taylor_shift_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_taylor_shift_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">f</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span>.
Uses the divide-and-conquer polynomial composition algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_taylor_shift_multi_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_taylor_shift_multi_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_taylor_shift_multi_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">poly</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span> in-place.
Uses a multimodular algorithm, distributing the computation
across <a class="reference internal" href="flint.html#c.flint_get_num_threads" title="flint_get_num_threads"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_get_num_threads()</span></code></a> threads.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_taylor_shift_multi_mod">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_taylor_shift_multi_mod</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_taylor_shift_multi_mod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">f</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span>.
Uses a multimodular algorithm, distributing the computation
across <a class="reference internal" href="flint.html#c.flint_get_num_threads" title="flint_get_num_threads"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_get_num_threads()</span></code></a> threads.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_taylor_shift">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_taylor_shift</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_taylor_shift" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">poly</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span> in-place.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_taylor_shift">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_taylor_shift</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_taylor_shift" title="Link to this definition">¶</a><br /></dt>
<dd><p>Performs the Taylor shift composing <code class="docutils literal notranslate"><span class="pre">f</span></code> by <span class="math notranslate nohighlight">\(x+c\)</span>.</p>
</dd></dl>

</section>
<section id="power-series-composition">
<h2>Power series composition<a class="headerlink" href="#power-series-composition" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_compose_series_horner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_compose_series_horner</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_compose_series_horner" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
modulo <span class="math notranslate nohighlight">\(x^n\)</span>, where the constant term of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is required
to be zero.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2,</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, that <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>,
and that <code class="docutils literal notranslate"><span class="pre">(len1-1)</span> <span class="pre">*</span> <span class="pre">(len2-1)</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>, and that <code class="docutils literal notranslate"><span class="pre">res</span></code> has
space for <code class="docutils literal notranslate"><span class="pre">n</span></code> coefficients. Does not support aliasing between any
of the inputs and the output.</p>
<p>This implementation uses the Horner scheme.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_compose_series_horner">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_compose_series_horner</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_compose_series_horner" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
modulo <span class="math notranslate nohighlight">\(x^n\)</span>, where the constant term of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is required
to be zero.</p>
<p>This implementation uses the Horner scheme.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_compose_series_brent_kung">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_compose_series_brent_kung</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_compose_series_brent_kung" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
modulo <span class="math notranslate nohighlight">\(x^n\)</span>, where the constant term of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is required
to be zero.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2,</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, that <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>,
and that <code class="docutils literal notranslate"><span class="pre">(len1-1)</span> <span class="pre">*</span> <span class="pre">(len2-1)</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>, and that <code class="docutils literal notranslate"><span class="pre">res</span></code> has
space for <code class="docutils literal notranslate"><span class="pre">n</span></code> coefficients. Does not support aliasing between any
of the inputs and the output.</p>
<p>This implementation uses Brent-Kung algorithm 2.1 <a class="reference internal" href="references.html#brentkung1978" id="id3"><span>[BrentKung1978]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_compose_series_brent_kung">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_compose_series_brent_kung</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_compose_series_brent_kung" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
modulo <span class="math notranslate nohighlight">\(x^n\)</span>, where the constant term of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is required
to be zero.</p>
<p>This implementation uses Brent-Kung algorithm 2.1 <a class="reference internal" href="references.html#brentkung1978" id="id4"><span>[BrentKung1978]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_compose_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_compose_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_compose_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
modulo <span class="math notranslate nohighlight">\(x^n\)</span>, where the constant term of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is required
to be zero.</p>
<p>Assumes that <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2,</span> <span class="pre">n</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, that <code class="docutils literal notranslate"><span class="pre">len1,</span> <span class="pre">len2</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>,
and that <code class="docutils literal notranslate"><span class="pre">(len1-1)</span> <span class="pre">*</span> <span class="pre">(len2-1)</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;=</span> <span class="pre">n</span></code>, and that <code class="docutils literal notranslate"><span class="pre">res</span></code> has
space for <code class="docutils literal notranslate"><span class="pre">n</span></code> coefficients. Does not support aliasing between any
of the inputs and the output.</p>
<p>This implementation automatically switches between the Horner scheme
and Brent-Kung algorithm 2.1 depending on the size of the inputs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_compose_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_compose_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_compose_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the composition of <code class="docutils literal notranslate"><span class="pre">poly1</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
modulo <span class="math notranslate nohighlight">\(x^n\)</span>, where the constant term of <code class="docutils literal notranslate"><span class="pre">poly2</span></code> is required
to be zero.</p>
<p>This implementation automatically switches between the Horner scheme
and Brent-Kung algorithm 2.1 depending on the size of the inputs.</p>
</dd></dl>

</section>
<section id="power-series-reversion">
<h2>Power series reversion<a class="headerlink" href="#power-series-reversion" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_revert_series_lagrange">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_revert_series_lagrange</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Qlen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_revert_series_lagrange" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of
<code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">Qlen)</span></code> as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>. The arguments may not be
aliased, and <code class="docutils literal notranslate"><span class="pre">Qlen</span></code> must be at least 2.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation uses the Lagrange inversion formula.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_revert_series_lagrange">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_revert_series_lagrange</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_revert_series_lagrange" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of <code class="docutils literal notranslate"><span class="pre">Q</span></code>
as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation uses the Lagrange inversion formula.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_revert_series_lagrange_fast">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_revert_series_lagrange_fast</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Qlen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_revert_series_lagrange_fast" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of
<code class="docutils literal notranslate"><span class="pre">(Q,</span> <span class="pre">Qlen)</span></code>
as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>. The arguments may not be
aliased, and <code class="docutils literal notranslate"><span class="pre">Qlen</span></code> must be at least 2.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation uses a reduced-complexity implementation
of the Lagrange inversion formula.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_revert_series_lagrange_fast">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_revert_series_lagrange_fast</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_revert_series_lagrange_fast" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of <code class="docutils literal notranslate"><span class="pre">Q</span></code>
as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation uses a reduced-complexity implementation
of the Lagrange inversion formula.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_revert_series_newton">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_revert_series_newton</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Qlen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_revert_series_newton" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of <code class="docutils literal notranslate"><span class="pre">Q</span></code>
as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>. The arguments may not be
aliased, and <code class="docutils literal notranslate"><span class="pre">Qlen</span></code> must be at least 2.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation uses Newton iteration <a class="reference internal" href="references.html#brentkung1978" id="id5"><span>[BrentKung1978]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_revert_series_newton">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_revert_series_newton</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_revert_series_newton" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of <code class="docutils literal notranslate"><span class="pre">Q</span></code>
as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation uses Newton iteration <a class="reference internal" href="references.html#brentkung1978" id="id6"><span>[BrentKung1978]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_revert_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_revert_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">Qlen</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_revert_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of <code class="docutils literal notranslate"><span class="pre">Q</span></code>
as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>. The arguments may not be
aliased, and <code class="docutils literal notranslate"><span class="pre">Qlen</span></code> must be at least 2.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation defaults to the fast version of
Lagrange interpolation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_revert_series">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_revert_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Qinv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_revert_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">Qinv</span></code> to the compositional inverse or reversion of <code class="docutils literal notranslate"><span class="pre">Q</span></code>
as a power series, i.e. computes <span class="math notranslate nohighlight">\(Q^{-1}\)</span> such that
<span class="math notranslate nohighlight">\(Q(Q^{-1}(x)) = Q^{-1}(Q(x)) = x \bmod x^n\)</span>.
It is required that <span class="math notranslate nohighlight">\(Q_0 = 0\)</span> and <span class="math notranslate nohighlight">\(Q_1 = \pm 1\)</span>.</p>
<p>This implementation defaults to the fast version of
Lagrange interpolation.</p>
</dd></dl>

</section>
<section id="square-root">
<h2>Square root<a class="headerlink" href="#square-root" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrtrem_classical">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrtrem_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrtrem_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> can be written in the form <span class="math notranslate nohighlight">\(A^2 + R\)</span> where
deg`(R) &lt;` deg`(<code class="docutils literal notranslate"><span class="pre">`poly`</span></code>)`, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>. If it can be so
written, <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">1)</span></code> is set to <span class="math notranslate nohighlight">\(A\)</span> and <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">m)</span></code> is set to
<span class="math notranslate nohighlight">\(R\)</span>, where <span class="math notranslate nohighlight">\(m =\)</span> deg`(<code class="docutils literal notranslate"><span class="pre">`poly`</span></code>)/2 + 1`.</p>
<p>For efficiency reasons, <code class="docutils literal notranslate"><span class="pre">r</span></code> must have room for <code class="docutils literal notranslate"><span class="pre">len</span></code>
coefficients, and may alias <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrtrem_classical">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrtrem_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrtrem_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(a\)</span> can be written as <span class="math notranslate nohighlight">\(b^2 + r\)</span> with deg`(r) &lt;` deg`(a)/2`, return
<span class="math notranslate nohighlight">\(1\)</span> and set <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(r\)</span> appropriately. Otherwise return <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrtrem_divconquer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrtrem_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">temp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrtrem_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns 1 if <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> can be written in the form <span class="math notranslate nohighlight">\(A^2 + R\)</span> where
deg`(R) &lt;` deg`(<code class="docutils literal notranslate"><span class="pre">`poly`</span></code>)`, otherwise returns <span class="math notranslate nohighlight">\(0\)</span>. If it can be so
written, <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">m</span> <span class="pre">-</span> <span class="pre">1)</span></code> is set to <span class="math notranslate nohighlight">\(A\)</span> and <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">m)</span></code> is set to
<span class="math notranslate nohighlight">\(R\)</span>, where <span class="math notranslate nohighlight">\(m =\)</span> deg`(<code class="docutils literal notranslate"><span class="pre">`poly`</span></code>)/2 + 1`.</p>
<p>For efficiency reasons, <code class="docutils literal notranslate"><span class="pre">r</span></code> must have room for <code class="docutils literal notranslate"><span class="pre">len</span></code>
coefficients, and may alias <code class="docutils literal notranslate"><span class="pre">poly</span></code>. Temporary space of <code class="docutils literal notranslate"><span class="pre">len</span></code>
coefficients is required.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrtrem_divconquer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrtrem_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrtrem_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(a\)</span> can be written as <span class="math notranslate nohighlight">\(b^2 + r\)</span> with deg`(r) &lt;` deg`(a)/2`, return
<span class="math notranslate nohighlight">\(1\)</span> and set <span class="math notranslate nohighlight">\(b\)</span> and <span class="math notranslate nohighlight">\(r\)</span> appropriately. Otherwise return <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrt_classical">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrt_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrt_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span> and <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> is a perfect square, sets
<code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1)</span></code> to the square root of <code class="docutils literal notranslate"><span class="pre">poly</span></code> with positive
leading coefficient and returns 1. Otherwise returns 0.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(0\)</span>, allows a remainder after the square root, which is
not computed.</p>
<p>This function first uses various tests to detect nonsquares quickly.
Then, it computes the square root iteratively from top to bottom,
requiring <span class="math notranslate nohighlight">\(O(n^2)\)</span> coefficient operations.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrt_classical">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrt_classical</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrt_classical" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is a perfect square, sets <code class="docutils literal notranslate"><span class="pre">b</span></code> to the square root of
<code class="docutils literal notranslate"><span class="pre">a</span></code> with positive leading coefficient and returns 1.
Otherwise returns 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrt_KS">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrt_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrt_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Heuristic square root. If the return value is <span class="math notranslate nohighlight">\(-1\)</span>, the function failed,
otherwise it succeeded and the following applies.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> is a perfect square, sets
<code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1)</span></code> to the square root of <code class="docutils literal notranslate"><span class="pre">poly</span></code> with positive
leading coefficient and returns 1. Otherwise returns 0.</p>
<p>This function first uses various tests to detect nonsquares quickly.
Then, it computes the square root iteratively from top to bottom.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrt_KS">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrt_KS</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrt_KS" title="Link to this definition">¶</a><br /></dt>
<dd><p>Heuristic square root. If the return value is <span class="math notranslate nohighlight">\(-1\)</span>, the function failed,
otherwise it succeeded and the following applies.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is a perfect square, sets <code class="docutils literal notranslate"><span class="pre">b</span></code> to the square root of
<code class="docutils literal notranslate"><span class="pre">a</span></code> with positive leading coefficient and returns 1.
Otherwise returns 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrt_divconquer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrt_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">exact</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrt_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(1\)</span> and <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> is a perfect square, sets
<code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1)</span></code> to the square root of <code class="docutils literal notranslate"><span class="pre">poly</span></code> with positive
leading coefficient and returns 1. Otherwise returns 0.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exact</span></code> is <span class="math notranslate nohighlight">\(0\)</span>, allows a remainder after the square root, which is
not computed.</p>
<p>This function first uses various tests to detect nonsquares quickly.
Then, it computes the square root iteratively from top to bottom.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrt_divconquer">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrt_divconquer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrt_divconquer" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is a perfect square, sets <code class="docutils literal notranslate"><span class="pre">b</span></code> to the square root of
<code class="docutils literal notranslate"><span class="pre">a</span></code> with positive leading coefficient and returns 1.
Otherwise returns 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> is a perfect square, sets <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">len</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">+</span> <span class="pre">1)</span></code>
to the square root of <code class="docutils literal notranslate"><span class="pre">poly</span></code> with positive leading coefficient
and returns 1. Otherwise returns 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">a</span></code> is a perfect square, sets <code class="docutils literal notranslate"><span class="pre">b</span></code> to the square root of
<code class="docutils literal notranslate"><span class="pre">a</span></code> with positive leading coefficient and returns 1.
Otherwise returns 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_sqrt_series">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_sqrt_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_sqrt_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">(res,</span> <span class="pre">n)</span></code> to the square root of the series <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n)</span></code>, if it
exists, and return <span class="math notranslate nohighlight">\(1\)</span>, otherwise, return <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>If the valuation of <code class="docutils literal notranslate"><span class="pre">poly</span></code> is not zero, <code class="docutils literal notranslate"><span class="pre">res</span></code> is zero padded
to make up for the fact that the square root may not be known to precision
<span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_sqrt_series">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_sqrt_series</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_sqrt_series" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">b</span></code> to the square root of the series <code class="docutils literal notranslate"><span class="pre">a</span></code>, where the latter
is taken to be a series of precision <span class="math notranslate nohighlight">\(n\)</span>. If such a square root exists,
return <span class="math notranslate nohighlight">\(1\)</span>, otherwise, return <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Note that if the valuation of <code class="docutils literal notranslate"><span class="pre">a</span></code> is not zero, <code class="docutils literal notranslate"><span class="pre">b</span></code> will
not have precision <code class="docutils literal notranslate"><span class="pre">n</span></code>. It is given only to the precision to which
the square root can be computed.</p>
</dd></dl>

</section>
<section id="power-sums">
<h2>Power sums<a class="headerlink" href="#power-sums" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_power_sums_naive">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_power_sums_naive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_power_sums_naive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the (truncated) power sums series of the monic polynomial
<code class="docutils literal notranslate"><span class="pre">(poly,len)</span></code> up to length <span class="math notranslate nohighlight">\(n\)</span> using Newton identities.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_power_sums_naive">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_power_sums_naive</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_power_sums_naive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the (truncated) power sum series of the monic polynomial
<code class="docutils literal notranslate"><span class="pre">poly</span></code> up to length <span class="math notranslate nohighlight">\(n\)</span> using Newton identities.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_power_sums">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_power_sums</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_power_sums" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the (truncated) power sums series of the monic polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code>
up to length <span class="math notranslate nohighlight">\(n\)</span>. That is the power series whose coefficient of degree <span class="math notranslate nohighlight">\(i\)</span> is
the sum of the <span class="math notranslate nohighlight">\(i\)</span>-th power of all (complex) roots of the polynomial
<code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_power_sums_to_poly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_power_sums_to_poly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_power_sums_to_poly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the (monic) polynomial given by its power sums series <code class="docutils literal notranslate"><span class="pre">(poly,len)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_power_sums_to_poly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_power_sums_to_poly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Q</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_power_sums_to_poly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the (monic) polynomial given its power sums series <code class="docutils literal notranslate"><span class="pre">(Q)</span></code>.</p>
</dd></dl>

</section>
<section id="signature">
<h2>Signature<a class="headerlink" href="#signature" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_signature">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_signature</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_signature" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the signature <span class="math notranslate nohighlight">\((r_1, r_2)\)</span> of the polynomial
<code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code>.  Assumes that the polynomial is squarefree over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_signature">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_signature</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_signature" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the signature <span class="math notranslate nohighlight">\((r_1, r_2)\)</span> of the polynomial <code class="docutils literal notranslate"><span class="pre">poly</span></code>,
which is assumed to be square-free over <span class="math notranslate nohighlight">\(\mathbb{Q}\)</span>.  The values of <span class="math notranslate nohighlight">\(r_1\)</span> and
<span class="math notranslate nohighlight">\(2 r_2\)</span> are the number of real and complex roots of the polynomial,
respectively.  For convenience, the zero polynomial is allowed, in which
case the output is <span class="math notranslate nohighlight">\((0, 0)\)</span>.</p>
<p>If the polynomial is not square-free, the behaviour is undefined and an
exception may be raised.</p>
<p>This function uses the algorithm described
in [Algorithm 4.1.11][Coh1996]_.</p>
</dd></dl>

</section>
<section id="hensel-lifting">
<h2>Hensel lifting<a class="headerlink" href="#hensel-lifting" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hensel_build_tree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hensel_build_tree</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">link</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_poly_factor.html#c.nmod_poly_factor_t" title="nmod_poly_factor_t"><span class="n"><span class="pre">nmod_poly_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">fac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hensel_build_tree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises and builds a Hensel tree consisting of two arrays <span class="math notranslate nohighlight">\(v\)</span>, <span class="math notranslate nohighlight">\(w\)</span>
of polynomials an array of links, called <code class="docutils literal notranslate"><span class="pre">link</span></code>.</p>
<p>The caller supplies a set of <span class="math notranslate nohighlight">\(r\)</span> local factors (in the factor structure
<code class="docutils literal notranslate"><span class="pre">fac</span></code>) of some polynomial <span class="math notranslate nohighlight">\(F\)</span> over <span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>. They also supply
two arrays of initialised polynomials <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span>, each of length
<span class="math notranslate nohighlight">\(2r - 2\)</span> and an array <code class="docutils literal notranslate"><span class="pre">link</span></code>, also of length <span class="math notranslate nohighlight">\(2r - 2\)</span>.</p>
<p>We will have five arrays: a <span class="math notranslate nohighlight">\(v\)</span> of <code class="docutils literal notranslate"><span class="pre">fmpz_poly_t</span></code>’s and a <span class="math notranslate nohighlight">\(V\)</span> of
<code class="docutils literal notranslate"><span class="pre">nmod_poly_t</span></code>’s and also a <span class="math notranslate nohighlight">\(w\)</span> and a <span class="math notranslate nohighlight">\(W\)</span> and <code class="docutils literal notranslate"><span class="pre">link</span></code>.  Here’s
the idea: we sort each leaf and node of a factor tree by degree, in
fact choosing to multiply the two smallest factors, then the next two
smallest (factors or products) etc.until a tree is made.  The tree
will be stored in the <span class="math notranslate nohighlight">\(v\)</span>’s. The first two elements of <span class="math notranslate nohighlight">\(v\)</span> will be the
smallest modular factors, the last two elements of <span class="math notranslate nohighlight">\(v\)</span> will multiply to
form <span class="math notranslate nohighlight">\(F\)</span> itself.  Since <span class="math notranslate nohighlight">\(v\)</span> will be rearranging the original factors we
will need to be able to recover the original order. For this we use the
array <code class="docutils literal notranslate"><span class="pre">link</span></code> which has nonnegative even numbers and negative numbers.
It is an array of <code class="docutils literal notranslate"><span class="pre">slong</span></code>’s which aligns with <span class="math notranslate nohighlight">\(V\)</span> and <span class="math notranslate nohighlight">\(v\)</span> if
<code class="docutils literal notranslate"><span class="pre">link</span></code> has a negative number in spot <span class="math notranslate nohighlight">\(j\)</span> that means <span class="math notranslate nohighlight">\(V_j\)</span> is an
original modular factor which has been lifted, if <code class="docutils literal notranslate"><span class="pre">link[j]</span></code> is a
nonnegative even number then <span class="math notranslate nohighlight">\(V_j\)</span> stores a product of the two entries
at <code class="docutils literal notranslate"><span class="pre">V[link[j]]</span></code> and <code class="docutils literal notranslate"><span class="pre">V[link[j]+1]</span></code>.
<span class="math notranslate nohighlight">\(W\)</span> and <span class="math notranslate nohighlight">\(w\)</span> play the role of the extended GCD, at <span class="math notranslate nohighlight">\(V_0\)</span>, <span class="math notranslate nohighlight">\(V_2\)</span>, <span class="math notranslate nohighlight">\(V_4\)</span>,
etc.we have a new product, <span class="math notranslate nohighlight">\(W_0\)</span>, <span class="math notranslate nohighlight">\(W_2\)</span>, <span class="math notranslate nohighlight">\(W_4\)</span>, etc.are the XGCD
cofactors of the <span class="math notranslate nohighlight">\(V\)</span>’s. For example,
<span class="math notranslate nohighlight">\(V_0 W_0 + V_1 W_1 \equiv 1 \pmod{p^{\ell}}\)</span> for some <span class="math notranslate nohighlight">\(\ell\)</span>.  These
will be lifted along with the entries in <span class="math notranslate nohighlight">\(V\)</span>.  It is not enough to just
lift each factor, we have to lift the entire tree and the tree of
XGCD cofactors.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hensel_lift">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hensel_lift</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">G</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">B</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p1</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hensel_lift" title="Link to this definition">¶</a><br /></dt>
<dd><p>This is the main Hensel lifting routine, which performs a Hensel step
from polynomials mod <span class="math notranslate nohighlight">\(p\)</span> to polynomials mod <span class="math notranslate nohighlight">\(P = p p_1\)</span>. One starts with
polynomials <span class="math notranslate nohighlight">\(f\)</span>, <span class="math notranslate nohighlight">\(g\)</span>, <span class="math notranslate nohighlight">\(h\)</span> such that <span class="math notranslate nohighlight">\(f = gh \pmod p\)</span>. The polynomials
<span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> satisfy <span class="math notranslate nohighlight">\(ag + bh = 1 \pmod p\)</span>.</p>
<p>The lifting formulae are</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}G = \biggl( \bigl( \frac{f-gh}{p} \bigr) b \bmod g \biggr) p + g\\H = \biggl( \bigl( \frac{f-gh}{p} \bigr) a \bmod h \biggr) p + h\\B = \biggl( \bigl( \frac{1-aG-bH}{p} \bigr) b \bmod g \biggr) p + b\\A = \biggl( \bigl( \frac{1-aG-bH}{p} \bigr) a \bmod h \biggr) p + a\end{aligned}\end{align} \]</div>
<p>Upon return we have <span class="math notranslate nohighlight">\(A G + B H = 1 \pmod P\)</span> and <span class="math notranslate nohighlight">\(f = G H \pmod P\)</span>,
where <span class="math notranslate nohighlight">\(G = g \pmod p\)</span> etc.</p>
<p>We require that <span class="math notranslate nohighlight">\(1 &lt; p_1 \leq p\)</span> and that the input polynomials <span class="math notranslate nohighlight">\(f, g, h\)</span>
have degree at least <span class="math notranslate nohighlight">\(1\)</span> and that the input polynomials <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are
non-zero.</p>
<p>The output arguments <span class="math notranslate nohighlight">\(G, H, A, B\)</span> may only be aliased with
the input arguments <span class="math notranslate nohighlight">\(g, h, a, b\)</span>, respectively.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hensel_lift_without_inverse">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hensel_lift_without_inverse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Gout</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Hout</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">g</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">h</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p1</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hensel_lift_without_inverse" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given polynomials such that <span class="math notranslate nohighlight">\(f = gh \pmod p\)</span> and <span class="math notranslate nohighlight">\(ag + bh = 1 \pmod p\)</span>,
lifts only the factors <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> modulo <span class="math notranslate nohighlight">\(P = p p_1\)</span>.</p>
<p>See <a class="reference internal" href="#c.fmpz_poly_hensel_lift" title="fmpz_poly_hensel_lift"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_poly_hensel_lift()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hensel_lift_only_inverse">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hensel_lift_only_inverse</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Aout</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Bout</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">G</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">H</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p1</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hensel_lift_only_inverse" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given polynomials such that <span class="math notranslate nohighlight">\(f = gh \pmod p\)</span> and <span class="math notranslate nohighlight">\(ag + bh = 1 \pmod p\)</span>,
lifts only the cofactors <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> modulo <span class="math notranslate nohighlight">\(P = p p_1\)</span>.</p>
<p>See <a class="reference internal" href="#c.fmpz_poly_hensel_lift" title="fmpz_poly_hensel_lift"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_poly_hensel_lift()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hensel_lift_tree_recursive">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hensel_lift_tree_recursive</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">link</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">j</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p0</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p1</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hensel_lift_tree_recursive" title="Link to this definition">¶</a><br /></dt>
<dd><p>Takes a current Hensel tree <code class="docutils literal notranslate"><span class="pre">(link,</span> <span class="pre">v,</span> <span class="pre">w)</span></code> and a pair <span class="math notranslate nohighlight">\((j,j+1)\)</span>
of entries in the tree and lifts the tree from mod <span class="math notranslate nohighlight">\(p_0\)</span> to
mod <span class="math notranslate nohighlight">\(P = p_0 p_1\)</span>, where <span class="math notranslate nohighlight">\(1 &lt; p_1 \leq p_0\)</span>.</p>
<p>Set <code class="docutils literal notranslate"><span class="pre">inv</span></code> to <span class="math notranslate nohighlight">\(-1\)</span> if restarting Hensel lifting, <span class="math notranslate nohighlight">\(0\)</span> if stopping
and <span class="math notranslate nohighlight">\(1\)</span> otherwise.</p>
<p>Here <span class="math notranslate nohighlight">\(f = g h\)</span> is the polynomial whose factors we are trying to lift.
We will have that <code class="docutils literal notranslate"><span class="pre">v[j]</span></code> is the product of <code class="docutils literal notranslate"><span class="pre">v[link[j]]</span></code> and
<code class="docutils literal notranslate"><span class="pre">v[link[j]</span> <span class="pre">+</span> <span class="pre">1]</span></code> as described above.</p>
<p>Does support aliasing of <span class="math notranslate nohighlight">\(f\)</span> with one of the polynomials in
the lists <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(w\)</span>.  But the polynomials in these two lists
are not allowed to be aliases of each other.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hensel_lift_tree">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hensel_lift_tree</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">link</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">e0</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">e1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">inv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hensel_lift_tree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(p_0 = p^{e_0}\)</span> and <span class="math notranslate nohighlight">\(p_1 = p^{e_1 - e_0}\)</span> for a small prime <span class="math notranslate nohighlight">\(p\)</span>
and <span class="math notranslate nohighlight">\(P = p^{e_1}\)</span>.</p>
<p>If we aim to lift to <span class="math notranslate nohighlight">\(p^b\)</span> then <span class="math notranslate nohighlight">\(f\)</span> is the polynomial whose factors we
wish to lift, made monic mod <span class="math notranslate nohighlight">\(p^b\)</span>. As usual, <code class="docutils literal notranslate"><span class="pre">(link,</span> <span class="pre">v,</span> <span class="pre">w)</span></code> is an
initialised tree.</p>
<p>This starts the recursion on lifting the <em>product tree</em> for lifting
from <span class="math notranslate nohighlight">\(p^{e_0}\)</span> to <span class="math notranslate nohighlight">\(p^{e_1}\)</span>. The value of <code class="docutils literal notranslate"><span class="pre">inv</span></code> corresponds to that
given for the function <a class="reference internal" href="#c.fmpz_poly_hensel_lift_tree_recursive" title="fmpz_poly_hensel_lift_tree_recursive"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_poly_hensel_lift_tree_recursive()</span></code></a>. We
set <span class="math notranslate nohighlight">\(r\)</span> to the number of local factors of <span class="math notranslate nohighlight">\(f\)</span>.</p>
<p>In terms of the notation, above <span class="math notranslate nohighlight">\(P = p^{e_1}\)</span>, <span class="math notranslate nohighlight">\(p_0 = p^{e_0}\)</span> and
<span class="math notranslate nohighlight">\(p_1 = p^{e_1-e_0}\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(f\)</span> is monic.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(1 &lt; p_1 \leq p_0\)</span>, that is, <span class="math notranslate nohighlight">\(0 &lt; e_1 \leq e_0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_hensel_start_lift">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_hensel_start_lift</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly_factor.html#c.fmpz_poly_factor_t" title="fmpz_poly_factor_t"><span class="n"><span class="pre">fmpz_poly_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">lifted_fac</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">link</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_poly_factor.html#c.nmod_poly_factor_t" title="nmod_poly_factor_t"><span class="n"><span class="pre">nmod_poly_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">local_fac</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_hensel_start_lift" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function takes the local factors in <code class="docutils literal notranslate"><span class="pre">local_fac</span></code>
and Hensel lifts them until they are known mod <span class="math notranslate nohighlight">\(p^N\)</span>, where
<span class="math notranslate nohighlight">\(N \geq 1\)</span>.</p>
<p>These lifted factors will be stored (in the same ordering) in
<code class="docutils literal notranslate"><span class="pre">lifted_fac</span></code>. It is assumed that <code class="docutils literal notranslate"><span class="pre">link</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code>, and
<code class="docutils literal notranslate"><span class="pre">w</span></code> are initialized arrays <code class="docutils literal notranslate"><span class="pre">fmpz_poly_t</span></code>’s with at least
<span class="math notranslate nohighlight">\(2*r - 2\)</span> entries and that <span class="math notranslate nohighlight">\(r \geq 2\)</span>.  This is done outside of
this function so that you can keep them for restarting Hensel lifting
later. The product of local factors must be squarefree.</p>
<p>The return value is an exponent which must be passed to the function
<a class="reference internal" href="#c._fmpz_poly_hensel_continue_lift" title="_fmpz_poly_hensel_continue_lift"><code class="xref c c-func docutils literal notranslate"><span class="pre">_fmpz_poly_hensel_continue_lift()</span></code></a> as <code class="docutils literal notranslate"><span class="pre">prev_exp</span></code> if the
Hensel lifting is to be resumed.</p>
<p>Currently, supports the case when <span class="math notranslate nohighlight">\(N = 1\)</span> for convenience,
although it is preferable in this case to simple iterate
over the local factors and convert them to polynomials over
<span class="math notranslate nohighlight">\(\mathbf{Z}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_hensel_continue_lift">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_hensel_continue_lift</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly_factor.html#c.fmpz_poly_factor_t" title="fmpz_poly_factor_t"><span class="n"><span class="pre">fmpz_poly_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">lifted_fac</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">link</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">v</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">w</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">prev</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">curr</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_hensel_continue_lift" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function restarts a stopped Hensel lift.</p>
<p>It lifts from <code class="docutils literal notranslate"><span class="pre">curr</span></code> to <span class="math notranslate nohighlight">\(N\)</span>. It also requires <code class="docutils literal notranslate"><span class="pre">prev</span></code>
(to lift the cofactors) given as the return value of the function
<a class="reference internal" href="#c._fmpz_poly_hensel_start_lift" title="_fmpz_poly_hensel_start_lift"><code class="xref c c-func docutils literal notranslate"><span class="pre">_fmpz_poly_hensel_start_lift()</span></code></a> or the function
<a class="reference internal" href="#c._fmpz_poly_hensel_continue_lift" title="_fmpz_poly_hensel_continue_lift"><code class="xref c c-func docutils literal notranslate"><span class="pre">_fmpz_poly_hensel_continue_lift()</span></code></a>. The current lifted factors
are supplied in <code class="docutils literal notranslate"><span class="pre">lifted_fac</span></code> and upon return are updated
there. As usual <code class="docutils literal notranslate"><span class="pre">link</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code>, and <code class="docutils literal notranslate"><span class="pre">w</span></code> describe the
current Hensel tree, <span class="math notranslate nohighlight">\(r\)</span> is the number of local factors and <span class="math notranslate nohighlight">\(p\)</span> is
the small prime modulo whose power we are lifting to. It is required
that <code class="docutils literal notranslate"><span class="pre">curr</span></code> be at least <span class="math notranslate nohighlight">\(1\)</span> and that <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">&gt;</span> <span class="pre">curr</span></code>.</p>
<p>Currently, supports the case when <code class="docutils literal notranslate"><span class="pre">prev</span></code> and <code class="docutils literal notranslate"><span class="pre">curr</span></code>
are equal.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hensel_lift_once">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hensel_lift_once</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_poly_factor.html#c.fmpz_poly_factor_t" title="fmpz_poly_factor_t"><span class="n"><span class="pre">fmpz_poly_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">lifted_fac</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_poly_factor.html#c.nmod_poly_factor_t" title="nmod_poly_factor_t"><span class="n"><span class="pre">nmod_poly_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">local_fac</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hensel_lift_once" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function does a Hensel lift.</p>
<p>It lifts local factors stored in <code class="docutils literal notranslate"><span class="pre">local_fac</span></code> of <span class="math notranslate nohighlight">\(f\)</span> to <span class="math notranslate nohighlight">\(p^N\)</span>,
where <span class="math notranslate nohighlight">\(N \geq 2\)</span>. The lifted factors will be stored in <code class="docutils literal notranslate"><span class="pre">lifted_fac</span></code>.
This lift cannot be restarted. This function is a convenience function
intended for end users. The product of local factors must be squarefree.</p>
</dd></dl>

</section>
<section id="input-and-output">
<h2>Input and output<a class="headerlink" href="#input-and-output" title="Link to this heading">¶</a></h2>
<p>The functions in this section are not intended to be particularly fast.
They are intended mainly as a debugging aid.</p>
<p>For the string output functions there are two variants.  The first uses a
simple string representation of polynomials which prints only the length
of the polynomial and the integer coefficients, whilst the latter variant,
appended with <code class="docutils literal notranslate"><span class="pre">_pretty</span></code>, uses a more traditional string
representation of polynomials which prints a variable name as part of the
representation.</p>
<p>The first string representation is given by a sequence of integers, in
decimal notation, separated by white space.  The first integer gives the
length of the polynomial; the remaining integers are the coefficients.
For example <span class="math notranslate nohighlight">\(5x^3 - x + 1\)</span> is represented by the string
<code class="docutils literal notranslate"><span class="pre">&quot;4</span>&#160; <span class="pre">1</span> <span class="pre">-1</span> <span class="pre">0</span> <span class="pre">5&quot;</span></code>, and the zero polynomial is represented by <code class="docutils literal notranslate"><span class="pre">&quot;0&quot;</span></code>.
The coefficients may be signed and arbitrary precision.</p>
<p>The string representation of the functions appended by <code class="docutils literal notranslate"><span class="pre">_pretty</span></code>
includes only the non-zero terms of the polynomial, starting with the
one of highest degree.  Each term starts with a coefficient, prepended
with a sign, followed by the character <code class="docutils literal notranslate"><span class="pre">*</span></code>, followed by a variable
name, which must be passed as a string parameter to the function,
followed by a caret <code class="docutils literal notranslate"><span class="pre">^</span></code> followed by a non-negative exponent.</p>
<p>If the sign of the leading coefficient is positive, it is omitted. Also
the exponents of the degree 1 and 0 terms are omitted, as is the
variable and the <code class="docutils literal notranslate"><span class="pre">*</span></code> character in the case of the degree 0
coefficient.  If the coefficient is plus or minus one, the coefficient
is omitted, except for the sign.</p>
<p>Some examples of the <code class="docutils literal notranslate"><span class="pre">_pretty</span></code> representation are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">5</span><span class="o">*</span><span class="n">x</span><span class="o">^</span><span class="mi">3</span><span class="o">+</span><span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">4</span>
<span class="n">x</span><span class="o">^</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span>
<span class="o">-</span><span class="n">x</span><span class="o">^</span><span class="mi">4</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span>
<span class="n">x</span><span class="o">+</span><span class="mi">1</span>
<span class="mi">5</span>
</pre></div>
</div>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_print">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the polynomial <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> to <code class="docutils literal notranslate"><span class="pre">stdout</span></code>.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_print">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the polynomial to <code class="docutils literal notranslate"><span class="pre">stdout</span></code>.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_print_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_print_pretty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_print_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the pretty representation of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> to <code class="docutils literal notranslate"><span class="pre">stdout</span></code>,
using the string <code class="docutils literal notranslate"><span class="pre">x</span></code> to represent the indeterminate.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_print_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_print_pretty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_print_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the pretty representation of <code class="docutils literal notranslate"><span class="pre">poly</span></code> to <code class="docutils literal notranslate"><span class="pre">stdout</span></code>,
using the string <code class="docutils literal notranslate"><span class="pre">x</span></code> to represent the indeterminate.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_fprint">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_fprint</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_fprint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the polynomial <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> to the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_fprint">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_fprint</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_fprint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the polynomial to the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_fprint_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_fprint_pretty</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_fprint_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the pretty representation of <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">len)</span></code> to the stream
<code class="docutils literal notranslate"><span class="pre">file</span></code>, using the string <code class="docutils literal notranslate"><span class="pre">x</span></code> to represent the indeterminate.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_fprint_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_fprint_pretty</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_fprint_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Prints the pretty representation of <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>,
using the string <code class="docutils literal notranslate"><span class="pre">x</span></code> to represent the indeterminate.</p>
<p>In case of success, returns a positive value.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_read">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_read</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_read" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a polynomial from <code class="docutils literal notranslate"><span class="pre">stdin</span></code>, storing the result in <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_read_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_read_pretty</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_read_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a polynomial in pretty format from <code class="docutils literal notranslate"><span class="pre">stdin</span></code>.</p>
<p>For further details, see the documentation for the function
<a class="reference internal" href="#c.fmpz_poly_fread_pretty" title="fmpz_poly_fread_pretty"><code class="xref c c-func docutils literal notranslate"><span class="pre">fmpz_poly_fread_pretty()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_fread">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_fread</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_fread" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a polynomial from the stream <code class="docutils literal notranslate"><span class="pre">file</span></code>, storing the result
in <code class="docutils literal notranslate"><span class="pre">poly</span></code>.</p>
<p>In case of success, returns a positive number.  In case of failure,
returns a non-positive value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_fread_pretty">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_fread_pretty</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">FILE</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">file</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_fread_pretty" title="Link to this definition">¶</a><br /></dt>
<dd><p>Reads a polynomial from the file <code class="docutils literal notranslate"><span class="pre">file</span></code> and sets <code class="docutils literal notranslate"><span class="pre">poly</span></code>
to this polynomial.  The string <code class="docutils literal notranslate"><span class="pre">*x</span></code> is set to the variable
name that is used in the input.</p>
<p>Returns a positive value, equal to the number of characters read from
the file, in case of success.  Returns a non-positive value in case of
failure, which could either be a read error or the indicator of a
malformed input.</p>
</dd></dl>

</section>
<section id="modular-reduction-and-reconstruction">
<h2>Modular reduction and reconstruction<a class="headerlink" href="#modular-reduction-and-reconstruction" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_get_nmod_poly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_get_nmod_poly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="nmod_poly.html#c.nmod_poly_t" title="nmod_poly_t"><span class="n"><span class="pre">nmod_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Amod</span></span>, <a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_get_nmod_poly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the coefficients of <code class="docutils literal notranslate"><span class="pre">Amod</span></code> to the coefficients in <code class="docutils literal notranslate"><span class="pre">A</span></code>,
reduced by the modulus of <code class="docutils literal notranslate"><span class="pre">Amod</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_nmod_poly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_nmod_poly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_poly.html#c.nmod_poly_t" title="nmod_poly_t"><span class="n"><span class="pre">nmod_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Amod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_nmod_poly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the coefficients of <code class="docutils literal notranslate"><span class="pre">A</span></code> to the residues in <code class="docutils literal notranslate"><span class="pre">Amod</span></code>,
normalised to the interval <span class="math notranslate nohighlight">\(-m/2 \le r &lt; m/2\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is the modulus.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_set_nmod_poly_unsigned">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_set_nmod_poly_unsigned</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">A</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_poly.html#c.nmod_poly_t" title="nmod_poly_t"><span class="n"><span class="pre">nmod_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Amod</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_set_nmod_poly_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the coefficients of <code class="docutils literal notranslate"><span class="pre">A</span></code> to the residues in <code class="docutils literal notranslate"><span class="pre">Amod</span></code>,
normalised to the interval <span class="math notranslate nohighlight">\(0 \le r &lt; m\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is the modulus.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_CRT_ui_precomp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_CRT_ui_precomp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">m2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">m2inv</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m1m2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_CRT_ui_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the coefficients in <code class="docutils literal notranslate"><span class="pre">res</span></code> to the CRT reconstruction modulo
<span class="math notranslate nohighlight">\(m_1m_2\)</span> of the residues <code class="docutils literal notranslate"><span class="pre">(poly1,</span> <span class="pre">len1)</span></code> and <code class="docutils literal notranslate"><span class="pre">(poly2,</span> <span class="pre">len2)</span></code>
which are images modulo <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(m_2\)</span> respectively.
The caller must supply the precomputed product of the input moduli as
<span class="math notranslate nohighlight">\(m_1m_2\)</span>, the inverse of <span class="math notranslate nohighlight">\(m_1\)</span> modulo <span class="math notranslate nohighlight">\(m_2\)</span> as <span class="math notranslate nohighlight">\(c\)</span>, and
the precomputed inverse of <span class="math notranslate nohighlight">\(m_2\)</span> (in the form computed by
<code class="docutils literal notranslate"><span class="pre">n_preinvert_limb</span></code>) as <code class="docutils literal notranslate"><span class="pre">m2inv</span></code>.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">sign</span></code> = 0, residues <span class="math notranslate nohighlight">\(0 &lt;= r &lt; m_1 m_2\)</span> are computed, while
if <code class="docutils literal notranslate"><span class="pre">sign</span></code> = 1, residues <span class="math notranslate nohighlight">\(-m_1 m_2/2 &lt;= r &lt; m_1 m_2/2\)</span> are computed.</p>
<p>Coefficients of <code class="docutils literal notranslate"><span class="pre">res</span></code> are written up to the maximum of
<code class="docutils literal notranslate"><span class="pre">len1</span></code> and <code class="docutils literal notranslate"><span class="pre">len2</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_CRT_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_CRT_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m1</span></span>, <span class="n"><span class="pre">mp_srcptr</span></span><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">m2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">m2inv</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_CRT_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function is identical to <code class="docutils literal notranslate"><span class="pre">_fmpz_poly_CRT_ui_precomp</span></code>,
apart from automatically computing <span class="math notranslate nohighlight">\(m_1m_2\)</span> and <span class="math notranslate nohighlight">\(c\)</span>. It also
aborts if <span class="math notranslate nohighlight">\(c\)</span> cannot be computed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_CRT_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_CRT_ui</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">m</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="nmod_poly.html#c.nmod_poly_t" title="nmod_poly_t"><span class="n"><span class="pre">nmod_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly2</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">sign</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_CRT_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">poly1</span></code> with coefficients modulo <code class="docutils literal notranslate"><span class="pre">m</span></code> and <code class="docutils literal notranslate"><span class="pre">poly2</span></code>
with modulus <span class="math notranslate nohighlight">\(n\)</span>, sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the CRT reconstruction modulo <span class="math notranslate nohighlight">\(mn\)</span>
with coefficients satisfying <span class="math notranslate nohighlight">\(-mn/2 \le c &lt; mn/2\)</span> (if sign = 1)
or <span class="math notranslate nohighlight">\(0 \le c &lt; mn\)</span> (if sign = 0).</p>
</dd></dl>

</section>
<section id="products">
<h2>Products<a class="headerlink" href="#products" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_product_roots_fmpz_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_product_roots_fmpz_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">xs</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_product_roots_fmpz_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1)</span></code> to the monic polynomial which is the product
of <span class="math notranslate nohighlight">\((x - x_0)(x - x_1) \cdots (x - x_{n-1})\)</span>, the roots <span class="math notranslate nohighlight">\(x_i\)</span> being
given by <code class="docutils literal notranslate"><span class="pre">xs</span></code>.</p>
<p>Aliasing of the input and output is not allowed.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_product_roots_fmpz_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_product_roots_fmpz_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">xs</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_product_roots_fmpz_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the monic polynomial which is the product
of <span class="math notranslate nohighlight">\((x - x_0)(x - x_1) \cdots (x - x_{n-1})\)</span>, the roots <span class="math notranslate nohighlight">\(x_i\)</span> being
given by <code class="docutils literal notranslate"><span class="pre">xs</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_product_roots_fmpq_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_product_roots_fmpq_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq" title="fmpq"><span class="n"><span class="pre">fmpq</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">xs</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_product_roots_fmpq_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">(poly,</span> <span class="pre">n</span> <span class="pre">+</span> <span class="pre">1)</span></code> to the product of
<span class="math notranslate nohighlight">\((q_0 x - p_0)(q_1 x - p_1) \cdots (q_{n-1} x - p_{n-1})\)</span>, the roots
<span class="math notranslate nohighlight">\(p_i/q_i\)</span> being given by <code class="docutils literal notranslate"><span class="pre">xs</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_product_roots_fmpq_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_product_roots_fmpq_vec</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpq.html#c.fmpq" title="fmpq"><span class="n"><span class="pre">fmpq</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">xs</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_product_roots_fmpq_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the polynomial which is the product
of <span class="math notranslate nohighlight">\((q_0 x - p_0)(q_1 x - p_1) \cdots (q_{n-1} x - p_{n-1})\)</span>, the roots
<span class="math notranslate nohighlight">\(p_i/q_i\)</span> being given by <code class="docutils literal notranslate"><span class="pre">xs</span></code>.</p>
</dd></dl>

</section>
<section id="roots">
<h2>Roots<a class="headerlink" href="#roots" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_bound_roots">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_bound_roots</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bound</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_bound_roots" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_bound_roots">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_bound_roots</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">bound</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_bound_roots" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes a nonnegative integer <code class="docutils literal notranslate"><span class="pre">bound</span></code> that bounds the absolute
value of all complex roots of <code class="docutils literal notranslate"><span class="pre">poly</span></code>. Uses Fujiwara’s bound</p>
<div class="math notranslate nohighlight">
\[2 \max \left(
    \left|\frac{a_{n-1}}{a_n}\right|,
    \left|\frac{a_{n-2}}{a_n}\right|^{\frac{1}{2}}, \dotsc
    \left|\frac{a_1}{a_n}\right|^{\frac{1}{n-1}},
    \left|\frac{a_0}{2a_n}\right|^{\frac{1}{n}}
\right)\]</div>
<p>where the coefficients of the polynomial are <span class="math notranslate nohighlight">\(a_0, \ldots, a_n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_num_real_roots_sturm">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_num_real_roots_sturm</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n_neg</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n_pos</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pol</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_num_real_roots_sturm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">n_neg</span></code> and <code class="docutils literal notranslate"><span class="pre">n_pos</span></code> to the number of negative and
positive roots of the polynomial <code class="docutils literal notranslate"><span class="pre">(pol,</span> <span class="pre">len)</span></code> using Sturm
sequence. The Sturm sequence is computed via subresultant
remainders obtained by repeated call to the function
<code class="docutils literal notranslate"><span class="pre">_fmpz_poly_pseudo_rem_cohen</span></code>.</p>
<p>The polynomial is assumed to be squarefree, of degree larger than 1
and with non-zero constant coefficient.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_num_real_roots_sturm">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_num_real_roots_sturm</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">pol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_num_real_roots_sturm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of real roots of the squarefree polynomial <code class="docutils literal notranslate"><span class="pre">pol</span></code>
using Sturm sequence.</p>
<p>The polynomial is assumed to be squarefree.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_num_real_roots">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_num_real_roots</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">pol</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_num_real_roots" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of real roots of the squarefree polynomial
<code class="docutils literal notranslate"><span class="pre">(pol,</span> <span class="pre">len)</span></code>.</p>
<p>The polynomial is assumed to be squarefree.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_num_real_roots">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_num_real_roots</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">pol</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_num_real_roots" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of real roots of the squarefree polynomial <code class="docutils literal notranslate"><span class="pre">pol</span></code>.</p>
<p>The polynomial is assumed to be squarefree.</p>
</dd></dl>

</section>
<section id="minimal-polynomials">
<h2>Minimal polynomials<a class="headerlink" href="#minimal-polynomials" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_cyclotomic">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_cyclotomic</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_ptr</span></span><span class="w"> </span><span class="n"><span class="pre">factors</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num_factors</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">phi</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_cyclotomic" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">a</span></code> to the lower half of the cyclotomic polynomial <span class="math notranslate nohighlight">\(\Phi_n(x)\)</span>,
given <span class="math notranslate nohighlight">\(n \ge 3\)</span> which must be squarefree.</p>
<p>A precomputed array containing the prime factors of <span class="math notranslate nohighlight">\(n\)</span> must be provided,
as well as the value of the Euler totient function <span class="math notranslate nohighlight">\(\phi(n)\)</span> as <code class="docutils literal notranslate"><span class="pre">phi</span></code>.
If <span class="math notranslate nohighlight">\(n\)</span> is even, 2 must be the first factor in the list.</p>
<p>The degree of <span class="math notranslate nohighlight">\(\Phi_n(x)\)</span> is exactly <span class="math notranslate nohighlight">\(\phi(n)\)</span>. Only the low
<span class="math notranslate nohighlight">\((\phi(n) + 1) / 2\)</span> coefficients are written; the high coefficients
can be obtained afterwards by copying the low coefficients
in reverse order, since  <span class="math notranslate nohighlight">\(\Phi_n(x)\)</span> is a palindrome for <span class="math notranslate nohighlight">\(n \ne 1\)</span>.</p>
<p>We use the sparse power series algorithm described as Algorithm 4
<a class="reference internal" href="references.html#arnoldmonagan2011" id="id7"><span>[ArnoldMonagan2011]</span></a>. The algorithm is based on the identity</p>
<div class="math notranslate nohighlight">
\[\Phi_n(x) = \prod_{d|n} (x^d - 1)^{\mu(n/d)}.\]</div>
<p>Treating the polynomial as a power series, the multiplications and
divisions can be done very cheaply using repeated additions and
subtractions. The complexity is <span class="math notranslate nohighlight">\(O(2^k \phi(n))\)</span> where <span class="math notranslate nohighlight">\(k\)</span> is the
number of prime factors in <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>To improve efficiency for small <span class="math notranslate nohighlight">\(n\)</span>, we treat the <code class="docutils literal notranslate"><span class="pre">fmpz</span></code>
coefficients as machine integers when there is no risk of overflow.
The following bounds are given in Table 6 of <a class="reference internal" href="references.html#arnoldmonagan2011" id="id8"><span>[ArnoldMonagan2011]</span></a>:</p>
<p>For <span class="math notranslate nohighlight">\(n &lt; 10163195\)</span>, the largest coefficient in any <span class="math notranslate nohighlight">\(\Phi_n(x)\)</span>
has 27 bits, so machine arithmetic is safe on 32 bits.</p>
<p>For <span class="math notranslate nohighlight">\(n &lt; 169828113\)</span>, the largest coefficient in any <span class="math notranslate nohighlight">\(\Phi_n(x)\)</span>
has 60 bits, so machine arithmetic is safe on 64 bits.</p>
<p>Further, the coefficients are always <span class="math notranslate nohighlight">\(\pm 1\)</span> or 0 if there are
exactly two prime factors, so in this case machine arithmetic can be
used as well.</p>
<p>Finally, we handle two special cases: if there is exactly one prime
factor <span class="math notranslate nohighlight">\(n = p\)</span>, then <span class="math notranslate nohighlight">\(\Phi_n(x) = 1 + x + x^2 + \ldots + x^{n-1}\)</span>,
and if <span class="math notranslate nohighlight">\(n = 2m\)</span>, we use <span class="math notranslate nohighlight">\(\Phi_n(x) = \Phi_m(-x)\)</span> to fall back
to the case when <span class="math notranslate nohighlight">\(n\)</span> is odd.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_cyclotomic">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_cyclotomic</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_cyclotomic" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the <span class="math notranslate nohighlight">\(n\)</span>-th cyclotomic polynomial, defined as
<span class="math notranslate nohighlight">\(\Phi_n(x) = \prod_{\omega} (x-\omega)\)</span>
where <span class="math notranslate nohighlight">\(\omega\)</span> runs over all the <span class="math notranslate nohighlight">\(n\)</span>-th primitive roots of unity.</p>
<p>We factor <span class="math notranslate nohighlight">\(n\)</span> into <span class="math notranslate nohighlight">\(n = qs\)</span> where <span class="math notranslate nohighlight">\(q\)</span> is squarefree,
and compute <span class="math notranslate nohighlight">\(\Phi_q(x)\)</span>. Then <span class="math notranslate nohighlight">\(\Phi_n(x) = \Phi_q(x^s)\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_is_cyclotomic">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_is_cyclotomic</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_is_cyclotomic" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_is_cyclotomic">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_is_cyclotomic</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_is_cyclotomic" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <code class="docutils literal notranslate"><span class="pre">poly</span></code> is a cyclotomic polynomial, returns the index <span class="math notranslate nohighlight">\(n\)</span> of this
cyclotomic polynomial. If <code class="docutils literal notranslate"><span class="pre">poly</span></code> is not a cyclotomic polynomial,
returns 0.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_cos_minpoly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_cos_minpoly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_cos_minpoly" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_cos_minpoly">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_cos_minpoly</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_cos_minpoly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the minimal polynomial of <span class="math notranslate nohighlight">\(2 \cos(2 \pi / n)\)</span>.
For suitable choice of <span class="math notranslate nohighlight">\(n\)</span>, this gives the minimal polynomial
of <span class="math notranslate nohighlight">\(2 \cos(a \pi)\)</span> or <span class="math notranslate nohighlight">\(2 \sin(a \pi)\)</span> for any rational <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>The cosine is multiplied by a factor two since this gives
a monic polynomial with integer coefficients. One can obtain
the minimal polynomial for <span class="math notranslate nohighlight">\(\cos(2 \pi / n)\)</span> by making
the substitution <span class="math notranslate nohighlight">\(x \to x / 2\)</span>.</p>
<p>For <span class="math notranslate nohighlight">\(n &gt; 2\)</span>, the degree of the polynomial is <span class="math notranslate nohighlight">\(\varphi(n) / 2\)</span>.
For <span class="math notranslate nohighlight">\(n = 1, 2\)</span>, the degree is 1. For <span class="math notranslate nohighlight">\(n = 0\)</span>, we define
the output to be the constant polynomial 1.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_swinnerton_dyer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_swinnerton_dyer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_swinnerton_dyer" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_swinnerton_dyer">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_swinnerton_dyer</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_swinnerton_dyer" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the Swinnerton-Dyer polynomial <span class="math notranslate nohighlight">\(S_n\)</span>, defined as
the integer polynomial
<span class="math notranslate nohighlight">\(S_n = \prod (x \pm \sqrt{2} \pm \sqrt{3} \pm \sqrt{5} \pm \ldots \pm \sqrt{p_n})\)</span>
where <span class="math notranslate nohighlight">\(p_n\)</span> denotes the <span class="math notranslate nohighlight">\(n\)</span>-th prime number and all combinations
of signs are taken. This polynomial has degree <span class="math notranslate nohighlight">\(2^n\)</span> and is
irreducible over the integers (it is the minimal polynomial
of <span class="math notranslate nohighlight">\(\sqrt{2} + \ldots + \sqrt{p_n}\)</span>).</p>
</dd></dl>

</section>
<section id="orthogonal-polynomials">
<h2>Orthogonal polynomials<a class="headerlink" href="#orthogonal-polynomials" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_chebyshev_t">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_chebyshev_t</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_chebyshev_t" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_chebyshev_t">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_chebyshev_t</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_chebyshev_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the Chebyshev polynomial of the first kind <span class="math notranslate nohighlight">\(T_n(x)\)</span>,
defined by <span class="math notranslate nohighlight">\(T_n(x) = \cos(n \cos^{-1}(x))\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>. The coefficients are
calculated using a hypergeometric recurrence.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_chebyshev_u">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_chebyshev_u</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_chebyshev_u" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_chebyshev_u">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_chebyshev_u</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_chebyshev_u" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the Chebyshev polynomial of the first kind <span class="math notranslate nohighlight">\(U_n(x)\)</span>,
defined by <span class="math notranslate nohighlight">\((n+1) U_n(x) = T'_{n+1}(x)\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>.
The coefficients are calculated using a hypergeometric recurrence.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_legendre_pt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_legendre_pt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_legendre_pt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">coeffs</span></code> to the coefficient array of the shifted Legendre
polynomial <span class="math notranslate nohighlight">\(\tilde{P_n}(x)\)</span>, defined by <span class="math notranslate nohighlight">\(\tilde{P_n}(x) = P_n(2x-1)\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>.
The coefficients are calculated using a hypergeometric recurrence.
The length of the array will be <code class="docutils literal notranslate"><span class="pre">n+1</span></code>.
See <code class="docutils literal notranslate"><span class="pre">fmpq_poly</span></code> for the Legendre polynomials.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_legendre_pt">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_legendre_pt</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_legendre_pt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the shifted Legendre polynomial <span class="math notranslate nohighlight">\(\tilde{P_n}(x)\)</span>,
defined by <span class="math notranslate nohighlight">\(\tilde{P_n}(x) = P_n(2x-1)\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>. The coefficients are
calculated using a hypergeometric recurrence. See <code class="docutils literal notranslate"><span class="pre">fmpq_poly</span></code>
for the Legendre polynomials.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_hermite_h">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_hermite_h</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_hermite_h" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">coeffs</span></code> to the coefficient array of the Hermite
polynomial <span class="math notranslate nohighlight">\(H_n(x)\)</span>, defined by <span class="math notranslate nohighlight">\(H'_n(x) = 2nH_{n-1}(x)\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>.
The coefficients are calculated using a hypergeometric recurrence.
The length of the array will be <code class="docutils literal notranslate"><span class="pre">n+1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hermite_h">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hermite_h</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hermite_h" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the Hermite polynomial <span class="math notranslate nohighlight">\(H_n(x)\)</span>,
defined by <span class="math notranslate nohighlight">\(H'_n(x) = 2nH_{n-1}(x)\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>. The coefficients are
calculated using a hypergeometric recurrence.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_hermite_he">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_hermite_he</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_hermite_he" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">coeffs</span></code> to the coefficient array of the Hermite
polynomial <span class="math notranslate nohighlight">\(He_n(x)\)</span>, defined by
<span class="math notranslate nohighlight">\(He_n(x) = 2^{-\tfrac{n}{2}}H_n\left(\frac{x}{\sqrt2}\right)\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>.
The coefficients are calculated using a hypergeometric recurrence.
The length of the array will be <code class="docutils literal notranslate"><span class="pre">n+1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_hermite_he">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_hermite_he</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_hermite_he" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the Hermite polynomial <span class="math notranslate nohighlight">\(He_n(x)\)</span>,
defined by <span class="math notranslate nohighlight">\(He_n(x) = 2^{-\tfrac{n}{2}}H_n\left(\frac{x}{\sqrt2}\right)\)</span>, for <span class="math notranslate nohighlight">\(n\ge0\)</span>.
The coefficients are calculated using a hypergeometric recurrence.</p>
</dd></dl>

</section>
<section id="fibonacci-polynomials">
<h2>Fibonacci polynomials<a class="headerlink" href="#fibonacci-polynomials" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_fibonacci">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_fibonacci</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">coeffs</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_fibonacci" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">coeffs</span></code> to the coefficient array of the <span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci polynomial.
The coefficients are calculated using a hypergeometric recurrence.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_fibonacci">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_fibonacci</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">poly</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_fibonacci" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">poly</span></code> to the <span class="math notranslate nohighlight">\(n\)</span>-th Fibonacci polynomial.
The coefficients are calculated using a hypergeometric recurrence.</p>
</dd></dl>

</section>
<section id="eulerian-numbers-and-polynomials">
<h2>Eulerian numbers and polynomials<a class="headerlink" href="#eulerian-numbers-and-polynomials" title="Link to this heading">¶</a></h2>
<p>Eulerian numbers are the coefficients to the Eulerian polynomials</p>
<div class="math notranslate nohighlight">
\[A_n(x) = \sum_{m = 0}^{n} A(n, m) x^m,\]</div>
<p>where the Eulerian polynomials are defined by the exponential generating
function</p>
<div class="math notranslate nohighlight">
\[\frac{x - 1}{x - e^{(x - 1) t}}
= \sum_{n = 0}^{\infty} A_n(x) \frac{t^n}{n!}.\]</div>
<p>The Eulerian numbers can be expressed explicitly via the formula
.. math</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> \<span class="n">sum_</span><span class="p">{</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">}</span><span class="o">^</span><span class="p">{</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">^</span><span class="n">k</span> \<span class="n">binom</span><span class="p">{</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}{</span><span class="n">k</span><span class="p">}</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span><span class="o">^</span><span class="n">n</span><span class="o">.</span>
</pre></div>
</div>
<p>Note: Not to be confused with Euler numbers and polynomials.</p>
<dl class="c function">
<dt class="sig sig-object c" id="c.arith_eulerian_polynomial">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">arith_eulerian_polynomial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.arith_eulerian_polynomial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">res</span></code> to the Eulerian polynomial <span class="math notranslate nohighlight">\(A_n(x)\)</span>, where we define
<span class="math notranslate nohighlight">\(A_0(x) = 1\)</span>. The polynomial is calculated via a recursive relation.</p>
</dd></dl>

</section>
<section id="modular-forms-and-q-series">
<h2>Modular forms and q-series<a class="headerlink" href="#modular-forms-and-q-series" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_eta_qexp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_eta_qexp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_eta_qexp" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_eta_qexp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_eta_qexp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_eta_qexp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the <span class="math notranslate nohighlight">\(q\)</span>-expansion to length <span class="math notranslate nohighlight">\(n\)</span> of the
Dedekind eta function (without the leading factor
<span class="math notranslate nohighlight">\(q^{1/24}\)</span>) raised to the power <span class="math notranslate nohighlight">\(r\)</span>, i.e.
<span class="math notranslate nohighlight">\((q^{-1/24} \eta(q))^r = \prod_{k=1}^{\infty} (1 - q^k)^r\)</span>.</p>
<p>In particular, <span class="math notranslate nohighlight">\(r = -1\)</span> gives the generating function
of the partition function <span class="math notranslate nohighlight">\(p(k)\)</span>, and <span class="math notranslate nohighlight">\(r = 24\)</span> gives,
after multiplication by <span class="math notranslate nohighlight">\(q\)</span>,
the modular discriminant <span class="math notranslate nohighlight">\(\Delta(q)\)</span> which generates
the Ramanujan tau function <span class="math notranslate nohighlight">\(\tau(k)\)</span>.</p>
<p>This function uses sparse formulas for <span class="math notranslate nohighlight">\(r = 1, 2, 3, 4, 6\)</span>
and otherwise reduces to one of those cases using power series arithmetic.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._fmpz_poly_theta_qexp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_fmpz_poly_theta_qexp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._fmpz_poly_theta_qexp" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.fmpz_poly_theta_qexp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_theta_qexp</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_theta_qexp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets <span class="math notranslate nohighlight">\(f\)</span> to the <span class="math notranslate nohighlight">\(q\)</span>-expansion to length <span class="math notranslate nohighlight">\(n\)</span> of the
Jacobi theta function raised to the power <span class="math notranslate nohighlight">\(r\)</span>, i.e. <span class="math notranslate nohighlight">\(\vartheta(q)^r\)</span>
where <span class="math notranslate nohighlight">\(\vartheta(q) = 1 + 2 \sum_{k=1}^{\infty} q^{k^2}\)</span>.</p>
<p>This function uses sparse formulas for <span class="math notranslate nohighlight">\(r = 1, 2\)</span>
and otherwise reduces to those cases using power series arithmetic.</p>
</dd></dl>

</section>
<section id="cld-bounds">
<h2>CLD bounds<a class="headerlink" href="#cld-bounds" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.fmpz_poly_CLD_bound">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">fmpz_poly_CLD_bound</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">res</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.fmpz_poly_t" title="fmpz_poly_t"><span class="n"><span class="pre">fmpz_poly_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.fmpz_poly_CLD_bound" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute a bound on the <span class="math notranslate nohighlight">\(n\)</span> coefficient of <span class="math notranslate nohighlight">\(fg'/g\)</span> where <span class="math notranslate nohighlight">\(g\)</span> is any
factor of <span class="math notranslate nohighlight">\(f\)</span>.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a><ul>
<li><a class="reference internal" href="#types-macros-and-constants">Types, macros and constants</a></li>
<li><a class="reference internal" href="#memory-management">Memory management</a></li>
<li><a class="reference internal" href="#polynomial-parameters">Polynomial parameters</a></li>
<li><a class="reference internal" href="#assignment-and-basic-manipulation">Assignment and basic manipulation</a></li>
<li><a class="reference internal" href="#randomisation">Randomisation</a></li>
<li><a class="reference internal" href="#getting-and-setting-coefficients">Getting and setting coefficients</a></li>
<li><a class="reference internal" href="#comparison">Comparison</a></li>
<li><a class="reference internal" href="#addition-and-subtraction">Addition and subtraction</a></li>
<li><a class="reference internal" href="#scalar-absolute-value-multiplication-and-division">Scalar absolute value, multiplication and division</a></li>
<li><a class="reference internal" href="#bit-packing">Bit packing</a></li>
<li><a class="reference internal" href="#multiplication">Multiplication</a></li>
<li><a class="reference internal" href="#fft-precached-multiplication">FFT precached multiplication</a></li>
<li><a class="reference internal" href="#squaring">Squaring</a></li>
<li><a class="reference internal" href="#powering">Powering</a></li>
<li><a class="reference internal" href="#shifting">Shifting</a></li>
<li><a class="reference internal" href="#bit-sizes-and-norms">Bit sizes and norms</a></li>
<li><a class="reference internal" href="#greatest-common-divisor">Greatest common divisor</a></li>
<li><a class="reference internal" href="#discriminant">Discriminant</a></li>
<li><a class="reference internal" href="#gaussian-content">Gaussian content</a></li>
<li><a class="reference internal" href="#square-free">Square-free</a></li>
<li><a class="reference internal" href="#euclidean-division">Euclidean division</a></li>
<li><a class="reference internal" href="#division-with-precomputed-inverse">Division with precomputed inverse</a></li>
<li><a class="reference internal" href="#divisibility-testing">Divisibility testing</a></li>
<li><a class="reference internal" href="#division-mod-p">Division mod p</a></li>
<li><a class="reference internal" href="#power-series-division">Power series division</a></li>
<li><a class="reference internal" href="#pseudo-division">Pseudo division</a></li>
<li><a class="reference internal" href="#derivative">Derivative</a></li>
<li><a class="reference internal" href="#evaluation">Evaluation</a></li>
<li><a class="reference internal" href="#newton-basis">Newton basis</a></li>
<li><a class="reference internal" href="#interpolation">Interpolation</a></li>
<li><a class="reference internal" href="#composition">Composition</a></li>
<li><a class="reference internal" href="#inflation-and-deflation">Inflation and deflation</a></li>
<li><a class="reference internal" href="#taylor-shift">Taylor shift</a></li>
<li><a class="reference internal" href="#power-series-composition">Power series composition</a></li>
<li><a class="reference internal" href="#power-series-reversion">Power series reversion</a></li>
<li><a class="reference internal" href="#square-root">Square root</a></li>
<li><a class="reference internal" href="#power-sums">Power sums</a></li>
<li><a class="reference internal" href="#signature">Signature</a></li>
<li><a class="reference internal" href="#hensel-lifting">Hensel lifting</a></li>
<li><a class="reference internal" href="#input-and-output">Input and output</a></li>
<li><a class="reference internal" href="#modular-reduction-and-reconstruction">Modular reduction and reconstruction</a></li>
<li><a class="reference internal" href="#products">Products</a></li>
<li><a class="reference internal" href="#roots">Roots</a></li>
<li><a class="reference internal" href="#minimal-polynomials">Minimal polynomials</a></li>
<li><a class="reference internal" href="#orthogonal-polynomials">Orthogonal polynomials</a></li>
<li><a class="reference internal" href="#fibonacci-polynomials">Fibonacci polynomials</a></li>
<li><a class="reference internal" href="#eulerian-numbers-and-polynomials">Eulerian numbers and polynomials</a></li>
<li><a class="reference internal" href="#modular-forms-and-q-series">Modular forms and q-series</a></li>
<li><a class="reference internal" href="#cld-bounds">CLD bounds</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="fmpz_lll.html"
                          title="previous chapter"><strong>fmpz_lll.h</strong> – LLL reduction</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="fmpz_poly_mat.html"
                          title="next chapter"><strong>fmpz_poly_mat.h</strong> – matrices of polynomials over the integers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/fmpz_poly.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fmpz_poly_mat.html" title="fmpz_poly_mat.h – matrices of polynomials over the integers"
             >next</a> |</li>
        <li class="right" >
          <a href="fmpz_lll.html" title="fmpz_lll.h – LLL reduction"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>fmpz_poly.h</strong> – univariate polynomials over the integers</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2018, The Flint development team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>