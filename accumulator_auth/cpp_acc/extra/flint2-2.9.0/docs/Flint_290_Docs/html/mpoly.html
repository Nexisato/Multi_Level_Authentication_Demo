<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>mpoly.h – support functions for multivariate polynomials &#8212; Flint 2.9.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    
    <script src="_static/documentation_options.js?v=182a64a0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="ulong_extras.h – arithmetic and number-theoretic functions for single-word integers" href="ulong_extras.html" />
    <link rel="prev" title="perm.h – permutations" href="perm.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ulong_extras.html" title="ulong_extras.h – arithmetic and number-theoretic functions for single-word integers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="perm.html" title="perm.h – permutations"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="mpoly-h-support-functions-for-multivariate-polynomials">
<span id="mpoly"></span><h1><strong>mpoly.h</strong> – support functions for multivariate polynomials<a class="headerlink" href="#mpoly-h-support-functions-for-multivariate-polynomials" title="Link to this heading">¶</a></h1>
<blockquote>
<div><p>An array of type <code class="docutils literal notranslate"><span class="pre">ulong</span> <span class="pre">*</span></code> or <code class="docutils literal notranslate"><span class="pre">fmpz</span> <span class="pre">**</span></code> is used to communicate
exponent vectors. These exponent vectors must have length equal to the
number of variables in the polynomial ring.
The element of this exponent vector at index <span class="math notranslate nohighlight">\(0\)</span>
corresponds to the most significant variable in the monomial ordering.
For example, if the polynomial is <span class="math notranslate nohighlight">\(7*x^2*y+8*y*z+9\)</span> and the variables are
ordered so that <span class="math notranslate nohighlight">\(x&gt;y&gt;z\)</span>, the degree function will return <span class="math notranslate nohighlight">\({2,1,1}\)</span>.
Similarly, the exponent vector of the <span class="math notranslate nohighlight">\(0\)</span>-index term of this polynomial is
<span class="math notranslate nohighlight">\({2,1,0}\)</span>, while the <span class="math notranslate nohighlight">\(2\)</span>-index term has exponent vector <span class="math notranslate nohighlight">\({0,0,0}\)</span> and
coefficient <span class="math notranslate nohighlight">\(9\)</span>.</p>
</div></blockquote>
<section id="orderings">
<h2>Orderings<a class="headerlink" href="#orderings" title="Link to this heading">¶</a></h2>
<dl class="c type">
<dt class="sig sig-object c" id="c.ordering_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">ordering_t</span></span></span><a class="headerlink" href="#c.ordering_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>An enumeration of supported term orderings.  Currently one of <code class="docutils literal notranslate"><span class="pre">ORD_LEX</span></code>,
<code class="docutils literal notranslate"><span class="pre">ORD_DEGLEX</span></code> or <code class="docutils literal notranslate"><span class="pre">ORD_DEGREVLEX</span></code>.</p>
</dd></dl>

<dl class="c type">
<dt class="sig sig-object c" id="c.mpoly_ctx_struct">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ctx_struct</span></span></span><a class="headerlink" href="#c.mpoly_ctx_struct" title="Link to this definition">¶</a><br /></dt>
<dt class="sig sig-object c" id="c.mpoly_ctx_t">
<span class="k"><span class="pre">type</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ctx_t</span></span></span><a class="headerlink" href="#c.mpoly_ctx_t" title="Link to this definition">¶</a><br /></dt>
<dd><p>An mpoly_ctx_struct is a structure holding information about the number of
variables and the term ordering of an multivariate polynomial.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_ctx_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ctx_init</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ctx</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">nvars</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.ordering_t" title="ordering_t"><span class="n"><span class="pre">ordering_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_ctx_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a context for specified number of variables and ordering.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_ctx_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ctx_clear</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_ctx_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clean up any spaced used by a context object.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_ordering_randtest">
<a class="reference internal" href="#c.ordering_t" title="ordering_t"><span class="n"><span class="pre">ordering_t</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ordering_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_ordering_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return a random ordering. The possibilities are <code class="docutils literal notranslate"><span class="pre">ORD_LEX</span></code>,
<code class="docutils literal notranslate"><span class="pre">ORD_DEGLEX</span></code> and <code class="docutils literal notranslate"><span class="pre">ORD_DEGREVLEX</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_ctx_init_rand">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ctx_init_rand</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">max_nvars</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_ctx_init_rand" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialize a context with a random choice for the ordering.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_ordering_isdeg">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ordering_isdeg</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.ordering_t" title="ordering_t"><span class="n"><span class="pre">ordering_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_ordering_isdeg" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if the given ordering is a degree ordering (deglex or degrevlex).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_ordering_isrev">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ordering_isrev</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.ordering_t" title="ordering_t"><span class="n"><span class="pre">ordering_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_ordering_isrev" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if the given ordering is a reverse ordering (currently only
degrevlex).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_ordering_print">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_ordering_print</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#c.ordering_t" title="ordering_t"><span class="n"><span class="pre">ordering_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">ord</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_ordering_print" title="Link to this definition">¶</a><br /></dt>
<dd><p>Print a string (either “lex”, “deglex” or “degrevlex”) to standard
output, corresponding to the given ordering.</p>
</dd></dl>

</section>
<section id="monomial-arithmetic">
<h2>Monomial arithmetic<a class="headerlink" href="#monomial-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_add</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">(exp_ptr,</span> <span class="pre">N)</span></code> to the sum of the monomials <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>, assuming <code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&lt;=</span> <span class="pre">FLINT_BITS</span></code></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_add_mp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_add_mp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_add_mp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">(exp_ptr,</span> <span class="pre">N)</span></code> to the sum of the monomials <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> and
<code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_sub">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_sub</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_sub" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">(exp_ptr,</span> <span class="pre">N)</span></code> to the difference of the monomials <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> and <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>, assuming <code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&lt;=</span> <span class="pre">FLINT_BITS</span></code></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_sub_mp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_sub_mp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_sub_mp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set <code class="docutils literal notranslate"><span class="pre">(exp_ptr,</span> <span class="pre">N)</span></code> to the difference of the monomials <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> and <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_overflows">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_overflows</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_overflows" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return true if any of the fields of the given monomial <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> has
overflowed (or is negative). The <code class="docutils literal notranslate"><span class="pre">mask</span></code> is a word with the high bit of
each field set to 1. In other words, the function returns 1 if any word of
<code class="docutils literal notranslate"><span class="pre">exp2</span></code> has any of the nonzero bits in <code class="docutils literal notranslate"><span class="pre">mask</span></code> set. Assumes that
<code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&lt;=</span> <span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_overflows_mp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_overflows_mp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_overflows_mp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return true if any of the fields of the given monomial <code class="docutils literal notranslate"><span class="pre">(exp_ptr,</span> <span class="pre">N)</span></code>
has overflowed. Assumes that <code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&gt;=</span> <span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_overflows1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_overflows1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_overflows1" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">mpoly_monomial_overflows</span></code> with <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_set">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_set</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_set" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the monomial <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> to <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_swap">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_swap</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_swap" title="Link to this definition">¶</a><br /></dt>
<dd><p>Swap the words in <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> and <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_mul_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_mul_ui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_mul_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Set the words of <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> to the words of <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>
multiplied by <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

</section>
<section id="monomial-comparison">
<h2>Monomial comparison<a class="headerlink" href="#monomial-comparison" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_is_zero">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_is_zero</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_is_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if <code class="docutils literal notranslate"><span class="pre">(exp,</span> <span class="pre">N)</span></code> is zero.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_equal">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_equal</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_equal" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if the monomials <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> and <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code> are equal.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_get_cmpmask">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_get_cmpmask</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmpmask</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_get_cmpmask" title="Link to this definition">¶</a><br /></dt>
<dd><p>Get the mask <code class="docutils literal notranslate"><span class="pre">(cmpmask,</span> <span class="pre">N)</span></code> for comparisons.
<code class="docutils literal notranslate"><span class="pre">bits</span></code> should be set to the number of bits in the exponents
to be compared. Any function that compares monomials should use this
comparison mask.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_lt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_lt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmpmask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_lt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> is less than <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_gt">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_gt</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmpmask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_gt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_cmp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_cmp</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmpmask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_cmp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return <span class="math notranslate nohighlight">\(1\)</span> if <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code> is greater than, <span class="math notranslate nohighlight">\(0\)</span> if it is equal and
<span class="math notranslate nohighlight">\(-1\)</span> if it is less than, <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code>.</p>
</dd></dl>

</section>
<section id="monomial-divisibility">
<h2>Monomial divisibility<a class="headerlink" href="#monomial-divisibility" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_divides">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_divides</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_divides" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if the monomial <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code> divides <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code>. If so
set <code class="docutils literal notranslate"><span class="pre">(exp_ptr,</span> <span class="pre">N)</span></code> to the quotient monomial. The <code class="docutils literal notranslate"><span class="pre">mask</span></code> is a word
with the high bit of each bit field set to 1. Assumes that
<code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&lt;=</span> <span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_divides_mp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_divides_mp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_divides_mp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if the monomial <code class="docutils literal notranslate"><span class="pre">(exp3,</span> <span class="pre">N)</span></code> divides <code class="docutils literal notranslate"><span class="pre">(exp2,</span> <span class="pre">N)</span></code>. If so
set <code class="docutils literal notranslate"><span class="pre">(exp_ptr,</span> <span class="pre">N)</span></code> to the quotient monomial. Assumes that
<code class="docutils literal notranslate"><span class="pre">bits</span> <span class="pre">&gt;=</span> <span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_divides1">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_divides1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp_ptr</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp2</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp3</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">mask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_divides1" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">mpoly_monomial_divides</span></code> with <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_divides_tight">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_divides_tight</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">e1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">e2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prods</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_divides_tight" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return 1 if the monomial <code class="docutils literal notranslate"><span class="pre">e2</span></code> divides the monomial <code class="docutils literal notranslate"><span class="pre">e1</span></code>, where
the monomials are stored using factorial representation. The array
<code class="docutils literal notranslate"><span class="pre">(prods,</span> <span class="pre">num)</span></code> should consist of <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(b_1\)</span>, <span class="math notranslate nohighlight">\(b_1\times b_2, \ldots\)</span>,
where the <span class="math notranslate nohighlight">\(b_i\)</span> are the bases of the factorial number representation.</p>
</dd></dl>

</section>
<section id="basic-manipulation">
<h2>Basic manipulation<a class="headerlink" href="#basic-manipulation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_exp_bits_required_ui">
<span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_exp_bits_required_ui</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">user_exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_exp_bits_required_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bits required to store <code class="docutils literal notranslate"><span class="pre">user_exp</span></code> in packed
format. The returned number of bits includes space for a zeroed signed bit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_exp_bits_required_ffmpz">
<span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_exp_bits_required_ffmpz</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">user_exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_exp_bits_required_ffmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bits required to store <code class="docutils literal notranslate"><span class="pre">user_exp</span></code> in packed
format. The returned number of bits includes space for a zeroed signed bit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_exp_bits_required_pfmpz">
<span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_exp_bits_required_pfmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">user_exp</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_exp_bits_required_pfmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the number of bits required to store <code class="docutils literal notranslate"><span class="pre">user_exp</span></code> in packed
format. The returned number of bits includes space for a zeroed signed bit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_max_fields_ui_sp">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_max_fields_ui_sp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">max_fields</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly_exps</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_max_fields_ui_sp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the field-wise maximum of packed exponents from <code class="docutils literal notranslate"><span class="pre">poly_exps</span></code>
of length <code class="docutils literal notranslate"><span class="pre">len</span></code> and unpack the result into <code class="docutils literal notranslate"><span class="pre">max_fields</span></code>.
The maximums are assumed to fit a ulong.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_max_fields_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_max_fields_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">max_fields</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly_exps</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_max_fields_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the field-wise maximum of packed exponents from <code class="docutils literal notranslate"><span class="pre">poly_exps</span></code>
of length <code class="docutils literal notranslate"><span class="pre">len</span></code> and unpack the result into <code class="docutils literal notranslate"><span class="pre">max_fields</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_max_degrees_tight">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_max_degrees_tight</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">max_exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prods</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_max_degrees_tight" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return an array of <code class="docutils literal notranslate"><span class="pre">num</span></code> integers corresponding to the maximum degrees
of the exponents in the array of exponent vectors <code class="docutils literal notranslate"><span class="pre">(exps,</span> <span class="pre">len)</span></code>,
assuming that the exponent are packed in a factorial representation. The
array <code class="docutils literal notranslate"><span class="pre">(prods,</span> <span class="pre">num)</span></code> should consist of <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(b_1\)</span>,
<span class="math notranslate nohighlight">\(b_1\times b_2, \ldots\)</span>, where the <span class="math notranslate nohighlight">\(b_i\)</span> are the bases of the factorial
number representation. The results are stored in the array <code class="docutils literal notranslate"><span class="pre">max_exp</span></code>,
with the entry corresponding to the most significant base of the factorial
representation first in the array.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_monomial_exists">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_monomial_exists</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">index</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly_exps</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmpmask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_monomial_exists" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns true if the given exponent vector <code class="docutils literal notranslate"><span class="pre">exp</span></code> exists in the array of
exponent vectors <code class="docutils literal notranslate"><span class="pre">(poly_exps,</span> <span class="pre">len)</span></code>, otherwise, return false. If the
exponent vector is found, its index into the array of exponent vectors is
returned. Otherwise, <code class="docutils literal notranslate"><span class="pre">index</span></code> is set to the index where this exponent
could be inserted to preserve the ordering. The index can be in the range
<code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">len]`</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_search_monomials">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_search_monomials</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">e_ind</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">e</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">e_score</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">t3</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">lower</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">upper</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">a_len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">b_len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmpmask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_search_monomials" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given packed exponent vectors <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, compute a packed
exponent <code class="docutils literal notranslate"><span class="pre">e</span></code> such that the number of monomials in the cross product
<code class="docutils literal notranslate"><span class="pre">a</span></code> X <code class="docutils literal notranslate"><span class="pre">b</span></code> that are less than or equal to <code class="docutils literal notranslate"><span class="pre">e</span></code> is between
<code class="docutils literal notranslate"><span class="pre">lower</span></code> and <code class="docutils literal notranslate"><span class="pre">upper</span></code>. This number is stored in <code class="docutils literal notranslate"><span class="pre">e_store</span></code>. If
no such monomial exists, one is chosen so that the number of monomials is as
close as possible. This function assumes that <code class="docutils literal notranslate"><span class="pre">1</span></code> is the smallest
monomial and needs three arrays <code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">t1</span></code>, and <code class="docutils literal notranslate"><span class="pre">t3</span></code> of the
size as <code class="docutils literal notranslate"><span class="pre">a</span></code> for workspace. The parameter <code class="docutils literal notranslate"><span class="pre">e_ind</span></code> is set to one
of <code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">t1</span></code>, and <code class="docutils literal notranslate"><span class="pre">t3</span></code> and gives the locations of the
monomials in <code class="docutils literal notranslate"><span class="pre">a</span></code> X <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p>
</dd></dl>

</section>
<section id="setting-and-getting-monomials">
<h2>Setting and getting monomials<a class="headerlink" href="#setting-and-getting-monomials" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_term_exp_fits_ui">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_term_exp_fits_ui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_term_exp_fits_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return whether every entry of the exponent vector of index <span class="math notranslate nohighlight">\(n\)</span> in
<code class="docutils literal notranslate"><span class="pre">exps</span></code> fits into a <code class="docutils literal notranslate"><span class="pre">ulong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_term_exp_fits_si">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_term_exp_fits_si</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_term_exp_fits_si" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return whether every entry of the exponent vector of index <span class="math notranslate nohighlight">\(n\)</span> in
<code class="docutils literal notranslate"><span class="pre">exps</span></code> fits into a <code class="docutils literal notranslate"><span class="pre">slong</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_get_monomial_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_get_monomial_ui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly_exps</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_get_monomial_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the packed exponent <code class="docutils literal notranslate"><span class="pre">poly_exps</span></code> of bit count <code class="docutils literal notranslate"><span class="pre">bits</span></code> to a
monomial from the user’s perspective. The exponents are assumed to fit
a ulong.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_get_monomial_ffmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_get_monomial_ffmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly_exps</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_get_monomial_ffmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the packed exponent <code class="docutils literal notranslate"><span class="pre">poly_exps</span></code> of bit count <code class="docutils literal notranslate"><span class="pre">bits</span></code> to a
monomial from the user’s perspective.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_get_monomial_pfmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_get_monomial_pfmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">poly_exps</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_get_monomial_pfmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the packed exponent <code class="docutils literal notranslate"><span class="pre">poly_exps</span></code> of bit count <code class="docutils literal notranslate"><span class="pre">bits</span></code> to a
monomial from the user’s perspective.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_set_monomial_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_set_monomial_ui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_set_monomial_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the user monomial <code class="docutils literal notranslate"><span class="pre">exp2</span></code> to packed format using <code class="docutils literal notranslate"><span class="pre">bits</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_set_monomial_ffmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_set_monomial_ffmpz</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_set_monomial_ffmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the user monomial <code class="docutils literal notranslate"><span class="pre">exp2</span></code> to packed format using <code class="docutils literal notranslate"><span class="pre">bits</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_set_monomial_pfmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_set_monomial_pfmpz</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_set_monomial_pfmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert the user monomial <code class="docutils literal notranslate"><span class="pre">exp2</span></code> to packed format using <code class="docutils literal notranslate"><span class="pre">bits</span></code>.</p>
</dd></dl>

</section>
<section id="packing-and-unpacking-monomials">
<h2>Packing and unpacking monomials<a class="headerlink" href="#packing-and-unpacking-monomials" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_pack_vec_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_pack_vec_ui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">nfields</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_pack_vec_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Packs a vector <code class="docutils literal notranslate"><span class="pre">exp2</span></code> into {exp1} using a bit count of <code class="docutils literal notranslate"><span class="pre">bits</span></code>.
No checking is done to ensure that the vector actually fits
into <code class="docutils literal notranslate"><span class="pre">bits</span></code> bits. The number of fields in each vector is
<code class="docutils literal notranslate"><span class="pre">nfields</span></code> and the total number of vectors to unpack is <code class="docutils literal notranslate"><span class="pre">len</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_pack_vec_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_pack_vec_fmpz</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">nfields</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_pack_vec_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Packs a vector <code class="docutils literal notranslate"><span class="pre">exp2</span></code> into {exp1} using a bit count of <code class="docutils literal notranslate"><span class="pre">bits</span></code>.
No checking is done to ensure that the vector actually fits
into <code class="docutils literal notranslate"><span class="pre">bits</span></code> bits. The number of fields in each vector is
<code class="docutils literal notranslate"><span class="pre">nfields</span></code> and the total number of vectors to unpack is <code class="docutils literal notranslate"><span class="pre">len</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_unpack_vec_ui">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_unpack_vec_ui</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">nfields</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_unpack_vec_ui" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpacks vector <code class="docutils literal notranslate"><span class="pre">exp2</span></code> of bit count <code class="docutils literal notranslate"><span class="pre">bits</span></code> into <code class="docutils literal notranslate"><span class="pre">exp1</span></code>.
The number of fields in each vector is
<code class="docutils literal notranslate"><span class="pre">nfields</span></code> and the total number of vectors to unpack is <code class="docutils literal notranslate"><span class="pre">len</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_unpack_vec_fmpz">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_unpack_vec_fmpz</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz.html#c.fmpz" title="fmpz"><span class="n"><span class="pre">fmpz</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">flint_bitcnt_t</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">nfields</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_unpack_vec_fmpz" title="Link to this definition">¶</a><br /></dt>
<dd><p>Unpacks vector <code class="docutils literal notranslate"><span class="pre">exp2</span></code> of bit count <code class="docutils literal notranslate"><span class="pre">bits</span></code> into <code class="docutils literal notranslate"><span class="pre">exp1</span></code>.
The number of fields in each vector is
<code class="docutils literal notranslate"><span class="pre">nfields</span></code> and the total number of vectors to unpack is <code class="docutils literal notranslate"><span class="pre">len</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_repack_monomials">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_repack_monomials</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exps2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#c.mpoly_ctx_t" title="mpoly_ctx_t"><span class="n"><span class="pre">mpoly_ctx_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">mctx</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_repack_monomials" title="Link to this definition">¶</a><br /></dt>
<dd><p>Convert an array of length <code class="docutils literal notranslate"><span class="pre">len</span></code> of exponents <code class="docutils literal notranslate"><span class="pre">exps2</span></code> packed
using bits <code class="docutils literal notranslate"><span class="pre">bits2</span></code> into an array <code class="docutils literal notranslate"><span class="pre">exps1</span></code> using bits <code class="docutils literal notranslate"><span class="pre">bits1</span></code>.
No checking is done to unsure that the result fits into bits <code class="docutils literal notranslate"><span class="pre">bits1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_pack_monomials_tight">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_pack_monomials_tight</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mults</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">extra</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_pack_monomials_tight" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given an array of possibly packed exponent vectors <code class="docutils literal notranslate"><span class="pre">exp2</span></code> of length
<code class="docutils literal notranslate"><span class="pre">len</span></code>, where each field of each exponent vector is packed into the
given number of bits, return the corresponding array of monomial vectors
packed using a factorial numbering scheme. The “bases” for the factorial
numbering scheme are given as an array of integers <code class="docutils literal notranslate"><span class="pre">mults</span></code>, the first
entry of which corresponds to the field of least significance in each
input exponent vector. Obviously the maximum exponent to be packed must be
less than the corresponding base in <code class="docutils literal notranslate"><span class="pre">mults</span></code>.</p>
<p>The number of multipliers is given by <code class="docutils literal notranslate"><span class="pre">num</span></code>. The code only considers
least significant <code class="docutils literal notranslate"><span class="pre">num</span></code> fields of each exponent vectors and ignores
the rest. The number of ignored fields should be passed in <code class="docutils literal notranslate"><span class="pre">extras</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_unpack_monomials_tight">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_unpack_monomials_tight</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">e1</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">e2</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mults</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">extra</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_unpack_monomials_tight" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given an array of exponent vectors <code class="docutils literal notranslate"><span class="pre">e2</span></code> of length <code class="docutils literal notranslate"><span class="pre">len</span></code> packed
using a factorial numbering scheme, unpack the monomials into an array
<code class="docutils literal notranslate"><span class="pre">e1</span></code> of exponent vectors in standard packed format, where each field
has the given number of bits. The “bases” for the factorial
numbering scheme are given as an array of integers <code class="docutils literal notranslate"><span class="pre">mults</span></code>, the first
entry of which corresponds to the field of least significance in each
exponent vector.</p>
<p>The number of multipliers is given by <code class="docutils literal notranslate"><span class="pre">num</span></code>. The code only considers
least significant <code class="docutils literal notranslate"><span class="pre">num</span></code> fields of each exponent vectors and ignores the
rest. The number of ignored fields should be passed in <code class="docutils literal notranslate"><span class="pre">extras</span></code>.</p>
</dd></dl>

</section>
<section id="chunking">
<h2>Chunking<a class="headerlink" href="#chunking" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.mpoly_main_variable_terms1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">mpoly_main_variable_terms1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">i1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n1</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">l1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">len1</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.mpoly_main_variable_terms1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given an array of exponent vectors <code class="docutils literal notranslate"><span class="pre">(exp1,</span> <span class="pre">len1)</span></code>, each exponent
vector taking one word of space, with each exponent being packed into the
given number of bits, compute <code class="docutils literal notranslate"><span class="pre">l1</span></code> starting offsets <code class="docutils literal notranslate"><span class="pre">i1</span></code> and
lengths <code class="docutils literal notranslate"><span class="pre">n1</span></code> (which may be zero) to break the exponents into chunks.
Each chunk consists of exponents have the same degree in the main variable.
The index of the main variable is given by <span class="math notranslate nohighlight">\(k\)</span>. The variables are indexed
from the variable of least significance, starting from <span class="math notranslate nohighlight">\(0\)</span>. The value
<code class="docutils literal notranslate"><span class="pre">l1</span></code> should be the degree in the main variable, plus one.</p>
</dd></dl>

</section>
<section id="chained-heap-functions">
<h2>Chained heap functions<a class="headerlink" href="#chained-heap-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c._mpoly_heap_insert">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_mpoly_heap_insert</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpoly_heap_s</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap_len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">cmpmask</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._mpoly_heap_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a heap, insert a new node <span class="math notranslate nohighlight">\(x\)</span> corresponding to the given exponent
into the heap. Heap elements are ordered by the exponent <code class="docutils literal notranslate"><span class="pre">(exp,</span> <span class="pre">N)</span></code>,
with the largest element at the head of the heap. A pointer to the current
heap length must be passed in via <code class="docutils literal notranslate"><span class="pre">heap_len</span></code>. This will be updated by
the function. Note that the index 0 position in the heap is not used, so
the length is always one greater than the number of elements.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._mpoly_heap_insert1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">_mpoly_heap_insert1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpoly_heap1_s</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap_len</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">maskhi</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._mpoly_heap_insert1" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">_mpoly_heap_insert</span></code> except that <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1</span></code>, and
<code class="docutils literal notranslate"><span class="pre">maskhi</span> <span class="pre">=</span> <span class="pre">cmpmask[0]</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._mpoly_heap_pop">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_mpoly_heap_pop</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpoly_heap_s</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap_len</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">N</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">maskhi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">masklo</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._mpoly_heap_pop" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pop the head of the heap. It is cast to a <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">*</span></code>. A pointer to the
current heap length must be passed in via <code class="docutils literal notranslate"><span class="pre">heap_len</span></code>. This will be
updated by the function. Note that the index 0 position in the heap is not
used, so the length is always one greater than the number of elements. The
<code class="docutils literal notranslate"><span class="pre">maskhi</span></code> and <code class="docutils literal notranslate"><span class="pre">masklo</span></code> values are zero except for degrevlex
ordering, where they are as per the monomial comparison operations above.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c._mpoly_heap_pop1">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">_mpoly_heap_pop1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mpoly_heap1_s</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">heap_len</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">maskhi</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c._mpoly_heap_pop1" title="Link to this definition">¶</a><br /></dt>
<dd><p>As per <code class="docutils literal notranslate"><span class="pre">_mpoly_heap_pop1</span></code> except that <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">1</span></code>, and
<code class="docutils literal notranslate"><span class="pre">maskhi</span> <span class="pre">=</span> <span class="pre">cmpmask[0]</span></code>.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a><ul>
<li><a class="reference internal" href="#orderings">Orderings</a></li>
<li><a class="reference internal" href="#monomial-arithmetic">Monomial arithmetic</a></li>
<li><a class="reference internal" href="#monomial-comparison">Monomial comparison</a></li>
<li><a class="reference internal" href="#monomial-divisibility">Monomial divisibility</a></li>
<li><a class="reference internal" href="#basic-manipulation">Basic manipulation</a></li>
<li><a class="reference internal" href="#setting-and-getting-monomials">Setting and getting monomials</a></li>
<li><a class="reference internal" href="#packing-and-unpacking-monomials">Packing and unpacking monomials</a></li>
<li><a class="reference internal" href="#chunking">Chunking</a></li>
<li><a class="reference internal" href="#chained-heap-functions">Chained heap functions</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="perm.html"
                          title="previous chapter"><strong>perm.h</strong> – permutations</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="ulong_extras.html"
                          title="next chapter"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/mpoly.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ulong_extras.html" title="ulong_extras.h – arithmetic and number-theoretic functions for single-word integers"
             >next</a> |</li>
        <li class="right" >
          <a href="perm.html" title="perm.h – permutations"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2018, The Flint development team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>