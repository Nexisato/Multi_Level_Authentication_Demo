<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>qsieve.h – Quadratic sieve &#8212; Flint 2.9.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    
    <script src="_static/documentation_options.js?v=182a64a0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="fmpq.h – rational numbers" href="fmpq.html" />
    <link rel="prev" title="fft.h – Schoenhage-Strassen FFT" href="fft.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fmpq.html" title="fmpq.h – rational numbers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fft.html" title="fft.h – Schoenhage-Strassen FFT"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>qsieve.h</strong> – Quadratic sieve</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="qsieve-h-quadratic-sieve">
<span id="qsieve"></span><h1><strong>qsieve.h</strong> – Quadratic sieve<a class="headerlink" href="#qsieve-h-quadratic-sieve" title="Link to this heading">¶</a></h1>
<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_knuth_schroeppel">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_knuth_schroeppel</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_knuth_schroeppel" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the Knuth-Schroeppel multiplier for the <span class="math notranslate nohighlight">\(n\)</span>, integer to be factored
based upon the Knuth-Schroeppel function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_primes_init">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_primes_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_primes_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compute the factor base prime along with there inverse for <span class="math notranslate nohighlight">\(kn\)</span>, where <span class="math notranslate nohighlight">\(k\)</span>
is Knuth-Schroeppel multiplier and <span class="math notranslate nohighlight">\(n\)</span> is the integer to be factored. It
also computes the square root of <span class="math notranslate nohighlight">\(kn\)</span> modulo factor base primes.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_primes_increment">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_primes_increment</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">delta</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_primes_increment" title="Link to this definition">¶</a><br /></dt>
<dd><p>It increase the number of factor base primes by amount ‘delta’ and
calculate inverse of those primes along with the square root of <span class="math notranslate nohighlight">\(kn\)</span> modulo
those primes.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_init_A0">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_init_A0</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_init_A0" title="Link to this definition">¶</a><br /></dt>
<dd><p>First it chooses the possible range of factor of <span class="math notranslate nohighlight">\(A _0\)</span>, based on the number
of bits in optimal value of <span class="math notranslate nohighlight">\(A _0\)</span>. It tries to select range such that we have
plenty of primes to choose from as well as number of factor in <span class="math notranslate nohighlight">\(A _0\)</span> are
sufficient. For input of size less than 130 bit, this selection method doesn’t
work therefore we randomly generate 2 or 3-subset of all the factor base prime
as the factor of <span class="math notranslate nohighlight">\(A _0\)</span>.
Otherwise, if we have to select <span class="math notranslate nohighlight">\(s\)</span> factor for <span class="math notranslate nohighlight">\(A _0\)</span>, we generate <span class="math notranslate nohighlight">\(s - 1\)</span>-
subset from odd indices of the possible range of factor and then search last
factor using binary search from the even indices of possible range of factor
such that value of <span class="math notranslate nohighlight">\(A _0\)</span> is close to it’s optimal value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_next_A0">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_next_A0</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_next_A0" title="Link to this definition">¶</a><br /></dt>
<dd><p>Find next candidate for <span class="math notranslate nohighlight">\(A _0\)</span> as follows:
generate next lexicographic <span class="math notranslate nohighlight">\(s - 1\)</span>-subset from the odd indices of possible
range of factor base and choose the last factor from even indices using binary
search so that value <span class="math notranslate nohighlight">\(A _0\)</span> is close to it’s optimal value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_compute_pre_data">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_compute_pre_data</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_compute_pre_data" title="Link to this definition">¶</a><br /></dt>
<dd><p>Precompute all the data associated with factor’s of <span class="math notranslate nohighlight">\(A _0\)</span>, since <span class="math notranslate nohighlight">\(A _0\)</span> is going
to be fixed for several <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_init_poly_first">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_init_poly_first</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_init_poly_first" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initializes the value of <span class="math notranslate nohighlight">\(A = q _0 * A _0\)</span>, where <span class="math notranslate nohighlight">\(q _0\)</span> is non-factor base prime.
precompute the data necessary for generating different <span class="math notranslate nohighlight">\(B\)</span> value using grey code
formula. Combine the data calculated for the factor of <span class="math notranslate nohighlight">\(A _0\)</span> along with the
parameter <span class="math notranslate nohighlight">\(q _0\)</span> to obtain data as for factor of <span class="math notranslate nohighlight">\(A\)</span>. It also calculates the sieve
offset for all the factor base prime, for first polynomial.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_init_poly_next">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_init_poly_next</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_init_poly_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>Generate next polynomial or next <span class="math notranslate nohighlight">\(B\)</span> value for particular <span class="math notranslate nohighlight">\(A\)</span> and also updates the
sieve offsets for all the factor base prime, for this <span class="math notranslate nohighlight">\(B\)</span> value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_compute_C">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_compute_C</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_compute_C" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span>, calculate <span class="math notranslate nohighlight">\(C = (B ^2 - A) / N\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_do_sieving">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_do_sieving</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sieve</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_do_sieving" title="Link to this definition">¶</a><br /></dt>
<dd><p>First initialize the sieve array to zero, then for each <span class="math notranslate nohighlight">\(p \in\)</span> <code class="docutils literal notranslate"><span class="pre">factor</span> <span class="pre">base</span></code>, add
<span class="math notranslate nohighlight">\(\log_2(p)\)</span> to the locations <span class="math notranslate nohighlight">\(\operatorname{soln1} _p + i * p\)</span> and <span class="math notranslate nohighlight">\(\operatorname{soln2} _p + i * p\)</span> for
<span class="math notranslate nohighlight">\(i = 0, 1, 2,\dots\)</span>, where <span class="math notranslate nohighlight">\(\operatorname{soln1} _p\)</span> and <span class="math notranslate nohighlight">\(\operatorname{soln2} _p\)</span> are the sieve offsets calculated
for <span class="math notranslate nohighlight">\(p\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_do_sieving2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_do_sieving2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_do_sieving2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Perform the same task as above but instead of sieving over whole array at once divide
the array in blocks and then sieve over each block for all the primes in factor base.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_evaluate_candidate">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_evaluate_candidate</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sieve</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_evaluate_candidate" title="Link to this definition">¶</a><br /></dt>
<dd><p>For location <span class="math notranslate nohighlight">\(i\)</span> in sieve array value at which, is greater than sieve threshold, check
the value of <span class="math notranslate nohighlight">\(Q(x)\)</span> at position <span class="math notranslate nohighlight">\(i\)</span> for smoothness. If value is found to be smooth then
store it for later processing, else check the residue for the partial if it is found to
be partial then store it for late processing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_evaluate_sieve">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_evaluate_sieve</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sieve</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_evaluate_sieve" title="Link to this definition">¶</a><br /></dt>
<dd><p>Scan the sieve array for location at, which accumulated value is greater than sieve
threshold.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_collect_relations">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_collect_relations</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sieve</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_collect_relations" title="Link to this definition">¶</a><br /></dt>
<dd><p>Call for initialization of polynomial, sieving, and scanning of sieve
for all the possible polynomials for particular hypercube i.e. <span class="math notranslate nohighlight">\(A\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_write_to_file">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_write_to_file</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">prime</span></span>, <a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">Y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_write_to_file" title="Link to this definition">¶</a><br /></dt>
<dd><p>Write a relation to the file. Format is as follows,
first write large prime, in case of full relation it is 1, then write exponent
of small primes, then write number of factor followed by offset of factor in
factor base and their exponent and at last value of <span class="math notranslate nohighlight">\(Q(x)\)</span> for particular relation.
each relation is written in new line.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_get_table_entry">
<span class="n"><span class="pre">hash_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_get_table_entry</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">prime</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_get_table_entry" title="Link to this definition">¶</a><br /></dt>
<dd><p>Return the pointer to the location of ‘prime’ is hash table if it exist, else
create and entry for it in hash table and return pointer to that.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_add_to_hashtable">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_add_to_hashtable</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">prime</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_add_to_hashtable" title="Link to this definition">¶</a><br /></dt>
<dd><p>Add ‘prime’ to the hast table.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_parse_relation">
<span class="n"><span class="pre">relation_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_parse_relation</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">str</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_parse_relation" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a string representation of relation from the file, parse it to obtain
all the parameters of relation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_merge_relation">
<span class="n"><span class="pre">relation_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_merge_relation</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="n"><span class="pre">relation_t</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">relation_t</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_merge_relation" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given two partial relation having same large prime, merge them to obtain a full
relation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_compare_relation">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_compare_relation</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_compare_relation" title="Link to this definition">¶</a><br /></dt>
<dd><p>Compare two relation based on, first large prime, then number of factor and then
offsets of factor in factor base.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_remove_duplicates">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_remove_duplicates</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">relation_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rel_list</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num_relations</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_remove_duplicates" title="Link to this definition">¶</a><br /></dt>
<dd><p>Remove duplicate from given list of relations by sorting relations in the list.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_insert_relation2">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_insert_relation2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span>, <span class="n"><span class="pre">relation_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">rel_list</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">num_relations</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_insert_relation2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Given a list of relations, insert each relation from the list into the matrix for
further processing.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_process_relation">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_process_relation</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">qs_t</span></span><span class="w"> </span><span class="n"><span class="pre">qs_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_process_relation" title="Link to this definition">¶</a><br /></dt>
<dd><p>After we have accumulated required number of relations, first process the file by
reading all the relations, removes singleton. Then merge all the possible partial
to obtain full relations.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.qsieve_factor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">qsieve_factor</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="fmpz_factor.html#c.fmpz_factor_t" title="fmpz_factor_t"><span class="n"><span class="pre">fmpz_factor_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">factors</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.qsieve_factor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Factor <span class="math notranslate nohighlight">\(n\)</span> using the quadratic sieve method. It is required that <span class="math notranslate nohighlight">\(n\)</span> is not a
prime and not a perfect power. There is no guarantee that the factors found will
be prime, or distinct.</p>
</dd></dl>

</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="fft.html"
                          title="previous chapter"><strong>fft.h</strong> – Schoenhage-Strassen FFT</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="fmpq.html"
                          title="next chapter"><strong>fmpq.h</strong> – rational numbers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/qsieve.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fmpq.html" title="fmpq.h – rational numbers"
             >next</a> |</li>
        <li class="right" >
          <a href="fft.html" title="fft.h – Schoenhage-Strassen FFT"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>qsieve.h</strong> – Quadratic sieve</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2018, The Flint development team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>