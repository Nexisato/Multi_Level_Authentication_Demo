<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>ulong_extras.h – arithmetic and number-theoretic functions for single-word integers &#8212; Flint 2.9.0 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    
    <script src="_static/documentation_options.js?v=182a64a0"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <script src="_static/sidebar.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="fmpz.h – integers" href="fmpz.html" />
    <link rel="prev" title="mpoly.h – support functions for multivariate polynomials" href="mpoly.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="fmpz.html" title="fmpz.h – integers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="mpoly.html" title="mpoly.h – support functions for multivariate polynomials"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="ulong-extras-h-arithmetic-and-number-theoretic-functions-for-single-word-integers">
<span id="ulong-extras"></span><h1><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers<a class="headerlink" href="#ulong-extras-h-arithmetic-and-number-theoretic-functions-for-single-word-integers" title="Link to this heading">¶</a></h1>
<section id="random-functions">
<h2>Random functions<a class="headerlink" href="#random-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_randlimb">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randlimb</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randlimb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random limb.</p>
<p>The algorithm generates two random half limbs <span class="math notranslate nohighlight">\(s_j\)</span>, <span class="math notranslate nohighlight">\(j = 0, 1\)</span>,
by iterating respectively <span class="math notranslate nohighlight">\(v_{i+1} = (v_i a + b) \bmod{p_j}\)</span> for
some initial seed <span class="math notranslate nohighlight">\(v_0\)</span>, randomly chosen values <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> and
<code class="docutils literal notranslate"><span class="pre">p_0</span> <span class="pre">=</span> <span class="pre">4294967311</span> <span class="pre">=</span> <span class="pre">nextprime(2^32)</span></code> on a 64-bit machine
and <code class="docutils literal notranslate"><span class="pre">p_0</span> <span class="pre">=</span> <span class="pre">nextprime(2^16)</span></code> on a 32-bit machine and
<code class="docutils literal notranslate"><span class="pre">p_1</span> <span class="pre">=</span> <span class="pre">nextprime(p_0)</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randbits">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randbits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">unsigned</span></span><span class="w"> </span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randbits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random number with the given number of
bits. The most significant bit is always set, unless zero is passed,
in which case zero is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest_bits">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest_bits</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest_bits" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random number with the given number of
bits. The most significant bit is always set, unless zero is passed,
in which case zero is returned. The probability of a value with a
sparse binary representation being returned is increased. This
function is intended for use in test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randint">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randint</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random number up to but not including
the given limit. If zero is passed as a parameter, an entire random
limb is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_urandint">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_urandint</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_urandint" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a uniformly pseudo random number up to but not including
the given limit. If zero is passed as a parameter, an entire
random limb is returned. This function provides somewhat better
randomness as compared to <a class="reference internal" href="#c.n_randint" title="n_randint"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_randint()</span></code></a>, especially for larger
values of limit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pseudo random number with a random number of bits,
from <span class="math notranslate nohighlight">\(0\)</span> to <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.  The probability of the special
values <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, <code class="docutils literal notranslate"><span class="pre">COEFF_MAX</span></code> and <code class="docutils literal notranslate"><span class="pre">WORD_MAX</span></code> is increased
as is the probability of a value with sparse binary representation.
This random function is mainly used for testing purposes.
This function is intended for use in test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest_not_zero">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest_not_zero</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest_not_zero" title="Link to this definition">¶</a><br /></dt>
<dd><p>As for <a class="reference internal" href="#c.n_randtest" title="n_randtest"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_randtest()</span></code></a>, but does not return <span class="math notranslate nohighlight">\(0\)</span>.
This function is intended for use in test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randprime">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randprime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">bits</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a random prime number <code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">1)</span></code> or probable prime
<code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">0)</span></code>
with <code class="docutils literal notranslate"><span class="pre">bits</span></code> bits, where <code class="docutils literal notranslate"><span class="pre">bits</span></code> must be at least 2 and
at most <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_randtest_prime">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_randtest_prime</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_randtest_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a random prime number <code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">1)</span></code> or probable
prime <code class="docutils literal notranslate"><span class="pre">(proved</span> <span class="pre">=</span> <span class="pre">0)</span></code>
with size randomly chosen between 2 and <code class="docutils literal notranslate"><span class="pre">FLINT_BITS</span></code> bits.
This function is intended for use in test code.</p>
</dd></dl>

</section>
<section id="basic-arithmetic">
<h2>Basic arithmetic<a class="headerlink" href="#basic-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_pow">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_pow</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">n^exp</span></code>. No checking is done for overflow. The exponent
may be zero. We define <span class="math notranslate nohighlight">\(0^0 = 1\)</span>.</p>
<p>The algorithm simply uses a for loop. Repeated squaring is
unlikely to speed up this algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_flog">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_flog</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_flog" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lfloor\log_b n\rfloor\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(n \geq 1\)</span> and <span class="math notranslate nohighlight">\(b \geq 2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_clog">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_clog</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_clog" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lceil\log_b n\rceil\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(n \geq 1\)</span> and <span class="math notranslate nohighlight">\(b \geq 2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_clog_2exp">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_clog_2exp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_clog_2exp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(\lceil\log_b 2^n\rceil\)</span>.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(b \geq 2\)</span>.</p>
</dd></dl>

</section>
<section id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_revbin">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_revbin</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_revbin" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the binary reverse of <span class="math notranslate nohighlight">\(n\)</span>, assuming it is <span class="math notranslate nohighlight">\(b\)</span> bits in length,
e.g. <code class="docutils literal notranslate"><span class="pre">n_revbin(10110,</span> <span class="pre">6)</span></code> will return <code class="docutils literal notranslate"><span class="pre">110100</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sizeinbase">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sizeinbase</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">base</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sizeinbase" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the exact number of digits needed to represent <span class="math notranslate nohighlight">\(n\)</span> as a
string in base <code class="docutils literal notranslate"><span class="pre">base</span></code> assumed to be between 2 and 36.
Returns 1 when <span class="math notranslate nohighlight">\(n = 0\)</span>.</p>
</dd></dl>

</section>
<section id="basic-arithmetic-with-precomputed-inverses">
<h2>Basic arithmetic with precomputed inverses<a class="headerlink" href="#basic-arithmetic-with-precomputed-inverses" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_preinvert_limb">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_preinvert_limb</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_preinvert_limb" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>, as defined in <a class="reference internal" href="references.html#gramol2010" id="id1"><span>[GraMol2010]</span></a>.
This precomputed inverse can be used with all of the functions that
take a precomputed inverse whose names are suffixed by <code class="docutils literal notranslate"><span class="pre">_preinv</span></code>.</p>
<p>We require <span class="math notranslate nohighlight">\(n &gt; 0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_precompute_inverse">
<span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_precompute_inverse</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_precompute_inverse" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> with double precision value <span class="math notranslate nohighlight">\(1/n\)</span>.
This precomputed inverse can be used with all of the functions that
take a precomputed inverse whose names are suffixed by <code class="docutils literal notranslate"><span class="pre">_precomp</span></code>.</p>
<p>We require <span class="math notranslate nohighlight">\(n &gt; 0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mod_precomp">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mod_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mod_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^FLINT_D_BITS</span></code>
and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">2^(FLINT_BITS-1)</span></code> and <span class="math notranslate nohighlight">\(0 \leq a &lt; n^2\)</span>.</p>
<p>We assume the processor is in the standard round to nearest
mode. Thus <code class="docutils literal notranslate"><span class="pre">ninv</span></code> is correct to <span class="math notranslate nohighlight">\(53\)</span> binary bits, the least
significant bit of which we shall call a place, and can be at most
half a place out. When <span class="math notranslate nohighlight">\(a\)</span> is multiplied by <span class="math notranslate nohighlight">\(ninv\)</span>, the binary
representation of <span class="math notranslate nohighlight">\(a\)</span> is exact and the mantissa is less than <span class="math notranslate nohighlight">\(2\)</span>, thus we
see that <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">ninv</span></code> can be at most one out in the mantissa. We now
truncate <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">ninv</span></code> to the nearest integer, which is always a round
down. Either we already have an integer, or we need to make a change down
of at least <span class="math notranslate nohighlight">\(1\)</span> in the last place. In the latter case we either get
precisely the exact quotient or below it as when we rounded the
product to the nearest place we changed by at most half a place.
In the case that truncating to an integer takes us below the
exact quotient, we have rounded down by less than <span class="math notranslate nohighlight">\(1\)</span> plus half a
place. But as the product is less than <span class="math notranslate nohighlight">\(n\)</span> and <span class="math notranslate nohighlight">\(n\)</span> is less than <span class="math notranslate nohighlight">\(2^{53}\)</span>,
half a place is less than <span class="math notranslate nohighlight">\(1\)</span>, thus we are out by less than <span class="math notranslate nohighlight">\(2\)</span> from
the exact quotient, i.e.the quotient we have computed is the
quotient we are after or one too small. That leaves only the case
where we had to round up to the nearest place which happened to
be an integer, so that truncating to an integer didn’t change
anything. But this implies that the exact quotient <span class="math notranslate nohighlight">\(a/n\)</span> is less
than <span class="math notranslate nohighlight">\(2^{-54}\)</span> from an integer. We deal with this rare case by
subtracting 1 from the quotient. Then the quotient we have computed is
either exactly what we are after, or one too small.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mod2_precomp">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mod2_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mod2_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span> or
on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>As for <a class="reference internal" href="#c.n_mod_precomp" title="n_mod_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod_precomp()</span></code></a> for <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span> and <span class="math notranslate nohighlight">\(a &lt; n^2\)</span> the
computed quotient is either what we are after or one too large or small.
We deal with these cases. Otherwise we can be sure that the
top <span class="math notranslate nohighlight">\(52\)</span> bits of the quotient are computed correctly. We take
the remainder and adjust the quotient by multiplying the
remainder by <code class="docutils literal notranslate"><span class="pre">ninv</span></code> to compute another approximate quotient as
per <code class="xref c c-func docutils literal notranslate"><span class="pre">mod_precomp()</span></code>. Now the remainder may be either
negative or positive, so the quotient we compute may be one
out in either direction.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_divrem2_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divrem2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divrem2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> and sets <span class="math notranslate nohighlight">\(q\)</span> to the quotient of <span class="math notranslate nohighlight">\(a\)</span> by <span class="math notranslate nohighlight">\(n\)</span>, given a
precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are
no restrictions on <span class="math notranslate nohighlight">\(a\)</span> and the only restriction on <span class="math notranslate nohighlight">\(n\)</span> is that it be
nonzero.</p>
<p>This uses the algorithm of Granlund and M&quot;oller <a class="reference internal" href="references.html#gramol2010" id="id2"><span>[GraMol2010]</span></a>. First
<span class="math notranslate nohighlight">\(n\)</span> is normalised and <span class="math notranslate nohighlight">\(a\)</span> is shifted into two limbs to compensate. Then
their algorithm is applied verbatim and the remainder shifted back.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_div2_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_div2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_div2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the Euclidean quotient of <span class="math notranslate nohighlight">\(a\)</span> by <span class="math notranslate nohighlight">\(n\)</span> given a precomputed inverse of
<span class="math notranslate nohighlight">\(n\)</span> computed by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>
and the only restriction on <span class="math notranslate nohighlight">\(n\)</span> is that it be nonzero.</p>
<p>This uses the algorithm of Granlund and M&quot;oller <a class="reference internal" href="references.html#gramol2010" id="id3"><span>[GraMol2010]</span></a>. First
<span class="math notranslate nohighlight">\(n\)</span> is normalised and <span class="math notranslate nohighlight">\(a\)</span> is shifted into two limbs to compensate. Then
their algorithm is applied verbatim.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mod2_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mod2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span> and the only
restriction on <span class="math notranslate nohighlight">\(n\)</span> is that it be nonzero.</p>
<p>This uses the algorithm of Granlund and M&quot;oller <a class="reference internal" href="references.html#gramol2010" id="id4"><span>[GraMol2010]</span></a>. First
<span class="math notranslate nohighlight">\(n\)</span> is normalised and <span class="math notranslate nohighlight">\(a\)</span> is shifted into two limbs to compensate. Then
their algorithm is applied verbatim and the result shifted back.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_divrem2_precomp">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divrem2_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divrem2_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a> and sets <span class="math notranslate nohighlight">\(q\)</span> to the quotient. There
are no restrictions on <span class="math notranslate nohighlight">\(a\)</span> or on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>This is as for <a class="reference internal" href="#c.n_mod2_precomp" title="n_mod2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod2_precomp()</span></code></a> with some additional care taken
to retain the quotient information. There are also special
cases to deal with the case where <span class="math notranslate nohighlight">\(a\)</span> is already reduced modulo
<span class="math notranslate nohighlight">\(n\)</span> and where <span class="math notranslate nohighlight">\(n\)</span> is <span class="math notranslate nohighlight">\(64\)</span> bits and <span class="math notranslate nohighlight">\(a\)</span> is not reduced modulo <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_ll_mod_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_ll_mod_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a_hi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a_lo</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_ll_mod_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>, which
will be two limbs <code class="docutils literal notranslate"><span class="pre">(a_hi,</span> <span class="pre">a_lo)</span></code>, or on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>The old version of this function merely reduced the top limb
<code class="docutils literal notranslate"><span class="pre">a_hi</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span> so that <a class="reference internal" href="longlong.html#c.udiv_qrnnd_preinv" title="udiv_qrnnd_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">udiv_qrnnd_preinv()</span></code></a> could
be used.</p>
<p>The new version reduces the top limb modulo <span class="math notranslate nohighlight">\(n\)</span> as per
<a class="reference internal" href="#c.n_mod2_preinv" title="n_mod2_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod2_preinv()</span></code></a> and then the algorithm of Granlund and
M&quot;oller <a class="reference internal" href="references.html#gramol2010" id="id5"><span>[GraMol2010]</span></a> is used again to reduce modulo <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_lll_mod_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_lll_mod_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a_hi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a_mi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a_lo</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_lll_mod_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a \bmod{n}\)</span>, where <span class="math notranslate nohighlight">\(a\)</span> has three limbs <code class="docutils literal notranslate"><span class="pre">(a_hi,</span> <span class="pre">a_mi,</span> <span class="pre">a_lo)</span></code>,
given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>.
It is assumed that <code class="docutils literal notranslate"><span class="pre">a_hi</span></code> is reduced modulo <span class="math notranslate nohighlight">\(n\)</span>. There are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>This function uses the algorithm of Granlund and
M&quot;oller <a class="reference internal" href="references.html#gramol2010" id="id6"><span>[GraMol2010]</span></a> to first reduce the top two limbs
modulo <span class="math notranslate nohighlight">\(n\)</span>, then does the same on the bottom two limbs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_precomp">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>
computed by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^FLINT_D_BITS</span></code> and <span class="math notranslate nohighlight">\(0 \leq a, b &lt; n\)</span>.</p>
<p>We assume the processor is in the standard round to nearest
mode. Thus <code class="docutils literal notranslate"><span class="pre">ninv</span></code> is correct to <span class="math notranslate nohighlight">\(53\)</span> binary bits, the least
significant bit of which we shall call a place, and can be at most half
a place out. The product of <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> is computed with error at most
half a place. When <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">b</span></code> is multiplied by <span class="math notranslate nohighlight">\(ninv\)</span> we find that the
exact quotient and computed quotient differ by less than two places. As
the quotient is less than <span class="math notranslate nohighlight">\(n\)</span> this means that the exact quotient is at
most <span class="math notranslate nohighlight">\(1\)</span> away from the computed quotient. We truncate this quotient to
an integer which reduces the value by less than <span class="math notranslate nohighlight">\(1\)</span>. We end up with a
value which can be no more than two above the quotient we are after and
no less than two below. However an argument similar to that for
<a class="reference internal" href="#c.n_mod_precomp" title="n_mod_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mod_precomp()</span></code></a> shows that the truncated computed quotient cannot
be two smaller than the truncated exact quotient. In other words the
computed integer quotient is at most two above and one below the quotient
we are after.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod2_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \bmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> or
on <span class="math notranslate nohighlight">\(n\)</span>. This is implemented by multiplying using <a class="reference internal" href="longlong.html#c.umul_ppmm" title="umul_ppmm"><code class="xref c c-func docutils literal notranslate"><span class="pre">umul_ppmm()</span></code></a> and
then reducing using <a class="reference internal" href="#c.n_ll_mod_preinv" title="n_ll_mod_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_ll_mod_preinv()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod2">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \bmod{n}\)</span>. There are no restrictions on <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> or
on <span class="math notranslate nohighlight">\(n\)</span>. This is implemented by multiplying using <a class="reference internal" href="longlong.html#c.umul_ppmm" title="umul_ppmm"><code class="xref c c-func docutils literal notranslate"><span class="pre">umul_ppmm()</span></code></a> and
then reducing using <a class="reference internal" href="#c.n_ll_mod_preinv" title="n_ll_mod_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_ll_mod_preinv()</span></code></a> after computing a precomputed
inverse.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">norm</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(a b \pmod{n}\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed by
<a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>, assuming <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> are reduced modulo <span class="math notranslate nohighlight">\(n\)</span>
and <span class="math notranslate nohighlight">\(n\)</span> is normalised, i.e. with most significant bit set. There are
no other restrictions on <span class="math notranslate nohighlight">\(a\)</span>, <span class="math notranslate nohighlight">\(b\)</span> or <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>The value <code class="docutils literal notranslate"><span class="pre">norm</span></code> is provided for convenience. As <span class="math notranslate nohighlight">\(n\)</span> is required
to be normalised, it may be that <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> have been shifted to the
left by <code class="docutils literal notranslate"><span class="pre">norm</span></code> bits before calling the function. Their product
then has an extra factor of <span class="math notranslate nohighlight">\(2^\text{norm}\)</span>. Specifying a nonzero
<code class="docutils literal notranslate"><span class="pre">norm</span></code> will shift the product right by this many bits before
reducing it.</p>
<p>The algorithm use is that of Granlund and M&quot;oller <a class="reference internal" href="references.html#gramol2010" id="id7"><span>[GraMol2010]</span></a>.</p>
</dd></dl>

</section>
<section id="greatest-common-divisor">
<h2>Greatest common divisor<a class="headerlink" href="#greatest-common-divisor" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_gcd">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_gcd</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_gcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the greatest common divisor <span class="math notranslate nohighlight">\(g\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>. No assumptions
are made about the values <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span>.</p>
<p>This function wraps GMP’s <code class="docutils literal notranslate"><span class="pre">mpn_gcd_1</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_gcdinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_gcdinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_gcdinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the greatest common divisor <span class="math notranslate nohighlight">\(g\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> and computes
<span class="math notranslate nohighlight">\(a\)</span> such that <span class="math notranslate nohighlight">\(0 \leq a &lt; y\)</span> and <span class="math notranslate nohighlight">\(a x = \gcd(x, y) \bmod{y}\)</span>, when
this is defined. We require <span class="math notranslate nohighlight">\(x &lt; y\)</span>.</p>
<p>When <span class="math notranslate nohighlight">\(y = 1\)</span> the greatest common divisor is set to <span class="math notranslate nohighlight">\(1\)</span> and <span class="math notranslate nohighlight">\(a\)</span> is
set to <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>This is merely an adaption of the extended Euclidean algorithm
computing just one cofactor and reducing it modulo <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_xgcd">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_xgcd</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_xgcd" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the greatest common divisor <span class="math notranslate nohighlight">\(g\)</span> of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> and unsigned
values <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> such that <span class="math notranslate nohighlight">\(a x - b y = g\)</span>. We require <span class="math notranslate nohighlight">\(x \geq y\)</span>.</p>
<p>We claim that computing the extended greatest common divisor via the
Euclidean algorithm always results in cofactor <span class="math notranslate nohighlight">\(\lvert a \rvert &lt; x/2\)</span>,
<span class="math notranslate nohighlight">\(\lvert b\rvert &lt; x/2\)</span>, with perhaps some small degenerate exceptions.</p>
<p>We proceed by induction.</p>
<p>Suppose we are at some step of the algorithm, with <span class="math notranslate nohighlight">\(x_n = q y_n + r\)</span>
with <span class="math notranslate nohighlight">\(r \geq 1\)</span>, and suppose <span class="math notranslate nohighlight">\(1 = s y_n - t r\)</span> with
<span class="math notranslate nohighlight">\(s &lt; y_n / 2\)</span>, <span class="math notranslate nohighlight">\(t &lt; y_n / 2\)</span> by hypothesis.</p>
<p>Write <span class="math notranslate nohighlight">\(1 = s y_n - t (x_n - q y_n) = (s + t q) y_n - t x_n\)</span>.</p>
<p>It suffices to show that <span class="math notranslate nohighlight">\((s + t q) &lt; x_n / 2\)</span> as <span class="math notranslate nohighlight">\(t &lt; y_n / 2 &lt; x_n / 2\)</span>,
which will complete the induction step.</p>
<p>But at the previous step in the backsubstitution we would have had
<span class="math notranslate nohighlight">\(1 = s r - c d\)</span> with <span class="math notranslate nohighlight">\(s &lt; r/2\)</span> and <span class="math notranslate nohighlight">\(c &lt; r/2\)</span>.</p>
<p>Then <span class="math notranslate nohighlight">\(s + t q &lt; r/2 + y_n / 2 q = (r + q y_n)/2 = x_n / 2\)</span>.</p>
<p>See the documentation of <a class="reference internal" href="#c.n_gcd" title="n_gcd"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_gcd()</span></code></a> for a description of the
branching in the algorithm, which is faster than using division.</p>
</dd></dl>

</section>
<section id="jacobi-and-kronecker-symbols">
<h2>Jacobi and Kronecker symbols<a class="headerlink" href="#jacobi-and-kronecker-symbols" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_jacobi">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_jacobi</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_signed_t</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_jacobi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Jacobi symbol <span class="math notranslate nohighlight">\(\left(\frac{x}{y}\right)\)</span> for any x and odd <span class="math notranslate nohighlight">\(y\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_jacobi_unsigned">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_jacobi_unsigned</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_jacobi_unsigned" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Jacobi symbol, allowing <span class="math notranslate nohighlight">\(x\)</span> to go up to a full limb.</p>
</dd></dl>

</section>
<section id="modular-arithmetic">
<h2>Modular Arithmetic<a class="headerlink" href="#modular-arithmetic" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_addmod">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_addmod</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_addmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\((a + b) \bmod{n}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_submod">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_submod</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_submod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\((a - b) \bmod{n}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_invmod">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_invmod</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">y</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_invmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the inverse of <span class="math notranslate nohighlight">\(x\)</span> modulo <span class="math notranslate nohighlight">\(y\)</span>, if it exists. Otherwise an exception
is thrown.</p>
<p>This is merely an adaption of the extended Euclidean algorithm
with appropriate normalisation.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod_precomp">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">mp_limb_signed_t</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">a^exp</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>
computed by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span>
and <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>. There are no restrictions on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e.
it can be negative.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod_ui_precomp">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod_ui_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod_ui_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">a^exp</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span>
computed by <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>. We require <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span>
and <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>. The exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> is unsigned and so
can be larger than allowed by <a class="reference internal" href="#c.n_powmod_precomp" title="n_powmod_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_powmod_precomp()</span></code></a>.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">mp_limb_signed_t</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">a^exp</span></code> modulo <span class="math notranslate nohighlight">\(n\)</span>. We require <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">&lt;</span> <span class="pre">2^FLINT_D_BITS</span></code>
and <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>. There are no restrictions on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e.it can be negative.</p>
<p>This is implemented by precomputing an inverse and calling the
<code class="docutils literal notranslate"><span class="pre">precomp</span></code> version of this function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">mp_limb_signed_t</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span> or on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e.it can be negative.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exp</span></code> is negative but <span class="math notranslate nohighlight">\(a\)</span> is not invertible modulo <span class="math notranslate nohighlight">\(n\)</span>, an
exception is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">mp_limb_signed_t</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are
no restrictions on <span class="math notranslate nohighlight">\(n\)</span> or on <code class="docutils literal notranslate"><span class="pre">exp</span></code>, i.e.it can be negative.</p>
<p>This is implemented by precomputing an inverse limb and calling the
<code class="docutils literal notranslate"><span class="pre">preinv</span></code> version of this function.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">exp</span></code> is negative but <span class="math notranslate nohighlight">\(a\)</span> is not invertible modulo <span class="math notranslate nohighlight">\(n\)</span>, an
exception is raised.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2_ui_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2_ui_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2_ui_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span>. The exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> is unsigned and so can be
larger than allowed by <a class="reference internal" href="#c.n_powmod2_preinv" title="n_powmod2_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_powmod2_preinv()</span></code></a>.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_powmod2_fmpz_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_powmod2_fmpz_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="fmpz.html#c.fmpz_t" title="fmpz_t"><span class="n"><span class="pre">fmpz_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_powmod2_fmpz_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">(a^exp)</span> <span class="pre">%</span> <span class="pre">n</span></code> given a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. We require <span class="math notranslate nohighlight">\(0 \leq a &lt; n\)</span>, but there are no
restrictions on <span class="math notranslate nohighlight">\(n\)</span>. The exponent <code class="docutils literal notranslate"><span class="pre">exp</span></code> must not be negative.</p>
<p>This is implemented as a standard binary powering algorithm using
repeated squaring and reducing modulo <span class="math notranslate nohighlight">\(n\)</span> at each step.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmod">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmod</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmod" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(p\)</span> is prime, compute a square root of <span class="math notranslate nohighlight">\(a\)</span> modulo <span class="math notranslate nohighlight">\(p\)</span> if <span class="math notranslate nohighlight">\(a\)</span> is a
quadratic residue modulo <span class="math notranslate nohighlight">\(p\)</span>, otherwise return <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(p\)</span> is not prime the result is with high probability <span class="math notranslate nohighlight">\(0\)</span>, indicating
that <span class="math notranslate nohighlight">\(p\)</span> is not prime, or <span class="math notranslate nohighlight">\(a\)</span> is not a square modulo <span class="math notranslate nohighlight">\(p\)</span>. Otherwise the
result is meaningless.</p>
<p>Assumes that <span class="math notranslate nohighlight">\(a\)</span> is reduced modulo <span class="math notranslate nohighlight">\(p\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmod_2pow">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmod_2pow</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqrt</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmod_2pow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes all the square roots of <code class="docutils literal notranslate"><span class="pre">a</span></code> modulo <code class="docutils literal notranslate"><span class="pre">2^exp</span></code>. The roots
are stored in an array which is created and whose address is stored in
the location pointed to by <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>. The array of roots is allocated
by the function but must be cleaned up by the user by calling
<code class="docutils literal notranslate"><span class="pre">flint_free</span></code>. The number of roots is returned by the function. If
<code class="docutils literal notranslate"><span class="pre">a</span></code> is not a quadratic residue modulo <code class="docutils literal notranslate"><span class="pre">2^exp</span></code> then 0 is
returned by the function and the location <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> points to is set to
NULL.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmod_primepow">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmod_primepow</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqrt</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmod_primepow" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes all the square roots of <code class="docutils literal notranslate"><span class="pre">a</span></code> modulo <code class="docutils literal notranslate"><span class="pre">p^exp</span></code>. The roots
are stored in an array which is created and whose address is stored in
the location pointed to by <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>. The array of roots is allocated
by the function but must be cleaned up by the user by calling
<code class="docutils literal notranslate"><span class="pre">flint_free</span></code>. The number of roots is returned by the function. If
<code class="docutils literal notranslate"><span class="pre">a</span></code> is not a quadratic residue modulo <code class="docutils literal notranslate"><span class="pre">p^exp</span></code> then 0 is
returned by the function and the location <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> points to is set to
NULL.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtmodn">
<span class="n"><span class="pre">slong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtmodn</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">sqrt</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">fac</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtmodn" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes all the square roots of <code class="docutils literal notranslate"><span class="pre">a</span></code> modulo <code class="docutils literal notranslate"><span class="pre">m</span></code> given the
factorisation of <code class="docutils literal notranslate"><span class="pre">m</span></code> in <code class="docutils literal notranslate"><span class="pre">fac</span></code>. The roots are stored in an array
which is created and whose address is stored in the location pointed to by
<code class="docutils literal notranslate"><span class="pre">sqrt</span></code>. The array of roots is allocated by the function but must be
cleaned up by the user by calling <a class="reference internal" href="flint.html#c.flint_free" title="flint_free"><code class="xref c c-func docutils literal notranslate"><span class="pre">flint_free()</span></code></a>. The number of roots
is returned by the function. If <code class="docutils literal notranslate"><span class="pre">a</span></code> is not a quadratic residue modulo
<code class="docutils literal notranslate"><span class="pre">m</span></code> then 0 is returned by the function and the location <code class="docutils literal notranslate"><span class="pre">sqrt</span></code>
points to is set to NULL.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_shoup">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_shoup</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">t</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">w_precomp</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_shoup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(w t \bmod{p}\)</span> given a precomputed scaled approximation of <span class="math notranslate nohighlight">\(w / p\)</span>
computed by <a class="reference internal" href="#c.n_mulmod_precomp_shoup" title="n_mulmod_precomp_shoup"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod_precomp_shoup()</span></code></a>. The value of <span class="math notranslate nohighlight">\(p\)</span> should be
less than <span class="math notranslate nohighlight">\(2^{\mathtt{FLINT\_BITS} - 1}\)</span>. <span class="math notranslate nohighlight">\(w\)</span> and <span class="math notranslate nohighlight">\(t\)</span> should be less than <span class="math notranslate nohighlight">\(p\)</span>.
Works faster than <a class="reference internal" href="#c.n_mulmod2_preinv" title="n_mulmod2_preinv"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_mulmod2_preinv()</span></code></a> if <span class="math notranslate nohighlight">\(w\)</span> fixed and <span class="math notranslate nohighlight">\(t\)</span> from array
(for example, scalar multiplication of vector).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_mulmod_precomp_shoup">
<span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_mulmod_precomp_shoup</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">w</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_mulmod_precomp_shoup" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(w'\)</span>, scaled approximation of <span class="math notranslate nohighlight">\(w / p\)</span>. <span class="math notranslate nohighlight">\(w'\)</span>  is equal to the integer
part of <span class="math notranslate nohighlight">\(w * 2^{\mathtt{FLINT\_BITS}} / p\)</span>.</p>
</dd></dl>

</section>
<section id="divisibility-testing">
<h2>Divisibility testing<a class="headerlink" href="#divisibility-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_divides">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_divides</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">q</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_divides" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">1</span></code> if <code class="docutils literal notranslate"><span class="pre">p</span></code> divides <code class="docutils literal notranslate"><span class="pre">n</span></code> and sets <code class="docutils literal notranslate"><span class="pre">q</span></code> to the quotient,
otherwise return <code class="docutils literal notranslate"><span class="pre">0</span></code> and sets <code class="docutils literal notranslate"><span class="pre">q</span></code> to <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
</dd></dl>

</section>
<section id="prime-number-generation-and-counting">
<h2>Prime number generation and counting<a class="headerlink" href="#prime-number-generation-and-counting" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_init">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_init</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_init" title="Link to this definition">¶</a><br /></dt>
<dd><p>Initialises the prime number iterator <code class="docutils literal notranslate"><span class="pre">iter</span></code> for use.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_clear">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_clear</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_clear" title="Link to this definition">¶</a><br /></dt>
<dd><p>Clears memory allocated by the prime number iterator <code class="docutils literal notranslate"><span class="pre">iter</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_next">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_next</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_next" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the next prime number and advances the state of <code class="docutils literal notranslate"><span class="pre">iter</span></code>.
The first call returns 2.</p>
<p>Small primes are looked up from <code class="docutils literal notranslate"><span class="pre">flint_small_primes</span></code>.
When this table is exhausted, primes are generated in blocks
by calling <a class="reference internal" href="#c.n_primes_sieve_range" title="n_primes_sieve_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_primes_sieve_range()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_jump_after">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_jump_after</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_jump_after" title="Link to this definition">¶</a><br /></dt>
<dd><p>Changes the state of <code class="docutils literal notranslate"><span class="pre">iter</span></code> to start generating primes
after <span class="math notranslate nohighlight">\(n\)</span> (excluding <span class="math notranslate nohighlight">\(n\)</span> itself).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_extend_small">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_extend_small</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">bound</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_extend_small" title="Link to this definition">¶</a><br /></dt>
<dd><p>Extends the table of small primes in <code class="docutils literal notranslate"><span class="pre">iter</span></code> to contain
at least two primes larger than or equal to <code class="docutils literal notranslate"><span class="pre">bound</span></code>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_sieve_range">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_sieve_range</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_primes_t</span></span><span class="w"> </span><span class="n"><span class="pre">iter</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_sieve_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the block endpoints of <code class="docutils literal notranslate"><span class="pre">iter</span></code> to the smallest and
largest odd numbers between <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span> inclusive, and
sieves to mark all odd primes in this range.
The iterator state is changed to point to the first
number in the sieved range.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_compute_primes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_compute_primes</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_compute_primes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Precomputes at least <code class="docutils literal notranslate"><span class="pre">num_primes</span></code> primes and their <code class="docutils literal notranslate"><span class="pre">double</span></code>
precomputed inverses and stores them in an internal cache.
Assuming that FLINT has been built with support for thread-local storage,
each thread has its own cache.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primes_arr_readonly">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">n_primes_arr_readonly</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primes_arr_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to a read-only array of the first <code class="docutils literal notranslate"><span class="pre">num_primes</span></code>
prime numbers. The computed primes are cached for repeated calls.
The pointer is valid until the user calls <a class="reference internal" href="#c.n_cleanup_primes" title="n_cleanup_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_cleanup_primes()</span></code></a>
in the same thread.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_prime_inverses_arr_readonly">
<span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">n_prime_inverses_arr_readonly</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_prime_inverses_arr_readonly" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to a read-only array of inverses of the first
<code class="docutils literal notranslate"><span class="pre">num_primes</span></code> prime numbers. The computed primes are cached for
repeated calls. The pointer is valid until the user calls
<a class="reference internal" href="#c.n_cleanup_primes" title="n_cleanup_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_cleanup_primes()</span></code></a> in the same thread.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cleanup_primes">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cleanup_primes</span></span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cleanup_primes" title="Link to this definition">¶</a><br /></dt>
<dd><p>Frees the internal cache of prime numbers used by the current thread.
This will invalidate any pointers returned by
<a class="reference internal" href="#c.n_primes_arr_readonly" title="n_primes_arr_readonly"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_primes_arr_readonly()</span></code></a> or <a class="reference internal" href="#c.n_prime_inverses_arr_readonly" title="n_prime_inverses_arr_readonly"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_prime_inverses_arr_readonly()</span></code></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_nextprime">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_nextprime</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_nextprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the next prime after <span class="math notranslate nohighlight">\(n\)</span>. Assumes the result will fit in an
<code class="docutils literal notranslate"><span class="pre">ulong</span></code>. If proved is <span class="math notranslate nohighlight">\(0\)</span>, i.e.false, the prime is not
proven prime, otherwise it is.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_prime_pi">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_prime_pi</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_prime_pi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the value of the prime counting function <span class="math notranslate nohighlight">\(\pi(n)\)</span>, i.e.the
number of primes less than or equal to <span class="math notranslate nohighlight">\(n\)</span>. The invariant
<code class="docutils literal notranslate"><span class="pre">n_prime_pi(n_nth_prime(n))</span> <span class="pre">==</span> <span class="pre">n</span></code>.</p>
<p>Currently, this function simply extends the table of cached primes up to
an upper limit and then performs a binary search.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_prime_pi_bounds">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_prime_pi_bounds</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lo</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_prime_pi_bounds" title="Link to this definition">¶</a><br /></dt>
<dd><p>Calculates lower and upper bounds for the value of the prime counting
function <code class="docutils literal notranslate"><span class="pre">lo</span> <span class="pre">&lt;=</span> <span class="pre">pi(n)</span> <span class="pre">&lt;=</span> <span class="pre">hi</span></code>. If <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> point to
the same location, the high value will be stored.</p>
<p>This does a table lookup for small values, then switches over to some
proven bounds.</p>
<p>The upper approximation is <span class="math notranslate nohighlight">\(1.25506 n / \ln n\)</span>, and the
lower is <span class="math notranslate nohighlight">\(n / \ln n\)</span>.  These bounds are due to Rosser and
Schoenfeld <a class="reference internal" href="references.html#rossch1962" id="id8"><span>[RosSch1962]</span></a> and valid for <span class="math notranslate nohighlight">\(n \geq 17\)</span>.</p>
<p>We use the number of bits in <span class="math notranslate nohighlight">\(n\)</span> (or one less) to form an
approximation to <span class="math notranslate nohighlight">\(\ln n\)</span>, taking care to use a value too
small or too large to maintain the inequality.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_nth_prime">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_nth_prime</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_nth_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the <span class="math notranslate nohighlight">\(n`th prime number `p_n\)</span>, using the mathematical indexing
convention <span class="math notranslate nohighlight">\(p_1 = 2, p_2 = 3, \dotsc\)</span>.</p>
<p>This function simply ensures that the table of cached primes is large
enough and then looks up the entry.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_nth_prime_bounds">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_nth_prime_bounds</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">lo</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">hi</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_nth_prime_bounds" title="Link to this definition">¶</a><br /></dt>
<dd><p>Calculates lower and upper bounds for the  <span class="math notranslate nohighlight">\(n\)</span> th prime number <span class="math notranslate nohighlight">\(p_n\)</span> ,
<code class="docutils literal notranslate"><span class="pre">lo</span> <span class="pre">&lt;=</span> <span class="pre">p_n</span> <span class="pre">&lt;=</span> <span class="pre">hi</span></code>. If <code class="docutils literal notranslate"><span class="pre">lo</span></code> and <code class="docutils literal notranslate"><span class="pre">hi</span></code> point to the same
location, the high value will be stored. Note that this function will
overflow for sufficiently large <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>We use the following estimates, valid for <span class="math notranslate nohighlight">\(n &gt; 5\)</span> :</p>
<div class="math notranslate nohighlight">
\[\begin{split}p_n  &amp; &gt;  n (\ln n + \ln \ln n - 1) \\
p_n  &amp; &lt;  n (\ln n + \ln \ln n) \\
p_n  &amp; &lt;  n (\ln n + \ln \ln n - 0.9427) \quad (n \geq 15985)\end{split}\]</div>
<p>The first inequality was proved by Dusart <a class="reference internal" href="references.html#dus1999" id="id9"><span>[Dus1999]</span></a>, and the last
is due to Massias and Robin <a class="reference internal" href="references.html#masrob1996" id="id10"><span>[MasRob1996]</span></a>.  For a further overview,
see <a class="reference external" href="http://primes.utm.edu/howmany.shtml">http://primes.utm.edu/howmany.shtml</a> .</p>
<p>We bound <span class="math notranslate nohighlight">\(\ln n\)</span> using the number of bits in <span class="math notranslate nohighlight">\(n\)</span> as in
<code class="docutils literal notranslate"><span class="pre">n_prime_pi_bounds()</span></code>, and estimate <span class="math notranslate nohighlight">\(\ln \ln n\)</span> to the nearest
integer; this function is nearly constant.</p>
</dd></dl>

</section>
<section id="primality-testing">
<h2>Primality testing<a class="headerlink" href="#primality-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_oddprime_small">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_oddprime_small</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_oddprime_small" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is an odd prime smaller than
<code class="docutils literal notranslate"><span class="pre">FLINT_ODDPRIME_SMALL_CUTOFF</span></code>. Expects <span class="math notranslate nohighlight">\(n\)</span>
to be odd and smaller than the cutoff.</p>
<p>This function merely uses a lookup table with one bit allocated for each
odd number up to the cutoff.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_oddprime_binary">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_oddprime_binary</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_oddprime_binary" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function performs a simple binary search through
the table of cached primes for <span class="math notranslate nohighlight">\(n\)</span>. If it exists in the array it returns
<span class="math notranslate nohighlight">\(1\)</span>, otherwise <span class="math notranslate nohighlight">\(0\)</span>. For the algorithm to operate correctly
<span class="math notranslate nohighlight">\(n\)</span> should be odd and at least <span class="math notranslate nohighlight">\(17\)</span>.</p>
<p>Lower and upper bounds are computed with <a class="reference internal" href="#c.n_prime_pi_bounds" title="n_prime_pi_bounds"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_prime_pi_bounds()</span></code></a>.
Once we have bounds on where to look in the table, we
refine our search with a simple binary algorithm, taking
the top or bottom of the current interval as necessary.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_prime_pocklington">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_prime_pocklington</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">iterations</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_prime_pocklington" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a prime using the Pocklington–Lehmer primality
test. If <span class="math notranslate nohighlight">\(1\)</span> is returned <span class="math notranslate nohighlight">\(n\)</span> has been proved prime. If <span class="math notranslate nohighlight">\(0\)</span> is returned
<span class="math notranslate nohighlight">\(n\)</span> is composite. However <span class="math notranslate nohighlight">\(-1\)</span> may be returned if nothing was proved
either way due to the number of iterations being too small.</p>
<p>The most time consuming part of the algorithm is factoring
<span class="math notranslate nohighlight">\(n - 1\)</span>. For this reason <a class="reference internal" href="#c.n_factor_partial" title="n_factor_partial"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_partial()</span></code></a> is used,
which uses a combination of trial factoring and Hart’s one
line factor algorithm <a class="reference internal" href="references.html#har2012" id="id11"><span>[Har2012]</span></a> to try to quickly factor <span class="math notranslate nohighlight">\(n - 1\)</span>.
Additionally if the cofactor is less than the square root of
<span class="math notranslate nohighlight">\(n - 1\)</span> the algorithm can still proceed.</p>
<p>One can also specify a number of iterations if less time
should be taken. Simply set this to <code class="docutils literal notranslate"><span class="pre">WORD(0)</span></code> if this is irrelevant.
In most cases a greater number of iterations will not
significantly affect timings as most of the time is spent
factoring.</p>
<p>See
<a class="reference external" href="https://mathworld.wolfram.com/PocklingtonsTheorem.html">https://mathworld.wolfram.com/PocklingtonsTheorem.html</a>
for a description of the algorithm.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_prime_pseudosquare">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_prime_pseudosquare</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_prime_pseudosquare" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a prime according to Theorem 2.7 <a class="reference internal" href="references.html#lukpatwil1996" id="id12"><span>[LukPatWil1996]</span></a>.</p>
<p>We first factor <span class="math notranslate nohighlight">\(N\)</span> using trial division up to some limit <span class="math notranslate nohighlight">\(B\)</span>.
In fact, the number of primes used in the trial factoring is at
most <code class="docutils literal notranslate"><span class="pre">FLINT_PSEUDOSQUARES_CUTOFF</span></code>.</p>
<p>Next we compute <span class="math notranslate nohighlight">\(N/B\)</span> and find the next pseudosquare <span class="math notranslate nohighlight">\(L_p\)</span> above
this value, using a static table as per
<a class="reference external" href="https://oeis.org/A002189/b002189.txt">https://oeis.org/A002189/b002189.txt</a> .</p>
<p>As noted in the text, if <span class="math notranslate nohighlight">\(p\)</span> is prime then Step 3 will pass. This
test rejects many composites, and so by this time we suspect
that <span class="math notranslate nohighlight">\(p\)</span> is prime. If <span class="math notranslate nohighlight">\(N\)</span> is <span class="math notranslate nohighlight">\(3\)</span> or <span class="math notranslate nohighlight">\(7\)</span> modulo <span class="math notranslate nohighlight">\(8\)</span>, we are done,
and <span class="math notranslate nohighlight">\(N\)</span> is prime.</p>
<p>We now run a probable prime test, for which no known
counterexamples are known, to reject any composites. We then
proceed to prove <span class="math notranslate nohighlight">\(N\)</span> prime by executing Step 4. In the case that
<span class="math notranslate nohighlight">\(N\)</span> is <span class="math notranslate nohighlight">\(1\)</span> modulo <span class="math notranslate nohighlight">\(8\)</span>, if Step 4 fails, we extend the number of primes
<span class="math notranslate nohighlight">\(p_i\)</span> at Step 3 and hope to find one which passes Step 4. We take
the test one past the largest <span class="math notranslate nohighlight">\(p\)</span> for which we have pseudosquares
<span class="math notranslate nohighlight">\(L_p\)</span> tabulated, as this already corresponds to the next <span class="math notranslate nohighlight">\(L_p\)</span> which
is bigger than <span class="math notranslate nohighlight">\(2^{64}\)</span> and hence larger than any prime we might be
testing.</p>
<p>As explained in the text, Condition 4 cannot fail if <span class="math notranslate nohighlight">\(N\)</span> is prime.</p>
<p>The possibility exists that the probable prime test declares a
composite prime. However in that case an error is printed, as
that would be of independent interest.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_prime">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_prime</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a prime. This first sieves for small prime factors,
then simply calls <a class="reference internal" href="#c.n_is_probabprime" title="n_is_probabprime"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_probabprime()</span></code></a>. This has been checked
against the tables of Feitsma and Galway
<a class="reference external" href="http://www.cecm.sfu.ca/Pseudoprimes/index-2-to-64.html">http://www.cecm.sfu.ca/Pseudoprimes/index-2-to-64.html</a> and thus
constitutes a check for primality (rather than just pseudoprimality)
up to <span class="math notranslate nohighlight">\(2^{64}\)</span>.</p>
<p>In future, this test may produce and check a certificate of
primality. This is likely to be significantly slower for prime
inputs.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_strong_probabprime_precomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_strong_probabprime_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">npre</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_strong_probabprime_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a strong probable prime to the base <span class="math notranslate nohighlight">\(a\)</span>. We
require that <span class="math notranslate nohighlight">\(d\)</span> is set to the largest odd factor of <span class="math notranslate nohighlight">\(n - 1\)</span> and
<code class="docutils literal notranslate"><span class="pre">npre</span></code> is a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed with
<a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>.  We also require that <span class="math notranslate nohighlight">\(n &lt; 2^{53}\)</span>,
<span class="math notranslate nohighlight">\(a\)</span> to be reduced modulo <span class="math notranslate nohighlight">\(n\)</span> and not <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(n\)</span> to be odd.</p>
<p>If we write <span class="math notranslate nohighlight">\(n - 1 = 2^s d\)</span> where <span class="math notranslate nohighlight">\(d\)</span> is odd then <span class="math notranslate nohighlight">\(n\)</span> is a strong
probable prime to the base <span class="math notranslate nohighlight">\(a\)</span>, i.e.an <span class="math notranslate nohighlight">\(a\)</span>-SPRP, if either
<span class="math notranslate nohighlight">\(a^d = 1 \pmod n\)</span> or <span class="math notranslate nohighlight">\((a^d)^{2^r} = -1 \pmod n\)</span> for some <span class="math notranslate nohighlight">\(r\)</span> less
than <span class="math notranslate nohighlight">\(s\)</span>.</p>
<p>A description of strong probable primes is given here:
<a class="reference external" href="https://mathworld.wolfram.com/StrongPseudoprime.html">https://mathworld.wolfram.com/StrongPseudoprime.html</a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_strong_probabprime2_preinv">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_strong_probabprime2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">d</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_strong_probabprime2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a strong probable prime to the base <span class="math notranslate nohighlight">\(a\)</span>. We require
that <span class="math notranslate nohighlight">\(d\)</span> is set to the largest odd factor of <span class="math notranslate nohighlight">\(n - 1\)</span> and <code class="docutils literal notranslate"><span class="pre">npre</span></code>
is a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> computed with <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>.
We require a to be reduced modulo <span class="math notranslate nohighlight">\(n\)</span> and not <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(n\)</span> to be odd.</p>
<p>If we write <span class="math notranslate nohighlight">\(n - 1 = 2^s d\)</span> where <span class="math notranslate nohighlight">\(d\)</span> is odd then <span class="math notranslate nohighlight">\(n\)</span> is a strong
probable prime to the base <span class="math notranslate nohighlight">\(a\)</span> (an <span class="math notranslate nohighlight">\(a\)</span>-SPRP) if either <span class="math notranslate nohighlight">\(a^d = 1 \pmod n\)</span>
or <span class="math notranslate nohighlight">\((a^d)^{2^r} = -1 \pmod n\)</span> for some <span class="math notranslate nohighlight">\(r\)</span> less than <span class="math notranslate nohighlight">\(s\)</span>.</p>
<p>A description of strong probable primes is given here:
<a class="reference external" href="https://mathworld.wolfram.com/StrongPseudoprime.html">https://mathworld.wolfram.com/StrongPseudoprime.html</a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_fermat">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_fermat</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">i</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_fermat" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is a base <span class="math notranslate nohighlight">\(i\)</span> Fermat probable prime. Requires
<span class="math notranslate nohighlight">\(1 &lt; i &lt; n\)</span> and that <span class="math notranslate nohighlight">\(i\)</span> does not divide <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>By Fermat’s Little Theorem if <span class="math notranslate nohighlight">\(i^{n-1}\)</span> is not congruent to <span class="math notranslate nohighlight">\(1\)</span>
then <span class="math notranslate nohighlight">\(n\)</span> is not prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_fibonacci">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_fibonacci</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_fibonacci" title="Link to this definition">¶</a><br /></dt>
<dd><p>Let <span class="math notranslate nohighlight">\(F_j\)</span> be the <span class="math notranslate nohighlight">\(j`th element of the Fibonacci sequence
`0, 1, 1, 2, 3, 5, \dotsc\)</span>, starting at <span class="math notranslate nohighlight">\(j = 0\)</span>. Then if <span class="math notranslate nohighlight">\(n\)</span> is prime
we have <span class="math notranslate nohighlight">\(F_{n - (n/5)} = 0 \pmod n\)</span>, where <span class="math notranslate nohighlight">\((n/5)\)</span> is the Jacobi
symbol.</p>
<p>For further details, see  pp. 142 <a class="reference internal" href="references.html#crapom2005" id="id13"><span>[CraPom2005]</span></a>.</p>
<p>We require that <span class="math notranslate nohighlight">\(n\)</span> is not divisible by <span class="math notranslate nohighlight">\(2\)</span> or <span class="math notranslate nohighlight">\(5\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_BPSW">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_BPSW</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_BPSW" title="Link to this definition">¶</a><br /></dt>
<dd><p>Implements a Baillie–Pomerance–Selfridge–Wagstaff probable primality
test. This is a variant of the usual BPSW test (which only uses strong
base-2 probable prime and Lucas-Selfridge tests, see Baillie and
Wagstaff <a class="reference internal" href="references.html#baiwag1980" id="id14"><span>[BaiWag1980]</span></a>).</p>
<p>This implementation makes use of a weakening of the usual Baillie-PSW
test given in  <a class="reference internal" href="references.html#chen2003" id="id15"><span>[Chen2003]</span></a>, namely replacing the Lucas test with a
Fibonacci test when <span class="math notranslate nohighlight">\(n \equiv 2, 3 \pmod{5}\)</span>, (see also the comment on
page 143 of <a class="reference internal" href="references.html#crapom2005" id="id16"><span>[CraPom2005]</span></a>) regarding Fibonacci pseudoprimes.</p>
<p>There are no known counterexamples to this being a primality test.</p>
<p>Up to <span class="math notranslate nohighlight">\(2^{64}\)</span> the test we use has been checked against tables of
pseudoprimes. Thus it is a primality test up to this limit.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime_lucas">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime_lucas</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime_lucas" title="Link to this definition">¶</a><br /></dt>
<dd><p>For details on Lucas pseudoprimes, see [pp. 143] <a class="reference internal" href="references.html#crapom2005" id="id17"><span>[CraPom2005]</span></a>.</p>
<p>We implement a variant of the Lucas pseudoprime test similar to that
described by Baillie and Wagstaff <a class="reference internal" href="references.html#baiwag1980" id="id18"><span>[BaiWag1980]</span></a>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_probabprime">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_probabprime</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_probabprime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Tests if <span class="math notranslate nohighlight">\(n\)</span> is a probable prime. Up to <code class="docutils literal notranslate"><span class="pre">FLINT_ODDPRIME_SMALL_CUTOFF</span></code>
this algorithm uses <a class="reference internal" href="#c.n_is_oddprime_small" title="n_is_oddprime_small"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_oddprime_small()</span></code></a> which uses a lookup table.</p>
<p>Next it calls <a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> with the maximum table size and
uses this table to perform a binary search for <span class="math notranslate nohighlight">\(n\)</span> up to the table limit.</p>
<p>Then up to <span class="math notranslate nohighlight">\(1050535501\)</span> it uses a number of strong probable prime tests,
<code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_strong_probabprime_preinv()</span></code>, etc., for various bases. The
output of the algorithm is guaranteed to be correct up to this bound due
to exhaustive tables, described at
<a class="reference external" href="http://uucode.com/obf/dalbec/alg.html">http://uucode.com/obf/dalbec/alg.html</a> .</p>
<p>Beyond that point the BPSW probabilistic primality test is used, by
calling the function <a class="reference internal" href="#c.n_is_probabprime_BPSW" title="n_is_probabprime_BPSW"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_is_probabprime_BPSW()</span></code></a>. There are no known
counterexamples, and it has been checked against the tables of Feitsma
and Galway and up to the accuracy of those tables, this is an exhaustive
check up to <span class="math notranslate nohighlight">\(2^{64}\)</span>, i.e. there are no counterexamples.</p>
</dd></dl>

</section>
<section id="chinese-remaindering">
<h2>Chinese remaindering<a class="headerlink" href="#chinese-remaindering" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_CRT">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_CRT</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">r1</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">m1</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">r2</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">m2</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_CRT" title="Link to this definition">¶</a><br /></dt>
<dd><p>Use the Chinese Remainder Theorem to set return the unique value
<span class="math notranslate nohighlight">\(0 \le x &lt; M\)</span> congruent to <span class="math notranslate nohighlight">\(r_1\)</span> modulo <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(r_2\)</span> modulo <span class="math notranslate nohighlight">\(m_2\)</span>,
where <span class="math notranslate nohighlight">\(M = m_1 \times m_2\)</span> is assumed to fit a ulong.</p>
<p>It is assumed that <span class="math notranslate nohighlight">\(m_1\)</span> and <span class="math notranslate nohighlight">\(m_2\)</span> are positive integers greater
than <span class="math notranslate nohighlight">\(1\)</span> and coprime. It is assumed that <span class="math notranslate nohighlight">\(0 \le r_1 &lt; m_1\)</span> and <span class="math notranslate nohighlight">\(0 \le r_2 &lt; m_2\)</span>.</p>
</dd></dl>

</section>
<section id="square-root-and-perfect-power-testing">
<h2>Square root and perfect power testing<a class="headerlink" href="#square-root-and-perfect-power-testing" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrt">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrt</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the integer truncation of the square root of <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>The implementation uses a call to the IEEE floating point sqrt function.
The integer itself is represented by the nearest double and its square
root is computed to the nearest place. If <span class="math notranslate nohighlight">\(a\)</span> is one below a square, the
rounding may be up, whereas if it is one above a square, the rounding
will be down. Thus the square root may be one too large in some
instances which we then adjust by checking if we have the right value.
We also have to be careful when the square of this too large
value causes an overflow. The same assumptions hold for a single
precision float provided the square root itself can be represented
in a single float, i.e.for <span class="math notranslate nohighlight">\(a &lt; 281474976710656 = 2^{46}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_sqrtrem">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_sqrtrem</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">r</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_sqrtrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the integer truncation of the square root of <span class="math notranslate nohighlight">\(a\)</span>.</p>
<p>The integer itself is represented by the nearest double and its square
root is computed to the nearest place. If <span class="math notranslate nohighlight">\(a\)</span> is one below a square, the
rounding may be up, whereas if it is one above a square, the rounding
will be down. Thus the square root may be one too large in some
instances which we then adjust by checking if we have the right value.
We also have to be careful when the square of this too
large value causes an overflow. The same assumptions hold for a
single precision float provided the square root itself can be
represented in a single float, i.e. for <span class="math notranslate nohighlight">\(a &lt; 281474976710656 = 2^{46}\)</span>.</p>
<p>The remainder is computed by subtracting the square of the computed square
root from <span class="math notranslate nohighlight">\(a\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_square">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_square</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">x</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_square" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(x\)</span> is a square, otherwise <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>This code first checks if <span class="math notranslate nohighlight">\(x\)</span> is a square modulo <span class="math notranslate nohighlight">\(64\)</span>,
<span class="math notranslate nohighlight">\(63 = 3 \times 3 \times 7\)</span> and <span class="math notranslate nohighlight">\(65 = 5 \times 13\)</span>, using lookup tables,
and if so it then takes a square root and checks that the square of this
equals the original value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_perfect_power235">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_perfect_power235</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_perfect_power235" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(1\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is a perfect square, cube or fifth power.</p>
<p>This function uses a series of modular tests to reject most
non 235-powers. Each modular test returns a value from 0 to 7
whose bits respectively indicate whether the value is a square,
cube or fifth power modulo the given modulus. When these are
logically <code class="docutils literal notranslate"><span class="pre">AND</span></code>-ed together, this gives a powerful test which will
reject most non-235 powers.</p>
<p>If a bit remains set indicating it may be a square, a standard
square root test is performed. Similarly a cube root or fifth
root can be taken, if indicated, to determine whether the power
of that root is exactly equal to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_perfect_power">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_perfect_power</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">root</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_perfect_power" title="Link to this definition">¶</a><br /></dt>
<dd><p>If <span class="math notranslate nohighlight">\(n = r^k\)</span>, return <span class="math notranslate nohighlight">\(k\)</span> and set <code class="docutils literal notranslate"><span class="pre">root</span></code> to <span class="math notranslate nohighlight">\(r\)</span>. Note that <span class="math notranslate nohighlight">\(0\)</span> and
<span class="math notranslate nohighlight">\(1\)</span> are considered squares. No guarantees are made about <span class="math notranslate nohighlight">\(r\)</span> or <span class="math notranslate nohighlight">\(k\)</span>
being the minimum possible value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_rootrem">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_rootrem</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remainder</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">root</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_rootrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function uses the Newton iteration method to calculate the nth root of
a number.
First approximation is calculated by an algorithm mentioned in this
article :  <a class="reference external" href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">https://en.wikipedia.org/wiki/Fast_inverse_square_root</a> .
Instead of the inverse square root, the nth root is calculated.</p>
<p>Returns the integer part of <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">^</span> <span class="pre">1/root</span></code>. Remainder is set as
<code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">-</span> <span class="pre">base^root</span></code>. In case <span class="math notranslate nohighlight">\(n &lt; 1\)</span> or <code class="docutils literal notranslate"><span class="pre">root</span> <span class="pre">&lt;</span> <span class="pre">1</span></code>, <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrt">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrt</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrt" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
First approximation is calculated by an algorithm mentioned in this
article : <a class="reference external" href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">https://en.wikipedia.org/wiki/Fast_inverse_square_root</a> .
Instead of the inverse sqare root, the cube root is calculated.
This functions uses different algorithms to calculate the cube root,
depending upon the size of <span class="math notranslate nohighlight">\(n\)</span>. For numbers greater than <span class="math notranslate nohighlight">\(2^46\)</span>, it uses
<a class="reference internal" href="#c.n_cbrt_chebyshev_approx" title="n_cbrt_chebyshev_approx"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_cbrt_chebyshev_approx()</span></code></a>. Otherwise, it makes use of the iteration,
<span class="math notranslate nohighlight">\(x \leftarrow x - (x*x*x - a)*x/(2*x*x*x + a)\)</span> for getting a good estimate,
as mentioned in the paper by W. Kahan <a class="reference internal" href="references.html#kahan1991" id="id19"><span>[Kahan1991]</span></a> .</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrt_newton_iteration">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrt_newton_iteration</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrt_newton_iteration" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
Makes use of Newton iterations to get a close value, and then adjusts the
estimate so as to get the correct value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrt_binary_search">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrt_binary_search</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrt_binary_search" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
Uses binary search to get the correct value.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrt_chebyshev_approx">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrt_chebyshev_approx</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrt_chebyshev_approx" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
The number is first expressed in the form <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">*</span> <span class="pre">2^exp</span></code>. This ensures
<span class="math notranslate nohighlight">\(x\)</span> is in the range [0.5, 1]. Cube root of x is calculated using
Chebyshev’s approximation polynomial for the function <span class="math notranslate nohighlight">\(y = x^1/3\)</span>. The
values of the coefficient are calculated from the python module mpmath,
<a class="reference external" href="http://mpmath.org">http://mpmath.org</a>, using the function chebyfit. x is multiplied
by <code class="docutils literal notranslate"><span class="pre">2^exp</span></code> and the cube root of 1, 2 or 4 (according to <code class="docutils literal notranslate"><span class="pre">exp%3</span></code>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_cbrtrem">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_cbrtrem</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">remainder</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_cbrtrem" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function returns the integer truncation of the cube root of <span class="math notranslate nohighlight">\(n\)</span>.
Remainder is set as <span class="math notranslate nohighlight">\(n\)</span> minus the cube of the value returned.</p>
</dd></dl>

</section>
<section id="factorisation">
<h2>Factorisation<a class="headerlink" href="#factorisation" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_remove">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_remove</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_remove" title="Link to this definition">¶</a><br /></dt>
<dd><p>Removes the highest possible power of <span class="math notranslate nohighlight">\(p\)</span> from <span class="math notranslate nohighlight">\(n\)</span>, replacing
<span class="math notranslate nohighlight">\(n\)</span> with the quotient. The return value is that highest
power of <span class="math notranslate nohighlight">\(p\)</span> that divided <span class="math notranslate nohighlight">\(n\)</span>. Assumes <span class="math notranslate nohighlight">\(n\)</span> is not <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>For <span class="math notranslate nohighlight">\(p = 2\)</span> trailing zeroes are counted. For other primes
<span class="math notranslate nohighlight">\(p\)</span> is repeatedly squared and stored in a table of powers
with the current highest power of <span class="math notranslate nohighlight">\(p\)</span> removed at each step
until no higher power can be removed. The algorithm then
proceeds down the power tree again removing powers of <span class="math notranslate nohighlight">\(p\)</span>
until none remain.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_remove2_precomp">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_remove2_precomp</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="n"><span class="pre">ppre</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_remove2_precomp" title="Link to this definition">¶</a><br /></dt>
<dd><p>Removes the highest possible power of <span class="math notranslate nohighlight">\(p\)</span> from <span class="math notranslate nohighlight">\(n\)</span>, replacing
<span class="math notranslate nohighlight">\(n\)</span> with the quotient. The return value is that highest
power of <span class="math notranslate nohighlight">\(p\)</span> that divided <span class="math notranslate nohighlight">\(n\)</span>. Assumes <span class="math notranslate nohighlight">\(n\)</span> is not <span class="math notranslate nohighlight">\(0\)</span>. We require
<code class="docutils literal notranslate"><span class="pre">ppre</span></code> to be set to a precomputed inverse of <span class="math notranslate nohighlight">\(p\)</span> computed
with <a class="reference internal" href="#c.n_precompute_inverse" title="n_precompute_inverse"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_precompute_inverse()</span></code></a>.</p>
<p>For <span class="math notranslate nohighlight">\(p = 2\)</span> trailing zeroes are counted. For other primes
<span class="math notranslate nohighlight">\(p\)</span> we make repeated use of <a class="reference internal" href="#c.n_divrem2_precomp" title="n_divrem2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_divrem2_precomp()</span></code></a> until division
by <span class="math notranslate nohighlight">\(p\)</span> is no longer possible.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_insert">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_insert</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">exp</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_insert" title="Link to this definition">¶</a><br /></dt>
<dd><p>Inserts the given prime power factor <code class="docutils literal notranslate"><span class="pre">p^exp</span></code> into
the <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> <code class="docutils literal notranslate"><span class="pre">factors</span></code>. See the documentation for
<a class="reference internal" href="#c.n_factor_trial" title="n_factor_trial"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_trial()</span></code></a> for a description of the <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> type.</p>
<p>The algorithm performs a simple search to see if <span class="math notranslate nohighlight">\(p\)</span> already
exists as a prime factor in the structure. If so the exponent
there is increased by the supplied exponent. Otherwise a new
factor <code class="docutils literal notranslate"><span class="pre">p^exp</span></code> is added to the end of the structure.</p>
<p>There is no test code for this function other than its use by
the various factoring functions, which have test code.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_trial_range">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_trial_range</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">start</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_trial_range" title="Link to this definition">¶</a><br /></dt>
<dd><p>Trial factor <span class="math notranslate nohighlight">\(n\)</span> with the first <code class="docutils literal notranslate"><span class="pre">num_primes</span></code> primes, but
starting at the prime with index start (counting from zero).</p>
<p>One requires an initialised <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> structure, but factors
will be added by default to an already used <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code>. Use
the function <code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_init()</span></code> defined in <code class="docutils literal notranslate"><span class="pre">ulong_extras</span></code> if
initialisation has not already been completed on factors.</p>
<p>Once completed, <code class="docutils literal notranslate"><span class="pre">num</span></code> will contain the number of distinct
prime factors found. The field <span class="math notranslate nohighlight">\(p\)</span> is an array of <code class="docutils literal notranslate"><span class="pre">ulong</span></code>’s
containing the distinct prime factors, <code class="docutils literal notranslate"><span class="pre">exp</span></code> an array
containing the corresponding exponents.</p>
<p>The return value is the unfactored cofactor after trial
factoring is done.</p>
<p>The function calls <a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> automatically. See
the documentation for that function regarding limits.</p>
<p>The algorithm stops when the current prime has a square
exceeding <span class="math notranslate nohighlight">\(n\)</span>, as no prime factor of <span class="math notranslate nohighlight">\(n\)</span> can exceed this
unless <span class="math notranslate nohighlight">\(n\)</span> is prime.</p>
<p>The precomputed inverses of all the primes computed by
<a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> are utilised with the <a class="reference internal" href="#c.n_remove2_precomp" title="n_remove2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_remove2_precomp()</span></code></a>
function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_trial">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_trial</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_trial" title="Link to this definition">¶</a><br /></dt>
<dd><p>This function calls <a class="reference internal" href="#c.n_factor_trial_range" title="n_factor_trial_range"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_trial_range()</span></code></a>, with the value of
<span class="math notranslate nohighlight">\(0\)</span> for <code class="docutils literal notranslate"><span class="pre">start</span></code>. By default this adds factors to an already existing
<code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> or to a newly initialised one.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_power235">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_power235</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">exp</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_power235" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is not a perfect square, cube or fifth power.
Otherwise it returns the root and sets <code class="docutils literal notranslate"><span class="pre">exp</span></code> to either <span class="math notranslate nohighlight">\(2\)</span>,
<span class="math notranslate nohighlight">\(3\)</span> or <span class="math notranslate nohighlight">\(5\)</span> appropriately.</p>
<p>This function uses a series of modular tests to reject most
non 235-powers. Each modular test returns a value from 0 to 7
whose bits respectively indicate whether the value is a square,
cube or fifth power modulo the given modulus. When these are
logically <code class="docutils literal notranslate"><span class="pre">AND</span></code>-ed together, this gives a powerful test which will
reject most non-235 powers.</p>
<p>If a bit remains set indicating it may be a square, a standard
square root test is performed. Similarly a cube root or fifth
root can be taken, if indicated, to determine whether the power
of that root is exactly equal to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_one_line">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_one_line</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_one_line" title="Link to this definition">¶</a><br /></dt>
<dd><p>This implements Bill Hart’s one line factoring algorithm <a class="reference internal" href="references.html#har2012" id="id20"><span>[Har2012]</span></a>.
It is a variant of Fermat’s algorithm which cycles through a large number
of multipliers instead of incrementing the square root. It is faster than
SQUFOF for <span class="math notranslate nohighlight">\(n\)</span> less than about <span class="math notranslate nohighlight">\(2^{40}\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_lehman">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_lehman</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_lehman" title="Link to this definition">¶</a><br /></dt>
<dd><p>Lehman’s factoring algorithm. Currently works up to <span class="math notranslate nohighlight">\(10^{16}\)</span>, but is
not particularly efficient and so is not used in the general factor
function. Always returns a factor of <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_SQUFOF">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_SQUFOF</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_SQUFOF" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempts to split <span class="math notranslate nohighlight">\(n\)</span> using the given number of iterations
of SQUFOF. Simply set <code class="docutils literal notranslate"><span class="pre">iters</span></code> to `` WORD(0)`` for maximum
persistence.</p>
<p>The version of SQUFOF implemented here is as described by Gower
and Wagstaff <a class="reference internal" href="references.html#gowwag2008" id="id21"><span>[GowWag2008]</span></a>.</p>
<p>We start by trying SQUFOF directly on <span class="math notranslate nohighlight">\(n\)</span>. If that fails we
multiply it by each of the primes in <code class="docutils literal notranslate"><span class="pre">flint_primes_small</span></code> in
turn. As this multiplication may result in a two limb value
we allow this in our implementation of SQUFOF. As SQUFOF
works with values about half the size of <span class="math notranslate nohighlight">\(n\)</span> it only needs
single limb arithmetic internally.</p>
<p>If SQUFOF fails to factor <span class="math notranslate nohighlight">\(n\)</span> we return <span class="math notranslate nohighlight">\(0\)</span>, however with
<code class="docutils literal notranslate"><span class="pre">iters</span></code> large enough this should never happen.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Factors <span class="math notranslate nohighlight">\(n\)</span> with no restrictions on <span class="math notranslate nohighlight">\(n\)</span>. If the prime factors are
required to be checked with a primality test, one may set
<code class="docutils literal notranslate"><span class="pre">proved</span></code> to <span class="math notranslate nohighlight">\(1\)</span>, otherwise set it to <span class="math notranslate nohighlight">\(0\)</span>, and they will only be
probable primes. N.B: at the present there is no difference because
the probable prime tests have been exhaustively tested up to <span class="math notranslate nohighlight">\(2^{64}\)</span>.</p>
<p>However, in future, this flag may produce and separately check
a primality certificate. This may be quite slow (and probably no
less reliable in practice).</p>
<p>For details on the <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> structure, see
<a class="reference internal" href="#c.n_factor_trial" title="n_factor_trial"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_trial()</span></code></a>.</p>
<p>This function first tries trial factoring with a number of primes
specified by the constant <code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_TRIAL_PRIMES</span></code>. If the
cofactor is <span class="math notranslate nohighlight">\(1\)</span> or prime the function returns with all the factors.</p>
<p>Otherwise, the cofactor is placed in the array <code class="docutils literal notranslate"><span class="pre">factor_arr</span></code>. Whilst
there are factors remaining in there which have not been split, the
algorithm continues. At each step each factor is first checked to
determine if it is a perfect power. If so it is replaced by the power
that has been found. Next if the factor is small enough and composite,
in particular, less than <code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_ONE_LINE_MAX</span></code> then
<a class="reference internal" href="#c.n_factor_one_line" title="n_factor_one_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_one_line()</span></code></a> is called with
<code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_ONE_LINE_ITERS</span></code> to try and split the factor. If
that fails or the factor is too large for <a class="reference internal" href="#c.n_factor_one_line" title="n_factor_one_line"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_one_line()</span></code></a>
then <a class="reference internal" href="#c.n_factor_SQUFOF" title="n_factor_SQUFOF"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_SQUFOF()</span></code></a> is called, with
<code class="docutils literal notranslate"><span class="pre">FLINT_FACTOR_SQUFOF_ITERS</span></code>. If that fails an error results and
the program aborts. However this should not happen in practice.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_trial_partial">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_trial_partial</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prod</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">num_primes</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_trial_partial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Attempts trial factoring of <span class="math notranslate nohighlight">\(n\)</span> with the first <code class="docutils literal notranslate"><span class="pre">num_primes</span> <span class="pre">primes</span></code>,
but stops when the product of prime factors so far exceeds <code class="docutils literal notranslate"><span class="pre">limit</span></code>.</p>
<p>One requires an initialised <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> structure, but factors
will be added by default to an already used <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code>. Use
the function <code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_init()</span></code> defined in <code class="docutils literal notranslate"><span class="pre">ulong_extras</span></code> if
initialisation has not already been completed on <code class="docutils literal notranslate"><span class="pre">factors</span></code>.</p>
<p>Once completed, <code class="docutils literal notranslate"><span class="pre">num</span></code> will contain the number of distinct
prime factors found. The field <span class="math notranslate nohighlight">\(p\)</span> is an array of <code class="docutils literal notranslate"><span class="pre">ulong</span></code>’s
containing the distinct prime factors, <code class="docutils literal notranslate"><span class="pre">exp</span></code> an array
containing the corresponding exponents.</p>
<p>The return value is the unfactored cofactor after trial
factoring is done. The value <code class="docutils literal notranslate"><span class="pre">prod</span></code> will be set to the product
of the factors found.</p>
<p>The function calls <a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> automatically. See
the documentation for that function regarding limits.</p>
<p>The algorithm stops when the current prime has a square
exceeding <span class="math notranslate nohighlight">\(n\)</span>, as no prime factor of <span class="math notranslate nohighlight">\(n\)</span> can exceed this
unless <span class="math notranslate nohighlight">\(n\)</span> is prime.</p>
<p>The precomputed inverses of all the primes computed by
<a class="reference internal" href="#c.n_compute_primes" title="n_compute_primes"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_compute_primes()</span></code></a> are utilised with the <a class="reference internal" href="#c.n_remove2_precomp" title="n_remove2_precomp"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_remove2_precomp()</span></code></a>
function.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_partial">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_partial</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">limit</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n"><span class="pre">proved</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_partial" title="Link to this definition">¶</a><br /></dt>
<dd><p>Factors <span class="math notranslate nohighlight">\(n\)</span>, but stops when the product of prime factors so far
exceeds <code class="docutils literal notranslate"><span class="pre">limit</span></code>.</p>
<p>One requires an initialised <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code> structure, but factors
will be added by default to an already used <code class="docutils literal notranslate"><span class="pre">n_factor_t</span></code>. Use
the function <code class="docutils literal notranslate"><span class="pre">n_factor_init()</span></code> defined in <code class="docutils literal notranslate"><span class="pre">ulong_extras</span></code> if
initialisation has not already been completed on <code class="docutils literal notranslate"><span class="pre">factors</span></code>.</p>
<p>On exit, <code class="docutils literal notranslate"><span class="pre">num</span></code> will contain the number of distinct prime factors
found. The field <span class="math notranslate nohighlight">\(p\)</span> is an array of <code class="docutils literal notranslate"><span class="pre">ulong</span></code>’s containing the
distinct prime factors, <code class="docutils literal notranslate"><span class="pre">exp</span></code> an array containing the corresponding
exponents.</p>
<p>The return value is the unfactored cofactor after factoring is done.</p>
<p>The factors are proved prime if <code class="docutils literal notranslate"><span class="pre">proved</span></code> is <span class="math notranslate nohighlight">\(1\)</span>, otherwise
they are merely probably prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pp1">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pp1</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">c</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pp1" title="Link to this definition">¶</a><br /></dt>
<dd><p>Factors <span class="math notranslate nohighlight">\(n\)</span> using Williams’ <span class="math notranslate nohighlight">\(p + 1\)</span> factoring algorithm, with prime
limit set to <span class="math notranslate nohighlight">\(B1\)</span>. We require <span class="math notranslate nohighlight">\(c\)</span> to be set to a random value. Each
trial of the algorithm with a different value of <span class="math notranslate nohighlight">\(c\)</span> gives another
chance to factor <span class="math notranslate nohighlight">\(n\)</span>, with roughly exponentially decreasing chance
of finding a missing factor. If <span class="math notranslate nohighlight">\(p + 1\)</span> (or <span class="math notranslate nohighlight">\(p - 1\)</span>) is not smooth
for any factor <span class="math notranslate nohighlight">\(p\)</span> of <span class="math notranslate nohighlight">\(n\)</span>, the algorithm will never succeed. The
value <span class="math notranslate nohighlight">\(c\)</span> should be less than <span class="math notranslate nohighlight">\(n\)</span> and greater than <span class="math notranslate nohighlight">\(2\)</span>.</p>
<p>If the algorithm succeeds, it returns the factor, otherwise it
returns <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(1\)</span> (the trivial factors modulo <span class="math notranslate nohighlight">\(n\)</span>).</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pp1_wrapper">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pp1_wrapper</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pp1_wrapper" title="Link to this definition">¶</a><br /></dt>
<dd><p>A simple wrapper around <code class="docutils literal notranslate"><span class="pre">n_factor_pp1</span></code> which works in the range
<span class="math notranslate nohighlight">\(31\)</span>-<span class="math notranslate nohighlight">\(64\)</span> bits. Below this point, trial factoring will always succeed.
This function mainly exists for <code class="docutils literal notranslate"><span class="pre">n_factor</span></code> and is tuned to minimise
the time for <code class="docutils literal notranslate"><span class="pre">n_factor</span></code> on numbers that reach the <code class="docutils literal notranslate"><span class="pre">n_factor_pp1</span></code>
stage, i.e. after trial factoring and one line factoring.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pollard_brent_single">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pollard_brent_single</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factor</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">ninv</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">ai</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">xi</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">normbits</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">max_iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pollard_brent_single" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pollard Rho algorithm (with Brent modification) for integer factorization.
Assumes that the <span class="math notranslate nohighlight">\(n\)</span> is not prime. <span class="math notranslate nohighlight">\(factor\)</span> is set as the factor if found.
It is not assured that the factor found will be prime. Does not compute the complete
factorization, just one factor. Returns 1 if factorization is successful
(non trivial factor is found), else returns 0. Assumes <span class="math notranslate nohighlight">\(n\)</span> is normalized,
(shifted by normbits bits), and takes as input a precomputed inverse of <span class="math notranslate nohighlight">\(n\)</span> as
computed by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. <span class="math notranslate nohighlight">\(ai\)</span> and <span class="math notranslate nohighlight">\(xi\)</span> should also be shifted
left by <span class="math notranslate nohighlight">\(normbits\)</span>.</p>
<p><span class="math notranslate nohighlight">\(ai\)</span> is the constant of the polynomial used, <span class="math notranslate nohighlight">\(xi\)</span> is the initial value.
<span class="math notranslate nohighlight">\(max_iters\)</span> is the number of iterations tried in process of finding the
cycle.</p>
<p>The algorithm used is a modification of the original Pollard Rho algorithm,
suggested by Richard Brent in the paper, available at
<a class="reference external" href="https://maths-people.anu.edu.au/~brent/pd/rpb051i.pdf">https://maths-people.anu.edu.au/~brent/pd/rpb051i.pdf</a></p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_pollard_brent">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_pollard_brent</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factor</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_in</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">max_tries</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">max_iters</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_pollard_brent" title="Link to this definition">¶</a><br /></dt>
<dd><p>Pollard Rho algorithm, modified as suggested by Richard Brent. Makes a call to
<a class="reference internal" href="#c.n_factor_pollard_brent_single" title="n_factor_pollard_brent_single"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_pollard_brent_single()</span></code></a>. The input parameters ai and xi for
<a class="reference internal" href="#c.n_factor_pollard_brent_single" title="n_factor_pollard_brent_single"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_factor_pollard_brent_single()</span></code></a> are selected at random.</p>
<p>If the algorithm fails to find a non trivial factor in one call, it tries again
(this time with a different set of random values). This process is repeated a
maximum of <span class="math notranslate nohighlight">\(max_tries\)</span> times.</p>
<p>Assumes <span class="math notranslate nohighlight">\(n\)</span> is not prime. <span class="math notranslate nohighlight">\(factor\)</span> is set as the factor found, if factorization
is successful. In such a case, 1 is returned. Otherwise, 0 is returned. Factor
discovered is not necessarily prime.</p>
</dd></dl>

</section>
<section id="arithmetic-functions">
<h2>Arithmetic functions<a class="headerlink" href="#arithmetic-functions" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_moebius_mu">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_moebius_mu</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_moebius_mu" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Moebius function <span class="math notranslate nohighlight">\(\mu(n)\)</span>, which is defined as <span class="math notranslate nohighlight">\(\mu(n) = 0\)</span>
if <span class="math notranslate nohighlight">\(n\)</span> has a prime factor of multiplicity greater than <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(\mu(n) = -1\)</span>
if <span class="math notranslate nohighlight">\(n\)</span> has an odd number of distinct prime factors, and <span class="math notranslate nohighlight">\(\mu(n) = 1\)</span> if
<span class="math notranslate nohighlight">\(n\)</span> has an even number of distinct prime factors. By convention,
<span class="math notranslate nohighlight">\(\mu(0) = 0\)</span>.</p>
<p>For even numbers, we use the identities <span class="math notranslate nohighlight">\(\mu(4n) = 0\)</span> and
<span class="math notranslate nohighlight">\(\mu(2n) = - \mu(n)\)</span>. Odd numbers up to a cutoff are then looked up from
a precomputed table storing <span class="math notranslate nohighlight">\(\mu(n) + 1\)</span> in groups of two bits.</p>
<p>For larger <span class="math notranslate nohighlight">\(n\)</span>, we first check if <span class="math notranslate nohighlight">\(n\)</span> is divisible by a small odd square
and otherwise call <code class="docutils literal notranslate"><span class="pre">n_factor()</span></code> and count the factors.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_moebius_mu_vec">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_moebius_mu_vec</span></span></span><span class="sig-paren">(</span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">mu</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">len</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_moebius_mu_vec" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes <span class="math notranslate nohighlight">\(\mu(n)\)</span> for <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">...,</span> <span class="pre">len</span> <span class="pre">-</span> <span class="pre">1</span></code>. This
is done by sieving over each prime in the range, flipping the sign
of <span class="math notranslate nohighlight">\(\mu(n)\)</span> for every multiple of a prime <span class="math notranslate nohighlight">\(p\)</span> and setting <span class="math notranslate nohighlight">\(\mu(n) = 0\)</span>
for every multiple of <span class="math notranslate nohighlight">\(p^2\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_is_squarefree">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_is_squarefree</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_is_squarefree" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(0\)</span> if <span class="math notranslate nohighlight">\(n\)</span> is divisible by some perfect square, and <span class="math notranslate nohighlight">\(1\)</span> otherwise.
This simply amounts to testing whether <span class="math notranslate nohighlight">\(\mu(n) \neq 0\)</span>. As special
cases, <span class="math notranslate nohighlight">\(1\)</span> is considered squarefree and <span class="math notranslate nohighlight">\(0\)</span> is not considered squarefree.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_euler_phi">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_euler_phi</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_euler_phi" title="Link to this definition">¶</a><br /></dt>
<dd><p>Computes the Euler totient function <span class="math notranslate nohighlight">\(\phi(n)\)</span>, counting the number of
positive integers less than or equal to <span class="math notranslate nohighlight">\(n\)</span> that are coprime to <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

</section>
<section id="factorials">
<h2>Factorials<a class="headerlink" href="#factorials" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_factorial_fast_mod2_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factorial_fast_mod2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">pinv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factorial_fast_mod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(n! \bmod p\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(p\)</span> as computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. <span class="math notranslate nohighlight">\(p\)</span> is not required to be a prime, but
no special optimisations are made for composite <span class="math notranslate nohighlight">\(p\)</span>.
Uses fast multipoint evaluation, running in about <span class="math notranslate nohighlight">\(O(n^{1/2})\)</span> time.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factorial_mod2_preinv">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factorial_mod2_preinv</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">pinv</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factorial_mod2_preinv" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns <span class="math notranslate nohighlight">\(n! \bmod p\)</span> given a precomputed inverse of <span class="math notranslate nohighlight">\(p\)</span> as computed
by <a class="reference internal" href="#c.n_preinvert_limb" title="n_preinvert_limb"><code class="xref c c-func docutils literal notranslate"><span class="pre">n_preinvert_limb()</span></code></a>. <span class="math notranslate nohighlight">\(p\)</span> is not required to be a prime, but
no special optimisations are made for composite <span class="math notranslate nohighlight">\(p\)</span>.</p>
<p>Uses a lookup table for small <span class="math notranslate nohighlight">\(n\)</span>, otherwise computes the product
if <span class="math notranslate nohighlight">\(n\)</span> is not too large, and calls the fast algorithm for extremely
large <span class="math notranslate nohighlight">\(n\)</span>.</p>
</dd></dl>

</section>
<section id="primitive-roots-and-discrete-logarithms">
<h2>Primitive Roots and Discrete Logarithms<a class="headerlink" href="#primitive-roots-and-discrete-logarithms" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_primitive_root_prime_prefactor">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primitive_root_prime_prefactor</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span>, <span class="n"><span class="pre">n_factor_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">factors</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primitive_root_prime_prefactor" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a primitive root for the multiplicative subgroup of <span class="math notranslate nohighlight">\(\mathbb{Z}/p\mathbb{Z}\)</span>
where <span class="math notranslate nohighlight">\(p\)</span> is prime given the factorisation (<code class="docutils literal notranslate"><span class="pre">factors</span></code>) of <span class="math notranslate nohighlight">\(p - 1\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_primitive_root_prime">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_primitive_root_prime</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">p</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_primitive_root_prime" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns a primitive root for the multiplicative subgroup of <span class="math notranslate nohighlight">\(\mathbb{Z}/p\mathbb{Z}\)</span>
where <span class="math notranslate nohighlight">\(p\)</span> is prime.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_discrete_log_bsgs">
<span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_discrete_log_bsgs</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">b</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">a</span></span>, <span class="n"><span class="pre">ulong</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_discrete_log_bsgs" title="Link to this definition">¶</a><br /></dt>
<dd><p>Returns the discrete logarithm of <span class="math notranslate nohighlight">\(b\)</span> with  respect to <span class="math notranslate nohighlight">\(a\)</span> in the
multiplicative subgroup of <span class="math notranslate nohighlight">\(\mathbb{Z}/n\mathbb{Z}\)</span> when <span class="math notranslate nohighlight">\(\mathbb{Z}/n\mathbb{Z}\)</span>
is cyclic That is,
it returns an number <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(a^x = b \bmod n\)</span>.  The
multiplicative subgroup is only cyclic when <span class="math notranslate nohighlight">\(n\)</span> is <span class="math notranslate nohighlight">\(2\)</span>, <span class="math notranslate nohighlight">\(4\)</span>,
<span class="math notranslate nohighlight">\(p^k\)</span>, or <span class="math notranslate nohighlight">\(2p^k\)</span> where <span class="math notranslate nohighlight">\(p\)</span> is an odd prime and <span class="math notranslate nohighlight">\(k\)</span> is a positive
integer.</p>
</dd></dl>

</section>
<section id="elliptic-curve-method-for-factorization-of-mp-limb-t">
<h2>Elliptic curve method for factorization of <code class="docutils literal notranslate"><span class="pre">mp_limb_t</span></code><a class="headerlink" href="#elliptic-curve-method-for-factorization-of-mp-limb-t" title="Link to this heading">¶</a></h2>
<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_double">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_double</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">x0</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">z0</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_double" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the point <span class="math notranslate nohighlight">\((x : z)\)</span> to two times <span class="math notranslate nohighlight">\((x_0 : z_0)\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span> according
to the formula</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">(x_0</span> <span class="pre">+</span> <span class="pre">z_0)^2</span> <span class="pre">\cdot</span> <span class="pre">(x_0</span> <span class="pre">-</span> <span class="pre">z_0)^2</span> <span class="pre">\mod</span> <span class="pre">n,</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">=</span> <span class="pre">4</span> <span class="pre">x_0</span> <span class="pre">z_0</span> <span class="pre">\left((x_0</span> <span class="pre">-</span> <span class="pre">z_0)^2</span> <span class="pre">+</span> <span class="pre">4a_{24}x_0z_0\right)</span> <span class="pre">\mod</span> <span class="pre">n.</span></code></p>
<p>This group doubling is valid only for points expressed in
Montgomery projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_add">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_add</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">x1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">z1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">x2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">z2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">x0</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">z0</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_add" title="Link to this definition">¶</a><br /></dt>
<dd><p>Sets the point <span class="math notranslate nohighlight">\((x : z)\)</span> to the sum of <span class="math notranslate nohighlight">\((x_1 : z_1)\)</span> and <span class="math notranslate nohighlight">\((x_2 : z_2)\)</span>
modulo <span class="math notranslate nohighlight">\(n\)</span>, given the difference <span class="math notranslate nohighlight">\((x_0 : z_0)\)</span> according to the formula</p>
<p>This group doubling is valid only for points expressed in
Montgomery projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_mul_montgomery_ladder">
<span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_mul_montgomery_ladder</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">x</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">z</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">x0</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">z0</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">k</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_mul_montgomery_ladder" title="Link to this definition">¶</a><br /></dt>
<dd><p>Montgomery ladder algorithm for scalar multiplication of elliptic points.</p>
<p>Sets the point <span class="math notranslate nohighlight">\((x : z)\)</span> to <span class="math notranslate nohighlight">\(k(x_0 : z_0)\)</span> modulo <span class="math notranslate nohighlight">\(n\)</span>.</p>
<p>Valid only for points expressed in Montgomery projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_select_curve">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_select_curve</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">sigma</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_select_curve" title="Link to this definition">¶</a><br /></dt>
<dd><p>Selects a random elliptic curve given a random integer <code class="docutils literal notranslate"><span class="pre">sigma</span></code>,
according to Suyama’s parameterization. If the factor is found while
selecting the curve, <span class="math notranslate nohighlight">\(1\)</span> is returned. In case the curve found is not
suitable, <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
<p>Also selects the initial point <span class="math notranslate nohighlight">\(x_0\)</span>, and the value of <span class="math notranslate nohighlight">\((a + 2)/4\)</span>, where <span class="math notranslate nohighlight">\(a\)</span>
is a curve parameter. Sets <span class="math notranslate nohighlight">\(z_0\)</span> as <span class="math notranslate nohighlight">\(1\)</span> (shifted left by
<code class="docutils literal notranslate"><span class="pre">n_ecm_inf-&gt;normbits</span></code>. All these are stored in the
<code class="docutils literal notranslate"><span class="pre">n_ecm_t</span></code> struct.</p>
<p>The curve selected is of Montgomery form, the points selected satisfy the
curve and are projective coordinates.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_stage_I">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_stage_I</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">prime_array</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">num</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_stage_I" title="Link to this definition">¶</a><br /></dt>
<dd><p>StageI implementation of the ECM algorithm.</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is set as the factor if found. <code class="docutils literal notranslate"><span class="pre">num</span></code> is number of prime numbers
<span class="math notranslate nohighlight">\(&lt;=\)</span> the bound <code class="docutils literal notranslate"><span class="pre">B1</span></code>. <code class="docutils literal notranslate"><span class="pre">prime_array</span></code> is an array of first <code class="docutils literal notranslate"><span class="pre">B1</span></code>
primes. <span class="math notranslate nohighlight">\(n\)</span> is the number being factored.</p>
<p>If the factor is found, <span class="math notranslate nohighlight">\(1\)</span> is returned, otherwise <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm_stage_II">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm_stage_II</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">B2</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">P</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span>, <span class="n"><span class="pre">n_ecm_t</span></span><span class="w"> </span><span class="n"><span class="pre">n_ecm_inf</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm_stage_II" title="Link to this definition">¶</a><br /></dt>
<dd><p>StageII implementation of the ECM algorithm.</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is set as the factor if found. <code class="docutils literal notranslate"><span class="pre">B1</span></code>, <code class="docutils literal notranslate"><span class="pre">B2</span></code> are the two
bounds. <code class="docutils literal notranslate"><span class="pre">P</span></code> is the primorial (approximately equal to <span class="math notranslate nohighlight">\(\sqrt{B2}\)</span>).
<span class="math notranslate nohighlight">\(n\)</span> is the number being factored.</p>
<p>If the factor is found, <span class="math notranslate nohighlight">\(1\)</span> is returned, otherwise <span class="math notranslate nohighlight">\(0\)</span>.</p>
</dd></dl>

<dl class="c function">
<dt class="sig sig-object c" id="c.n_factor_ecm">
<span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">n_factor_ecm</span></span></span><span class="sig-paren">(</span><span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n"><span class="pre">f</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">curves</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">B1</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">B2</span></span>, <a class="reference internal" href="flint.html#c.flint_rand_t" title="flint_rand_t"><span class="n"><span class="pre">flint_rand_t</span></span></a><span class="w"> </span><span class="n"><span class="pre">state</span></span>, <span class="n"><span class="pre">mp_limb_t</span></span><span class="w"> </span><span class="n"><span class="pre">n</span></span><span class="sig-paren">)</span><a class="headerlink" href="#c.n_factor_ecm" title="Link to this definition">¶</a><br /></dt>
<dd><p>Outer wrapper function for the ECM algorithm. It factors <span class="math notranslate nohighlight">\(n\)</span> which
must fit into a <code class="docutils literal notranslate"><span class="pre">mp_limb_t</span></code>.</p>
<p>The function calls stageI andII, and
the precomputations (builds <code class="docutils literal notranslate"><span class="pre">prime_array</span></code> for stageI,
<code class="docutils literal notranslate"><span class="pre">GCD_table</span></code> and <code class="docutils literal notranslate"><span class="pre">prime_table</span></code> for stageII).</p>
<p><code class="docutils literal notranslate"><span class="pre">f</span></code> is set as the factor if found. <code class="docutils literal notranslate"><span class="pre">curves</span></code> is the number of
random curves being tried. <code class="docutils literal notranslate"><span class="pre">B1</span></code>, <code class="docutils literal notranslate"><span class="pre">B2</span></code> are the two bounds or
stageI and stageII. <span class="math notranslate nohighlight">\(n\)</span> is the number being factored.</p>
<p>If a factor is found in stageI, <span class="math notranslate nohighlight">\(1\)</span> is returned.
If a factor is found in stageII, <span class="math notranslate nohighlight">\(2\)</span> is returned.
If a factor is found while selecting the curve, <span class="math notranslate nohighlight">\(-1\)</span> is returned.
Otherwise <span class="math notranslate nohighlight">\(0\)</span> is returned.</p>
</dd></dl>

</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a><ul>
<li><a class="reference internal" href="#random-functions">Random functions</a></li>
<li><a class="reference internal" href="#basic-arithmetic">Basic arithmetic</a></li>
<li><a class="reference internal" href="#miscellaneous">Miscellaneous</a></li>
<li><a class="reference internal" href="#basic-arithmetic-with-precomputed-inverses">Basic arithmetic with precomputed inverses</a></li>
<li><a class="reference internal" href="#greatest-common-divisor">Greatest common divisor</a></li>
<li><a class="reference internal" href="#jacobi-and-kronecker-symbols">Jacobi and Kronecker symbols</a></li>
<li><a class="reference internal" href="#modular-arithmetic">Modular Arithmetic</a></li>
<li><a class="reference internal" href="#divisibility-testing">Divisibility testing</a></li>
<li><a class="reference internal" href="#prime-number-generation-and-counting">Prime number generation and counting</a></li>
<li><a class="reference internal" href="#primality-testing">Primality testing</a></li>
<li><a class="reference internal" href="#chinese-remaindering">Chinese remaindering</a></li>
<li><a class="reference internal" href="#square-root-and-perfect-power-testing">Square root and perfect power testing</a></li>
<li><a class="reference internal" href="#factorisation">Factorisation</a></li>
<li><a class="reference internal" href="#arithmetic-functions">Arithmetic functions</a></li>
<li><a class="reference internal" href="#factorials">Factorials</a></li>
<li><a class="reference internal" href="#primitive-roots-and-discrete-logarithms">Primitive Roots and Discrete Logarithms</a></li>
<li><a class="reference internal" href="#elliptic-curve-method-for-factorization-of-mp-limb-t">Elliptic curve method for factorization of <code class="docutils literal notranslate"><span class="pre">mp_limb_t</span></code></a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="mpoly.html"
                          title="previous chapter"><strong>mpoly.h</strong> – support functions for multivariate polynomials</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="fmpz.html"
                          title="next chapter"><strong>fmpz.h</strong> – integers</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ulong_extras.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
<div id="sidebarbutton" title="Collapse sidebar">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="fmpz.html" title="fmpz.h – integers"
             >next</a> |</li>
        <li class="right" >
          <a href="mpoly.html" title="mpoly.h – support functions for multivariate polynomials"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Flint 2.9.0 documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><strong>ulong_extras.h</strong> – arithmetic and number-theoretic functions for single-word integers</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
    &#169; Copyright 2018, The Flint development team.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    </div>
  </body>
</html>